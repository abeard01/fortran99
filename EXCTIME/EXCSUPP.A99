	LIST
	TITL 'SUPPORT UTILITIES FOR MDOS VERSION'
	PAGE
*
*		OPFILE - OPEN FILE ROUTINE
*		IO     - INPUT/OUTPUT ROUTINE
*		INIT   - INITIALIZE FOR I/O, MEMORY PAGES
*		MENU   - EXIT FOR ALL PROGRAMS (BACK TO MDOS)
*		SCSN   - CONVERT STRING TO FLOATING POINT
*
*
*  SCSN- Convert String to Number routine.  This routine is called
*        instead of the low memory routine since the low memory
*        routine does not work well on the Geneve.
*
*  Update History:
*
*   Version 4.0    ????        Initial Release
*
*           4.41   04-Jan-90   Update for debug display of STOP
*
*
ESCSN	EQU  $			CONVERT STRING TO NUMBER
	MOV  @2(R13),R5		Get user FAC address
	CLR  *R5+		5 words (4 plus overflow)
	CLR  *R5+
	CLR  *R5+
	CLR  *R5+
	MOV  @4(R13),R6		Get user string address
	MOVB *R6+,R8		Get the byte
	SRL  R8,8		in lbyte R8
	CLR  @MINUSF		reset minus flag
	MOV  R6,R2
	CI   R8,>002B		ASCII +
	JEQ  CSNPLU
	CI   R8,>002D		ASCII -
	JNE  CSNMIN		No sign
	SETO @MINUSF		Set negate flag
CSNPLU	EQU  $
	INC  R2			Fix length
CSNPL1	EQU  $
	MOVB *R6+,R8		Get byte
	SRL  R8,8		in low byte
CSNMIN	EQU  $
	CI   R8,>0030		0?
	JEQ  CSNPL1		Yes, skip it
	MOV  R6,R12		Save string start
	DEC  R12		right address
	SETO R7
	JMP  CSNCO2
CSNCO1	EQU  $
	INC  R7
	MOVB *R6+,R8		Get character
	SRL  R8,8		in low byte
CSNCO2	EQU  $
	CI   R8,>0030		Compare, if character 0 through 9
	JL   CSNPTO
	CI   R8,>0039
	JLE  CSNCO1		Get another character
CSNPTO  EQU  $
	CI   R8,>002E		Decimal Point?
	JNE  CSNCO6
	INC  R2			Compute digit left of point
	MOV  R7,R7
	JLT  CSNCO4
	JMP  CSNC4A
CSNCO3	EQU  $
	DEC  R7
CSNCO4	EQU  $
	MOVB *R6+,R8
	SRL  R8,8		Get a character
	CI   R8,>0030		0?
	JEQ  CSNCO3
	DEC  R6
	MOV  R6,R12
CSNC4A  EQU  $
	MOVB *R6+,R8
	SRL  R8,8
	CI   R8,>0030
	JL   CSNCO5
	CI   R8,>0039
	JLE  CSNC4A
CSNCO5	EQU  $
	C    R6,R2		End of number
	JEQ  CSNRD2		Set zero
CSNCO6	EQU  $
	MOV  R6,R2
	CLR  R4
	DEC  R2			Correction
	CLR  R1
	CI   R8,>0045		'E' for Exponent?
	JNE  CSNEX3
	MOVB *R6+,R8
	SRL  R8,8		Get next character
	CI   R8,>002B		Sign of exponent (+)
	JEQ  CSNEX2
	CI   R8,>002D		(-)
	JNE  CSNEX1
	DEC  R1
	JMP  CSNEX2
CSNEX1	EQU  $
	DEC  R6
CSNEX2  EQU  $
	BL   @CSNINT		Convert integer exponent
	MOVB R1,R1		Negative number
	JEQ  CSNEX3
	NEG  R4
CSNEX3	EQU  $
	DEC  R6
	MOV  R6,@CSNPTR
	C    R12,R2
	JEQ  CSNRD2		Set FAC=0 and return
	AI   R4,>0080		Correct Exponent
	CLR  R1
	A    R7,R4
	MOV  R4,R7
	SRA  R4,1		Exponent :2, Bias 100!
	MOV  R4,@EXPONF
	SRC  R7,1
	LI   R5,>0008		8 digits of the number
	MOV  @2(R13),R0		Get user FAC address again
	INC  R0
	MOV  R12,R6		Address, begin number in R5
CSNDO1	EQU  $
	C    R6,R2
	JEQ  CSNDO4		Brif done
	MOVB *R6+,R8
	SRL  R8,8
	CI   R8,>002E		Point?
	JEQ  CSNDO1		Next character.
	AI   R8,>FFD0		ASCII Correction
	INV  R7
	JLT  CSNDO3
CSNDO2	EQU  $
	MPY  @K10,R8		*10
	CLR  R1
	SWPB R9
	MOVB R9,R1		R9 Lbyte in R1
	JMP  CSNDO1
CSNDO3	EQU  $
	SWPB R8
	AB   R8,R1		R8 Lbyte add to R1
CSNDO4  EQU  $
	MOVB R1,*R0+		R1 on FAC
	CLR  R1
	DEC  R5			All digits
	JNE  CSNDO1
CSNDON	EQU  $			Rounding and done
	LI   R0,>3200		Decimal 50
	MOV  @2(R13),R1		compare (with user result address)
	C    @8(R1),R0
	JLT  CSNRD1
	LI   R1,7
	LI   R2,>0100
	LI   R0,>6400		Decimal 100
CSNRD0	EQU  $
	MOV  @2(R13),R3
	A    R1,R3
	AB   R2,*R3
	CB   *R3,R0
	JL   CSNRD1		Smaller 100, then end
	SB   R0,*R3		Minus 100
	DEC  R1
	JGT  CSNRD0
	INC  @EXPONF		Increase Exponent
	MOV  @2(R13),R3
	MOVB R2,@1(R3)		1 on first digit
CSNRD1	EQU  $
	MOV  @EXPONF,R3		Fetch Exponent
	CI   R3,>0080		Too big?
	JHE  CSNERR		Error, number too big
	SWPB R3
	MOV  @2(R13),R2
	MOVB R3,*R2		Set exponent
	ABS  @MINUSF		get minus flag
	JEQ  CSNRD2		brif not negative
	MOV  @2(R13),R2
	NEG  *R2
CSNRD2	EQU  $
	LI   R1,0		Return no error
	JMP  CSNRD3
CSNERR	EQU  $
	LI   R1,1		Return error
CSNRD3	EQU  $
	STST R15
	RTWP			Return
*
*  CSNINT - Convert String to Number, Convert Exponent
*
CSNINT	EQU  $
	CLR  R4
	CLR  R0
	MOV  R11,R9		Save return
	JMP  CSNIN1
CSNIN0	EQU  $
	MPY  @K10,R4		*10
	MOV  R4,R4		Overflow?
	JNE  CSNERR		brif yes, its an error
	INC  R0
	A    R8,R5
	MOV  R5,R4
	JLT  CSNERR		Negative, error
CSNIN1	EQU  $
	MOVB *R6+,R8		Get a character
	SRL  R8,8
	AI   R8,>FFD0		Ascii correction
	CI   R8,10		Smaller 10?
	JL   CSNIN0		No, go on
	MOV  R0,R0
	JEQ  CSNERR		Overflow
	B    *R9		Return
*
*  INIT - INIT is called upon entry of the task.  It sets up the
*	  input/output (IO) tables, and sets the cntrl/s on print flag.
*
*	  Calling Sequence:
*
*	  BLWP @INIT
*	  DATA BUFFER_AREA_START	; Free buffer start
*	  DATA SCREEN_BUFFER_SIZE	; Bytes
*	  DATA IO_BUFFER_SIZE		; Bytes
*	  DATA NUMBER_IO_TABLES
*
EINIT	EQU  $			; INITIALIZE ROUTINE
*
*  Clear local I/O table.  The I/O table contains the device number
*  to device translations, the I/O buffer addresses, the PAB addresses,
*  and the device types.
*
	SETO @PRINTC		; SET CHECK CNTRL/S AFTER PRINT
	MOV  *R14,@SIOBUF	; SCREEN I/O BUFFER
	MOV  *R14+,R5		; GET IT AGAIN
	A    *R14,R5		; ADD SCREEN BUFFER SIZE
	MOV  *R14+,@SCRBFS	; AND SAVE IT
	MOV  R5,@IIOBUF		; INPUT/OUTPUT BUFFER
	A    *R14,R5		; ADD I/O BUFFER SIZE
	MOV  *R14+,@IOBUFS	; SAVE IT
	MOV  R5,@IOTABL		; I/O TABLE START
	MOV  *R14,@NOIOTA	; NUMBER OF I/O TABLES
	MOV  *R14+,R6
IOTCLR	EQU  $
	MOV  R5,R4		; START OF ENTRY
	CLR  *R5+		; CLEAR 1ST WORD
	AI   R4,8
	MOV  R4,*R5+		; SET ADDRESS FOR PAB
	AI   R4,PABFLN		; FILE NAME START
	MOV  R4,*R5+
	LI   R7,IOTLEN		; GET REMAINDER TO CLEAR
	AI   R7,-6		; EXCEPT 6 BYTES I ALREADY SET
IOTCL1	EQU  $
	CLR  *R5+		; CLEAR A WORD
	DECT R7
	JNE  IOTCL1		; BRIF MORE THIS ENTRY
	DEC  R6			; DECR ENTRY
	JNE  IOTCLR		; BRIF MORE ENTRIES
	MOV  R5,@FREMEM		; FREE MEMORY START
	RTWP
*
*  ALLMEM : ALLOCATE THE REQUESTED AMOUNT OF MEMORY
*
*   ENTRY REGISTERS:
*
*     R0 :  IS THE NUMBER OF BYTES TO ALLOCATE
*
*   EXIT REGISTERS:
*
*     R0 :  IS THE START ADDRESS OF MEMORY ALLOCATED
*
EALLME	EQU  $
	MOV  @FREMEM,R5		GET FREE MEMORY START
	A    *R13,R5		ADD IN CURRENT MEMORY POINTER
	JGT  GETERR		BRIF ERROR
	JEQ  GETERR
	ABS  @PDEBUG		AM I RUNNING UNDER DEBUGGER?
	JEQ  ALLME1		BRIF NO
	CI   R5,MEMDEB		MAKE SURE I'M NOT PAST END OF DEBUG
	JEQ  GETERR
	JGT  GETERR		BRIF YES, ERROR
ALLME1	EQU  $
	MOV  @FREMEM,*R13	STILL NEGATIVE, MUST BE OK
	MOV  R5,@FREMEM		UPDATE MEMORY POINTER
	CLR  R0
	JMP  ALLDON
GETERR	EQU  $
	SETO R0
ALLDON	EQU  $
	MOV  R0,R0		SET STATUS FOR RETURN
	STST R15
	RTWP
*
*  EPRNTC : CHANGE STATE OF CHECK CNTRL/S AFTER PRINT FLAG (PRINTC)
*	    NEW VALUE IN USER R0.
*
EPRNTC	EQU  $
	MOV  *R13,@PRINTC	SET IT
	RTWP			SIMPLE, WASN'T IT?
*
*  EDEBMO : ENTER DEBUGGER MODE
*
EDEBMO	EQU  $
	MOV  *R13,@IDEBUG	SET OR RESET DEBUG MODE FLAG
	RTWP
*
*  WAIT: WAIT FOR A KEYPRESS FROM THE USER TO CONTINUE
*
EWAIT	EQU  $
	LI   R5,WAIMSG		WAIT FOR USER
	MOV  @SIOBUF,R6		MOVE MESSAGE
	CLR  R2
EWAIT1	EQU  $
	INC  R2
	MOVB *R5+,*R6+
	JNE  EWAIT1		DO UNTIL NULL
	DEC  R2
	MOV  @SIOBUF,R1		WRITE ADDRESS BUFFER
	MOV  @IDEBUG,R0		WAS ANY USER XOP REQUESTED?
	JEQ  EWAIT2		BRIF NO, USE STANDARD MDOS XOP
	BL   *R0		ELSE, USE USER IOP
	JMP  KEYLOW
EWAIT2	EQU  $
	LI   R0,WRITET		WRITE TTY
	XOP  @DVIDXP,0		DO IT
KEYLOW	EQU  $
	CLR  R0			KEYBOARD MODE
	XOP  @DKEYXP,0		GET A KEY
	JNE  KEYLOW		BRIF NO KEY DEPRESSED
	CB   R1,@KFF		WAS IT A BREAK?
	JEQ  WAIEXI		BRIF YES, GET OUT
	ANDI R1,>7F00
	CB   R1,@KCR		WAS IT A CARRIAGE RETURN?
	JNE  KEYLOW		NO, HOLD HERE
WAIEXI	EQU  $
	RTWP
*
*  CLOSA$ : CLOSE ALL OPEN FILES, TO LOAD NEW TASK
*
ECLOSA	EQU  $
	BL   @CLOSIT		CLOSE ALL FILES
	RTWP			AND RETURN
*
*  MENU$: EXIT USER TASK (FIRST CLOSE ANY OPEN FILES)
*
*  NOTE:  R12 ON ENTRY CONTAINS LOCATION OF WHERE IN THE USER PROGRAM
*         THE STOP WAS CALLED (FROM STOP$, NSTOP$ AND CALL EXIT).  DO
*         NOT DESTROY R12, SINCE DEBUGGER NEEDS IT FOR DISPLAY.
*
MENU$	EQU  $
	BL   @CLOSIT		CLOSE ALL FILES
	MOV  R12,R11		FOR DISPLAY IN DEBUGGER
	ABS  @PDEBUG
	JEQ  MENUEX		NOT RUNNING UNDER DEBUGGER, JUST EXIT
	XOP  R2,DEBXOP		ELSE, EXECUTE XOP TO RETURN
MENUEX	EQU  $
	LIMI 2			ENSURE INTERRUPTS ARE ENABLED
	BLWP @0			RETURN TO MDOS
*
*  CLOSIT : CLOSE ALL OPEN FILES (CALLED BY FORTRAN EXIT LOGIC, AND
*	    CHAIN LOGIC).
*
*  CLEAR THE I/O TABLES, CLOSE EACH FILE WHICH MAY BE OPEN.
*
CLOSIT	EQU  $
	MOV  @NOIOTA,R9		# OF I/O TABLES
	MOV  @IOTABL,R10	I/O TABLE START
INILOP	EQU  $
	MOV  *R10,@ALCLOS+2
	JEQ  NOCLOS		BRIF NOTHING HERE
	LI   R4,ALCLOS
	BLWP @CIO$		CLOSE THE FILE
	CLR  *R10		ENSURE LOGICAL DEVICE # ZAPPED
NOCLOS	EQU  $
	AI   R10,IOTLEN		SKIP TO NEXT
	DEC  R9	   		DECR TABLE #
	JNE  INILOP		BRIF MORE
	B    *R11		RETURN
*
	TITL 'I/O ROUTINES'
	PAGE
*
*  THIS MODULE CONTAINS THE GENERAL I/O ROUTINES.
*
*
*  OPFILE - OPEN A FILE ROUTINE
*
*  THIS ROUTINE IS CALLED TO OPEN A FILE FOR ACCESS.
*
*  CALLING SEQUENCE:
*
*	LI  R0,FILE#	NUMBER OF FILE TO OPEN
*	LI  R1,PABADR	PAB ADDRESS IN CPU RAM
*       BLWP @OPFILE    OPEN FILE
*
*  OPFILE WILL ADD THE REQUESTED DEVICE TO THE IOTABL, AND
*  OPEN THE FILE VIA THE DSRLNK ROUTINE.
*
*  ERRORS ARE RETURNED IN R1 (LOBYTE, RIGHT JUSTIFIED)
*
EOPFIL	EQU  $
	MOV  *R13,R0		GET OLD USER R0
	MOV  @2(R13),R1		GET OLD USER R1
	MOV  R0,R0
	JEQ  INVDVE		INVALID DEVICE
	BL   @FNDFRR		FIND FREE PACKET
	JMP  SETFRR		SET FREE PACKET
	NOP			ALREADY EXISTS
INVDVE	EQU  $
	CLR  R2
	LI   R1,BUFFUL		RETURN ERROR
	JMP  BIORRT		RETURN
*
SETFRR	EQU  $			FOUND FREE I/O TABLE SLOT
	MOV  R0,*R6		SET FILE #
*				GET RAM ADDRESS OF PAB
	MOV  @IOTPAB(R6),R0	MOVE TO ADDRESS
	MOV  *R1+,*R0+		MOVE OPCODE AND FLAGS
	CLR  *R0+		CLEAR ERROR CODE & HIGH BYTE ADDRESS
	MOV  @IIOBUF,R2		INPUT/OUTPUT BUFFER
	MOV  R2,*R0+		SET CPU BUFFER ADDRESS IN PAB
	INCT R1			SKIP PAST USELESS ADDRESS IN USER PAB
	MOV  *R1+,R2		GET LOGICAL RECORD LENGTH, CHAR COUNT
	MOV  *R1+,*R0+		MOVE RECORD NUMBER
	MOV  R2,R3		EXTRACT RECORD LENGTH
	SWPB R3
	ANDI R3,>00FF
	MOV  R3,*R0+		MOVE RECORD LENGTH
	CLR  *R0+		CLEAR CPU & HIGH CHAR COUNT FLAG
	ANDI R3,>00FF		MASK CHARACTER COUNT
	MOV  R3,*R0+
	CLR  R3
	MOVB R3,*R0+		CLEAR STATUS BYTE
	INC  R1			SKIP USELESS SCREEN OFFSET BYTE
*
*   PAB WITH THE EXCEPTION OF THE FILE NAME HAS BEEN MOVED.  BEFORE
*   MOVING THE FILE NAME, CHECK TO SEE IF IT IS A CRT OR CONSOLE DEVICE,
*   IDENTIFIED BY A TWO OR THREE CHARACTER FILE NAME, AND THE FIRST TWO
*   CHARACTERS BEING 'CR'.
*
*   SPECIAL HANDLING MUST ALSO BE PERFORMED FOR 'RS232' AND 'PIO' DEVICES.
*
	CLR  R5			GET # BYTES TO PARSE
	MOVB R5,*R0		CLEAR RESULTING STRING
	MOV  R1,R4		GET DEVICE NAME START
	MOVB *R4+,R5		GET LENGTH OF INPUT STRING
	JEQ  OPRETU		BRIF NULL FILE HERE (NOTHING TO DO)
	SWPB R5
	CI   R5,2		BE PICKY ABOUT DEVICE NAME
	JLT  PARSIT		BRIF < 2 BYTES, PARSE NAME
	MOVB *R4+,R2		CHECK DEVICE NAME
	SWPB R2
	MOVB *R4+,R2
	SWPB R2			DEVICE NAME NOW IN R6
	LI   R3,SPEDEV		CHECK SPECIAL DEVICES
	C    *R3+,R2		IS IT THE CRT?
	JEQ  OPECRT		BRIF YES
	C    *R3+,R2		IS IT THE RS232 DEVICE?
	JNE  CHKPIO		BRIF NO, CHECK THE PIO DEVICE
	CB   *R3+,*R4+		'2'
	JNE  PARSIT
	CB   *R3+,*R4+		'3'
	JNE  PARSIT
	CB   *R3+,*R4+		'2'
	JNE  PARSIT
	CB   *R3+,*R4+		'/'
	JNE  PARSIT
	JMP  SKIPAR
*
CHKPIO	EQU  $
	INCT R3
	INCT R3			SKIP 2 WORDS FOR PIO CHECK
	C    *R3+,R2		IS IT THE PIO DEVICE?
	JNE  PARSIT		BRIF NO, PARSE THE DEVICE NAME
	CB   *R3+,*R4+		CHECK LAST BYTE
	JNE  PARSIT
*
SKIPAR	EQU  $
	MOVB *R1+,*R0+		MOVE LENGTH BYTE
OPFMOV	EQU  $
	MOVB *R1+,*R0+		MOVE THE DEVICE NAME
	DEC  R5
	JNE  OPFMOV
	MOV  @IOTPAB(R6),R2	GET PAB ADDRESS AGAIN
	SOC  @KX80,*R2		OR IN BIT TO SAY TAKE SWITCH SETTINGS
	JMP  PARSNO
*
OPECRT	EQU  $			OPEN CRT DEVICE (NON-DSR)
	MOVB *R1+,*R0+		MOVE THE DEVICE NAME OF 'CRT'
	MOVB *R1+,*R0+
	MOVB *R1+,*R0+
	MOVB *R1+,*R0+
	JMP  PARSNO		AND EXIT
*
*  I DON'T KNOW WHAT KIND OF DEVICE IT IS.  CALL THE PARSE DEVICE
*  ROUTINE TO PARSE IT.
*
PARSIT	EQU  $
	CLR  R5			GET LENGTH OF INPUT STRING
	MOVB *R1+,R5		GET IT
	SWPB R5
	A    R1,R5		POINT TO BYTE PAST INPUT STRING
	CLR  R4
	MOVB R4,*R5		MAKE STRING NULL TERMINATED (IN USER BUFFER)
	MOV  R0,R2		POINTER TO LENGTH BYTE IN OUTPUT STRING
	CLR  R3
	LI   R5,>2000		SIZE OF OUTPUT STRING
	MOVB R5,*R2
	LI   R0,PARFIL		PARSE FILE
	XOP  @DUTXOP,0		DO IT
	MOV  R1,R1		ANY ERROR?
	JNE  INVDVE		BRIF NO, INVALID DEVICE
*
PARSNO	EQU  $
	MOV  @IOTPAB(R6),R1	GET PAB FILE NAME ADDRESS START
	MOV  @PABTXT(R1),R1	GET FILE NAME (1ST TWO CHARS)
	CLR  R4	   		ASSUME DISK TYPE
	LI   R5,DSKSS		COMPARE ALL TYPES
DSKLOP  EQU  $
	MOV  *R5+,R7		GET TABLE ENTRY
	JEQ  NOTDSK		BRIF NOT A DISK
	C    R1,R7
	JNE  DSKLOP		BRIF NOT THIS ONE
	JMP  STIOTY
NOTDSK  EQU  $
	INCT R4	   		ASSUME SCREEN TYPE
	C    R1,@SCRDEV		IS IT THE CRT?
	JEQ  STIOTY		BRIF YES
	INC  R4	   		ELSE, ASSUME LISTING DEVICE
STIOTY	EQU  $
	MOV  R4,@IOTTYP(R6)
*
	CI   R4,SCRTYP		IS IT THE SCREEN?
	JEQ  OPRETU
*
JMPIOT	EQU  $			SET I/O DESCRIPTOR
	MOV  @IOTPAB(R6),R0	ADDRESS OF PAB
	XOP  @DIOXOP,0		OPEN THE DEVICE
	MOV  @IOTPAB(R6),R2	GET ERROR (IF ANY)
	CLR  R1
	MOVB @PABERR(R2),R1	ANY ERROR?
	JEQ  OPRETU		BRIF NO ERROR
	SWPB R1			ELSE, JUSTIFY ERROR NUMBER IN LOW
	SRA  R1,5		 BYTE FOR ERROR PRINTOUT
	INC  R1
	JMP  IORRT1
*
OPRETU	EQU  $
	CLR  R1
	JMP  IORRT1
BIORRT	EQU  $
	JMP  IORRT2
*
*  IO - INPUT/OUTPUT ROUTINE
*
*  THIS ROUTINE HANDLES GENERAL PURPOSE I/O FROM A USER
*  PASSED COMMAND LIST.
*
*  CALLING SEQUENCE:
*
*	LI   R4,CMDLST
*	BLWP @IO
*
*  WHERE:
*
*	CMDLST - IS AN UP TO FIVE WORD COMMAND LIST AS FOLLOWS:
*
*		0  -  FUNCTION		 (ALL)
*		1  -  FILE NUMBER	 (ALL)
*		2  -  I/O BUFFER ADDRESS (FOR READS/WRITES)
*		3  -  # BYTES OF I/O     (FOR READS/WRITES)
*		4  -  RECORD # 		 (FOR REL. I/O ONLY)
*
*	RETURNS:
*		a. Returned I/O buffer at I/O buffer address
*		b. R0 - # bytes actually read (0 to 255, reads only)
*		c. R1 - any error condition (0=none, 1 to 10)
*		d. R2 - if error, has pointer to VDP file name
*
EIO  	EQU  $
	MOV  @8(R13),R4		GET OLD USER R4
*
REIOEN	EQU  $
	MOV  @IOLABE(R4),R0
	JEQ  SETINV		0 LABEL INVALID
	BL   @FNDFRR		SEARCH I/O TABLE FOR #
	JMP  SETINV		FREE PACKET FOUND
	JMP  IOTFND		FILE FOUND
SETINV	EQU  $			ALL PACKETS IN USE
	CLR  R2
	LI   R1,INVDEV		INVALID DEVICE OR FILE
	JMP  IORRT2		RETURN
*
IOTFND	EQU  $			FOUND IO TABLE PACKET
	CLR  R1			IN CASE DUMMY, NO ERROR POSSIBLE
	MOV  @IOTDSR(R6),R0
	MOVB *R0,R1
	JEQ  IORRT1		BRIF DUMMY FILE HERE
	MOV  *R4,R3		GET I/O LABEL
	ANDI R3,>800		RELATIVE I/O ?
	JEQ  NOTREL		BRIF NOT
*				MOVE RECORD NUMBER
	MOV  @IOTPAB(R6),R1
	MOV  @PABCHC(R1),@IOBYTE(R4)
	MOV  @IORCNO(R4),@6(R1)
*
NOTREL	EQU  $
	LI   R7,PFORMA		SEARCH FORMAT CODE
	MOV  *R4,R3		GET FUNCTION/TYPE
	ANDI R3,>FF		MASK FUNCTION
FORLOP	EQU  $			FIND FUNCTION
	C    *R7,R3		IS IT THE SAME ?
	JEQ  FOREND		BRIF YES
	AI   R7,6	 	ELSE, SKIP TO NEXT
	MOV  *R7,R5
	JGT  FORLOP		BRIF MORE
	LI   R1,INVCAL		ELSE, INVALID CALL
	JMP  IORRT2		RETURN
FOREND	EQU  $
	CLR  R1	   		CLEAR ERROR
	INCT R7	   		CALL PRE-FORMAT ROUTINE
	MOV  *R7,R2
	B    *R2
*				CALL DSRLNK FOR I/O
CALDSR  EQU  $
	MOV  @IOTPAB(R6),R2
	MOVB R1,*R2
	MOV  @IOTTYP(R6),R2
	SLA  R2,1	 	*2
	AI   R2,BTYPET		BRANCH TABLE
	MOV  *R2,R2
	B    *R2	  	EXECUTE FUNCTION
*
RETDSR  EQU  $
	JNE  IORRT2		BRIF I/O ERROR OCCURED
	INCT R7			BUMP POINTER TO POST FORMAT ROUTINE
	MOV  *R7,R2		GET ROUTINE ADDRESS
	JEQ  IORRT1		BRIF NONE
	CLR  R1			ELSE, EXECUTE ROUTINE
	B    *R2	  	EXECUTE POST-FORMAT ROUTINE
*
IORRT1  EQU  $
	MOV  R1,R1
	JEQ  IORRT3		BRIF NO ERROR
IORRT2  EQU  $
	MOV  @IOTDSR(R6),R2	GET PAB ADDRESS IN VDP ARM
	MOV  R2,@4(R13)		MOVE TO USER R2
IORRT3  EQU  $
	ANDI R1,>FF		SET EQUAL BIT
	MOV  R1,@2(R13)		PUT ERROR CODE (IF ANY) IN USER R1
	STST R15		SAVE STATUS
	RTWP			RETURN
*
**************************
*			 *
*  PRE- FORMAT ROUTINES  *
*			 *
**************************
*
PRREAD	EQU  $			PRE-READ FORMAT
	LI   R1,OPCREA*256	SET FUNCTION=READ
	JMP  PRERET
*
PRREWI	EQU  $
	LI   R1,OPCRES*256	PRE-REWIND FORMAT
	JMP  PRERET
*
PRCLOS	EQU  $			PRE-CLOSE FILE
	LI   R1,OPCCLO*256	SET FUNCTION=CLOSE
	JMP  CLARET
*
PRDELE	EQU  $			PRE-DELETE FILE
	LI   R1,OPCDEF*256	SET FUNCTION=DELETE
CLARET	EQU  $
	CLR  *R6	  	CLEAR THIS IOTABLE (UNUSED)
PRERET	B    @CALDSR		RETURN
*
PRWRIB	EQU  $			PRE-WRITE BINARY
	MOV  @IOBUFA(R4),R2	GET BUFFER ADDRESS
	MOV  @IOBYTE(R4),R3	GET NUMBER OF BYTES
	JMP  PRWRAB		DON'T TRIM ANYTHING
*
PRWRIA	EQU  $			PRE-WRITE ASCII
	MOV  @IOTTYP(R6),R3
	CI   R3,DSKTYP		IS IT LISTING TYPE ?
	JNE  ISTPRI		BRIF PRINTER
	MOV  @IOBUFA(R4),R2     GET BUFFER ADDRESS
	MOV  @IOBYTE(R4),R3	GET NUMBER OF BYTES
	BL   @TRIMBY		TRIM BYTES FROM BUFFER
	INC  R3			ADD BACK IN 1ST BYTE
PRWRAB  EQU  $
	MOV  @IIOBUF,R0
	MOV  R2,R1		SAVE I/O BUFFER ADDRESS
	MOV  R3,R2		NUMBER OF BYTES OF I/O
	JNE  PRWRAA		BRIF SOMETHING HERE
	INC  R2			MUST BE AT LEAST ONE BYTE
PRWRAA  EQU  $
	MOV  R2,R12		BYTE COUNT FOR DECREMENTER
PRWRAC	EQU  $
	MOVB *R1+,*R0+		MOVE A BYTE (ONLY AS MUCH AS IS NEEDED)
	DEC  R12
	JNE  PRWRAC
	MOV  R2,R1		GET BYTE COUNT
	JMP  NOMOV2		CLEANUP & EXIT
*
*  PRINTER FORMAT CONTROL LOOP
*
ISTPRI	EQU  $
	CI   R3,SCRTYP
	JEQ  NOMOV3		IF SCREEN, SKIP PRINTER STUFF
	MOV  @IOBUFA(R4),R2	GET CPU RAM BUFFER ADDRESS
*
*  PRINTER OUTPUT CONTROL PRE-FORMATTER (FOR ASCII)
*
ISTPR1	EQU  $
	MOV  @IIOBUF,R0
	LI   R8,PPRINT		SEARCH BPRINT TABLE FOR CHAR
*
BPRLOP	EQU  $
	MOV  *R8+,R5		GET THE CHARACTER TO COMPARE
	JLT  UNRECO		UNRECOGNIZED CHAR
	CB   *R2,R5		IS IT THE SAME ?
	JEQ  BPRLO1		BRIF FOUND
	INCT R8			SKIP DATA WORD
	JMP  BPRLOP
UNRECO  EQU  $
	LI   R8,PSINGL		SINGLE SKIP
BPRLO1  EQU  $
	BL   @WRITER		WRITE TERMINATOR
	MOV  @IOBYTE(R4),R3     GET BYTE COUNT FROM USER
	BL   @TRIMBY		TRIM BYTE COUNT (DON'T INCLUDE BLANKS)
	MOV  @IOBUFA(R4),R1	CPU RAM USER BUFFER ADDRESS
	INC  R1			+1 TO SKIP 1ST CHARACTER
	MOV  R3,R2		RESULTANT BYTE COUNT (NOT INCLUDING 1ST)
	JEQ  NOMOVE		BRIF NOTHING TO MOVE
	MOV  R2,R10
	MOV  R0,R11
BPRLO2  EQU  $
	MOVB *R1+,*R11+		WRITE REST OF BUFFER
	DEC  R10		* BUG FIX
	JNE  BPRLO2
NOMOVE  EQU  $
	A    R2,R0		BUMP VDP RAM ADDRESS
	BL   @WRITER		WRITE TERMINATOR
	MOV  @IIOBUF,R1
	NEG  R1
	A    R1,R0		DETERMINE RESULTANT BYTE COUNT
	MOV  R0,R1		AND PUT IT IN PAB
NOMOV2  EQU  $
	MOV  @IOTPAB(R6),R2
	MOV  R1,@PABCHC(R2)
NOMOV3  EQU  $
	LI   R1,OPCWRI*256
	B    @CALDSR		RETURN
*
**************************
*			 *
*	I/O DRIVERS	 *
*			 *
**************************
*
*  THE FOLLOWING CONTAINS I/O DRIVERS BY DEVICE TYPE.
*
*  DSKIO:   DISK I/O
*  CASIO:   CASSETTE I/O (UNIMPLEMENTED)
*  LISIO:   LISTING (PRINTER OR OTHER DSR) I/O
*  SCRIO:   SCREEN I/O
*
DSKIO	EQU  $
CASIO	EQU  $
LISIO	EQU  $
	MOV  @IOTPAB(R6),R0	I/O ADDRESS
	XOP  @DIOXOP,0		DO IT
	MOV  @IOTPAB(R6),R2	GET PAB ADDRESS
	CLR  R1
	MOVB @PABERR(R2),R1
	JEQ  IOEER1		BRIF NO I/O ERROR
	SWPB R1			JUSTIFY ERROR NUMBER IN LOW BYTE
	SRA  R1,5
	INC  R1			INCR BY ONE FOR ERROR PRINT
	CI   R1,6	 	IS IT AN EOF ?
	JNE  IOEER1		BRIF NO
	MOV  @IIOBUF,R0
	LI   R1,BEOD
	MOV  *R1+,*R0+
	MOV  *R1,*R0
	MOV  @IOTPAB(R6),R1	SET 4 BYTES READ
	LI   R2,4
	MOV  R2,@PABCHC(R1)
	CLR  R1
*	
IOEER1	EQU  $
	MOV  R1,R1		SET STATUS FOR USER
	B    @RETDSR		RETURN
*
*  SCREEN I/O ROUTINES (READ & WRITE)
*
SCRIO	EQU  $
	CI   R1,OPCREA*256	IS IT A READ ?
	JEQ  TRYAGA		BRIF YES, GO DO READ
	CI   R1,OPCWRI*256	IS IT A WRITE ?
	JEQ  WRITRE		BRIF YES, GO DO WRITE
BREADR	B    @READRE		ELSE, RETURN
*
*  ITS A READ ( FUNC CODE 2 )
*
TRYAGA	EQU  $
	MOV  @IIOBUF,R5		GET MY I/O BUFFER ADDRESS
	CLR  R3
SKEYIN	EQU  $			KEYBOARD INPUT ROUTINE
	C    @IOBYTE(R4),R3	DID I READ MAXIMUM BYTES?
	JEQ  SKEYDO		BRIF YES
	BL   @MOVESR		MOVE STRING
	DATA CURSOR
	LI   R0,0		KEYBOARD MODE
	XOP  @DKEYXP,0		GET A KEY
	JNE  SKEYIN		BRIF NO KEY DEPRESSED
*
	LI   R2,CMPLIS		COMPARE LIST
	CB   R1,*R2+		IS IT A FF?  (NO KEY)
	JEQ  SKEYIN
*
	ABS  @PRINTC		IS PRINT CONTROL DISABLED?
	JEQ  SNOCTLC		BRIF YES
*
	CB   R1,*R2+		IS IT A FUNCTION/9?
	JEQ  ERR09		BRIF YES
*
	CB   R1,*R2+		IS IT A FUNCTION/8?
	JEQ  ERR08		BRIF YES
*
	CB   R1,*R2+		IS IT AN ESCAPE?
	JEQ  ERR09		YES, TREAT AS FCTN/9
*
	ANDI R1,>7F00		IS IT A CONTROL/C?
	CB   R1,*R2+
	JNE  SNOCTLC		BRIF NO
	B    @MENU$		BRIF YES, GRACEFUL EXIT
*
SNOCTLC	EQU  $
	ANDI R1,>7F00
	CB   R1,@KCR		WAS THIS ENTER?
	JEQ  SKEYDO		BRIF YES, DONE
	CI   R1,>0800		WAS THIS A BACKSPACE?
	JNE  SNOCTL8		BRIF NO
	MOV  R3,R3		ANY CHARACTERS IN BUFFER
	JEQ  SKEYIN		BRIF NO, IGNORE
	DEC  R3
	DEC  R5
	BL   @MOVESR		BLANK THIS AND LAST CHARACTERS
	DATA BLANKI
	JMP  SKEYIN
SNOCTL8	EQU  $
	MOVB R1,*R5+
	MOV  @SIOBUF,R2		I/O BUFFER ADDRESS
	MOVB R1,*R2
	MOV  R2,R1
	LI   R2,1
	MOV  @IDEBUG,R0		USER SCREEN HANDLER REQUESTED?
	JEQ  SNOCT9
	BL   *R0		ELSE, EXECUTE USER ROUTINE
	JMP  SNOCTA
SNOCT9	EQU  $
	LI   R0,WRITET
	XOP  @DVIDXP,0		WRITE TO SCREEN
SNOCTA	EQU  $
	INC  R3			BUMP # CHARACTERS READ
	JMP  SKEYIN
*
ERR08	EQU  $
	BL   @MOVESR
	DATA CRLFP
	LI   R1,8		ERROR 8 - REDO
	B    @RETDSR
*
ERR09	EQU  $
	BL   @MOVESR
	DATA CRLFP
	LI   R1,9		ERROR 9 - BACK
	B    @RETDSR
*
*  SKEYDO - Done with key loop, either ran out of bytes, or user
*	    pressed ENTER.
*
*	    R3 has byte count read.
*	    R5 points to I/O buffer end
*
SKEYDO	EQU  $
	BL   @MOVESR		WRITE CARRAIGE RETURN/LINE FEED PAIR
	DATA CRLFP
	MOV  @IOTPAB(R6),R1
	MOV  R3,@PABCHC(R1)	SET BYTE COUNT READ IN PAB
	JMP  BREADR		RETURN
*
*  SCRWRT - SCREEN WRITE HANDLES FORTRAN I/O BUFFER DIRECTLY
*	    MODULE USES A LOCAL SCREEN I/O BUFFER.  BUFFER IS
*	    WRITTEN TO SCREEN USING STANDARD MDOS WRITETTY FUNCTION.
*
WRITRE	EQU  $
	CLR  @ESCCNT		RESET ESCAPE IN PROGRESS FLAG
	MOV  @SIOBUF,R8		SCREEN I/O BUFFER
	MOV  @SCRBFS,R9		SCREEN I/O BUFFER SIZE
	MOV  @IOBYTE(R4),R3	GET BYTE COUNT FROM USER COMMAND STACK
	MOV  @IOBUFA(R4),R2     GET I/O BUFFER ADDRESS
	MOV  @IOORDE(R4),R5	IS IT A WRITE BINARY?
	ANDI R5,>FF
	CI   R5,WRBOPC		IS IT A WRITE BINARY?
	JNE  FSCR00		BRIF NO
	MOV  R3,R6		SAVE BYTE COUNT MAXIMUM	
	CLR  @TERCHA		CLEAR ANY TERMINATING CHARACTER
	MOV  @IOBUFA(R4),R4	GET USER I/O BUFFER ADDRESS START
	JMP  FSCRO4		SKIP PRINTER CHARACTER CHECK
FSCR00	EQU  $	
	BL   @TRIMBY		TRIM BYTE COUNT (ELIMINATE TRAILING BLANK)
	MOV  R3,R6		SAVE MAXIMUM BYTE COUNT
	MOV  @IOBUFA(R4),R4	GET USER I/O ADDRESS AGAIN
	LI   R3,BPRINT		DETERMINE WHAT TO DO WITH PRINT CONTROL
FSCRO1	EQU  $
	MOV  *R3+,R5		GET NEXT CHARACTER
	JLT  FSCRO2		BRIF NOT FOUND
	CB   *R4,R5		IS THIS THE ONE?
	JEQ  FSCRO3
	INCT R3
	JMP  FSCRO1		BRIF NO
FSCRO2  EQU  $
	LI   R3,SINGLE		USE DEFAULT
FSCRO3  EQU  $
	INC  R4			SKIP THIS PRE-CHARACTER
	MOV  *R3,R1		GET PRE/POST CHARACTERS
	MOV  *R3,@TERCHA	SAVE ANY TERMINATING CHARACTER
	ANDI R1,>FF00		CLEAR EXCESS BYTES
	MOV  R1,R1		IF NULL, SKIP THIS
	JEQ  FSCRO4
	BL   @STORCH		STORE CHARACTER IN BUFFER
	CB   R1,@KCR
	JNE  FSCRO4		BRIF NOT A CARRIAGE RETURN
	MOVB @KLF,R1		ELSE, MOVE LINE FEED
	BL   @STORCH
*
*  FOLLOWING LOOP IS EXECUTED FOR EACH CHARACTER IN INPUT BUFFER.
*  IT COPIES THE CHARACTER FROM THE USER INPUT BUFFER TO MY PRIVATE
*  SCREEN BUFFER. 
*
FSCRO4	EQU  $			DO FOR EACH CHARACTER
	DEC  R6
	JLT  FSCRO5		BRIF DONE, NOTHING MORE
	MOVB *R4+,R1		GET THE NEXT CHARACTER
	JEQ  FSCRO4		SKIP NULLS
	BL   @STORCH		STORE CHARACTER IN OUTPUT BUFFER
	CB   R1,@KCR		IS IT A CARRIAGE RETURN?
	JNE  FSCR4A		BRIF NO, TRY ANOTHER
	MOVB @KLF,R1		ELSE, MOVE LINE FEED
	BL   @STORCH
	JMP  FSCRO4
FSCR4A	EQU  $
	DEC  @ESCCNT		DECREMENT ESCAPE COUNT
	CB   R1,@KESC		IS IT AN ESCAPE?
	JNE  FSCRO4		BRIF NO
	LI   R5,3		MUST EAT 3 MORE CHARACTERS AT LEAST
	MOV  R5,@ESCCNT		SETIT
	JMP  FSCRO4
*
*  WHEN I REACH HERE, I'M DONE.  NO MORE CHARACTERS REMAIN IN INPUT
*  BUFFER.  
*
*  SEE IF I NEED TO EAT ANY BLANKS, SINCE ESCAPE SEQUENCE STARTED.
*
FSCRO5	EQU  $
	MOV  @ESCCNT,R5		GET ESCAPE COUNT
	JEQ  FSCR5A
	JLT  FSCR5A		BRIF DON'T NEED TO EAT ANY
	DEC  @ESCCNT		ELSE, DECREMENT ESCAPE COUNT
	MOV  @BLANK,R1		SEND BLANKS UNTIL ALL DONE
	BL   @STORCH
	JMP  FSCRO5
*
*  SEE IF THERE WERE ANY TERMINATING CHARACTERS (E.G. CR)
*
FSCR5A	EQU  $
	MOV  @TERCHA,R1		GET TERMINATING CHARACTER
	ANDI R1,>00FF
	SWPB R1
	MOV  R1,R1		ANYTHING HERE?
	JEQ  FSCRO6		BRIF NO
	BL   @STORCH
	CB   R1,@KCR
	JNE  FSCRO6
	MOVB @KLF,R1		CR, NOW STORE LF
	BL   @STORCH
*
*  NOW WRITE THE BUFFER TO THE SCREEN
*
FSCRO6	EQU  $
	BL   @FLUSHD		FLUSH THE DISPLAY
*
*  FOLLOWING CODE IS THE KEYBOARD "HOLD" MODE.  RECOGNIZES XON/XOFF
*  CONTROL SEQUENCES ONLY.
*
FKEYE1	EQU  $
	ABS  @PRINTC		CHECK STATUS OF PRINT FLAG
	JEQ  READRE		BRIF TURNED OFF, NOTHING TO DO
	CLR  R0			KEYBOARD MODE
	XOP  @DKEYXP,0		GET A KEY
	JNE  READRE		BRIF NO KEY DEPRESSED
	CB   R1,@KFF		WAS IT A CTL/C (BREAK)?
	JNE  FKEYE2		BRIF NO
	SETO R1
	JMP  FKEYE1		YES, INFORM CALLER BREAK REQUESTED
FKEYE2	EQU  $
	CB   R1,@KXON		WAS IT XON?
	JNE  READRE		BRIF NO, JUST EXIT
	CLR  R0			WAIT FOR KEY REMOVAL
	XOP  @DKEYXP,0
	JEQ  FKEYE2		BRIF A KEY IS STILL DEPRESSED
FKEYE3	EQU  $
	LI   R0,0		FINALLY, WAIT FOR SECOND KEY DEPRESS
	XOP  @DKEYXP,0
	JNE  FKEYE3		WAIT UNTIL SOMETHING PRESSED
	CB   R1,@KXOFF		WAS IT XOFF (CNTRL/Q)
	JNE  FKEYE3		BRIF NO, JUST HANG LOOSE
READRE  EQU  $
	LI   R1,0		CLEAR ERROR CONDITION
	B    @RETDSR		RETURN
*
*  STORCH - StorCH stores the character in R1 in the screen I/O buffer.
*	    It checks to ensure that the screen buffer will hold
*	    the requested character.  If not, the screen buffer is
*	    flushed first, then the character is stored.
*
STORCH	EQU  $
	MOV  R11,R12		SAVE RETURN
	DEC  R9			DECREMENT BYTE COUNT IN BUFFER
	JNE  STORC1		BRIF OK
	MOV  R1,@CHARSV		SAVE THE CHARACTER BEING STORED
	BL   @FLUSHD		FLUSH THE DISPLAY BUFFER
	MOV  @CHARSV,R1		RESTORE THE CHARACTER BEING STORED
	DEC  R9
STORC1	EQU  $
	MOVB R1,*R8+		SAVE CHARACTER IN BUFFER
	B    *R12		RETURN
*
*  FLUSHD flushes the screen buffer to the display.  This may be as
*  a result of a SETTTY command, or as a result of the screen buffer
*  being filled, or the actual end of display processing.
*
FLUSHD	EQU  $
	MOV  @SIOBUF,R1		SET SCREEN I/O BUFFER START
	S    R1,R8		HAS ANYTHING BEEN WRITTEN YET?
	JEQ  DONTWR		BRIF NO, DON'T FLUSH IT
	CLR  R5			FLUSH THE OUTPUT BUFFER
	MOV  R8,R2		SET # OF CHARACTERS IN STRING
	MOV  @IDEBUG,R0		USER SCREEN OUTPUT ROUTINE REQUESTED?
	JEQ  FLUSD1		BRIF NO
	MOV  R11,R8		SAVE RETURN
	BL   *R0		ELSE, EXECUTE USER ROUTINE
	MOV  R8,R11		RESTORE RETURN
	JMP  DONTWR
FLUSD1	EQU  $
	LI   R0,WRITET		WriteTTY
	XOP  @DVIDXP,0		DO IT
DONTWR	EQU  $
	MOV  @SIOBUF,R8		SET START SCREEN I/O BUFFER
	MOV  @SCRBFS,R9		SET SCREEN BUFFER SIZE (BYTES)
	B    *R11
*
**************************
*			 *
*  POST-FORMAT ROUTINES  *
*			 *
**************************
*
*  ROUTINES EXECUTED AFTER I/O PERFORMED
*
*  POREAD:  POST READ ROUTINE.  PADS WITH BLANKS & CHECKS FOR EOD.
*
POREAD	EQU  $
	MOV  @IOTPAB(R6),R2	GET # BYTES ACTUALLY READ
	MOV  @PABCHC(R2),R1
	MOV  R1,*R13		SAVE IN USER R0
	MOV  R1,R2		# BYTES READ
	MOV  @IIOBUF,R0
	MOV  @IOBUFA(R4),R1
	MOV  R2,R2		BRIF NOTHING READ
	JEQ  NOREAD
	MOV  R2,R11
POREA2	EQU  $
	MOVB *R0+,*R1+
	DEC  R11
	JNE  POREA2
NOREAD  EQU  $
	MOV  @IOBUFA(R4),R1	GET USER BUFFER ADDRESS
	A    @IOBYTE(R4),R1     GET END OF BUFFER ADDRESS
	DEC  R1
	S    @IOBYTE(R4),R2	GET # BYTES TO PAD
	JEQ  CHKEOD
	JGT  CHKEOD
PADLOP	EQU  $
	MOVB @BLANK,*R1   	PAD A BYTE
	DEC  R1	   		DECR # BYTES
	INC  R2
	JNE  PADLOP
*
CHKEOD	EQU  $			CHECK FOR END OF DATA
	MOV  @IOBUFA(R4),R1
	C    @BEOD,*R1+
	JNE  POREEN		NOT >EOD
	C    @BEOD+2,*R1
	JNE  POREEN
	LI   R1,IEOFER		ELSE, RETURN EOF ERROR
	JMP  CHKEO1
POREEN  EQU  $
	CLR  R1
CHKEO1	EQU  $
	B    @IORRT1		RETURN
*
*  PRE,POST FORMAT BY FUNCTION CODE
*
PFORMA	EQU  $
	DATA REAOPC	  06 = READ
	DATA PRREAD
	DATA POREAD
*
	DATA REWOPC	  3B = REWIND
	DATA PRREWI
	DATA 0
*
	DATA CLOOPC	  FE = CLOSE FILE
	DATA PRCLOS
	DATA 0
*
	DATA DELOPC	  FF = DELETE FILE
	DATA PRDELE
	DATA 0
*
	DATA WRBOPC	  01 = WRITE BINARY
	DATA PRWRIB
	DATA 0
*
	DATA WRAOPC	  05 = WRITE ASCII
	DATA PRWRIA
	DATA 0
	DATA -1	   	TERMINATOR
*
*  BRANCH TABLE FOR I/O TYPE DEVICE
*
BTYPET	EQU  $
	DATA DSKIO	DISK I/O
	DATA CASIO	CASSETTE I/O
	DATA SCRIO	SCREEN I/O
	DATA LISIO	LISTING (PRINTER) I/O
*
*  PRINTER FORMAT CONTROL CHARACTERS
*
*  1ST WORD:   High byte is carriage control FORTRAN character
*  2ND WORD:   High byte is leading byte, low byte is trailing byte
*
PPRINT	EQU  $
	TEXT '1 '		'1' - NEW PAGE
	DATA >0C00
	TEXT '0 '		'0' - DOUBLE SKIP
	DATA >0D00
	TEXT '+ '		'+' - NO CARRIAGE CONTROL
	DATA >0000
	TEXT '  '		' ' - SINGLE SKIP (DEFAULT)
PSINGL	EQU  $
	DATA >0000
	DATA -1			END OF LIST
*
* FOLLOWING IS LIST FOR CRT:
*
BPRINT	EQU  $
	TEXT '1 '	  	'1' - NEW PAGE
	DATA >0C0D
	TEXT '0 '	  	'0' - DOUBLE SKIP
	DATA >0D0D
	TEXT '+ '	  	'+' - NO CARRIAGE CONTROL
	DATA >0000
	TEXT '  '	  	' '  - SINGLE SKIP (DEFAULT)
SINGLE	EQU  $
	DATA >000D
	DATA -1	   	END OF LIST
*
*  FNDFRR - FIND FREE PACKET
*
*  GIVEN FILE # IN R0, SEARCH I/O TABLE FOR FREE PACKET
*
*  CONDITIONS RETURNED:
*
*   CALLER + 2 - FOUND FREE PACKET, ADDRESS IN R6
*   CALLER + 4 - FILE EXISTS, ADDRESS OF FILE ADDRESS IN R6
*   CALLER + 8 - NO FREE I/O FILE ADDRESSES EXIST
*
FNDFRR	EQU  $
	MOV  @IOTABL,R6		I/O TABLE START
	MOV  @NOIOTA,R3		# OF I/O TABLE PACKETS
	CLR  R2	   		FREE PACKET ADDRESS
FRELOP	EQU  $
	MOV  *R6,R5		GET ENTRY
	JNE  NFDNFR		BRIF THIS ONE EMPTY
FNDFRE	EQU  $	    		FOUND FREE PACKET
	MOV  R2,R2		DID I ALREADY FIND ONE?
	JNE  NFDNFR		BRIF YES, USE 1ST FOR LATER SEARCH SPEED
	MOV  R6,R2		OTHERWISE, SAVE ADDRESS THIS PACKET
NFDNFR	EQU  $
	C    R5,R0		IS IT THE FILE REQUESTED ?
	JEQ  RETEXI		YES, RETURN EXISTS
INCFRE	EQU  $
	AI   R6,IOTLEN		SKIP TO NEXT PACKET
	DEC  R3
	JNE  FRELOP		BRIF MORE TO SEARCH
	MOV  R2,R6		ANY FREE PACKETS FOUND ?
	JNE  RETFRX		BRIF YES
RETFUL	EQU  $			FULL CONDITION
	INCT R11
RETEXI	EQU  $			FOUND FILE CONDITION
	INCT R11
RETFRX	EQU  $			FOUND FREE PACKET CONDITION
	B    *R11
*
*  TRIMBY - Trim byte count (eliminate trailing blanks)
*
*	    R2 has I/O buffer address in CPU RAM
*	    R3 has byte count from user
*
*  Returns new byte count in R3.
*
TRIMBY  EQU  $
	MOV  R2,R1
	A    R3,R1		Determine ending buffer address
	DEC  R1
TRIMLA  EQU  $
	CB   *R1,@BLANK		is this a blank?
	JNE  TRIMEN		brif no, done
	DEC  R1			look at previous
	DEC  R3			decrement byte count
	JNE  TRIMLA		don't go negative
	INC  R3			make sure at least one byte
TRIMEN  EQU  $
	DEC  R3
	B    *R11		return	
*
*  WRITER - WRITE TERMINATOR
*
*	    ON ENTRY:   R8 HAS POINTER TO NEXT TERMINATOR (PRE/POST)
*	 	        R0 POINTS TO CURRENT VDP BUFFER ADDRESS
*
WRITER  EQU  $
	MOV  R11,R10		SAVE RETURN
	CLR  R1
	MOVB *R8+,R1		GET LEADING CHARACTER
	JEQ  BPRLO3		BRIF NULL
	MOVB R1,*R0+
	CB   R1,@KCR		DID I WRITE A CARRIAGE RETURN?
	JNE  BPRLO3		BRIF NO
	MOVB @KLF,R1		GET ADDITIONAL LINE ENDING CHARACTER
	JEQ  BPRLO3		BRIF NOTHING HERE
	MOVB R1,*R0+
BPRLO3  EQU  $
	B    *R10
*
*  MOVESR - MOVE THE GIVEN STRING TO THE I/O BUFFER, AND WRITE IT TO
*	    THE SCREEN.
*
MOVESR	EQU  $
	MOV  *R11+,R0		INPUT STRING ADDRESS
	MOV  @SIOBUF,R1		OUTPUT STRING ADDRESS
	MOV  R1,R2
*
MOVELP	EQU  $
	MOVB *R0+,*R2+		MOVE A BYTE
	JNE  MOVELP
*
	DEC  R2			DECREMENT TIL LAST
	S    R1,R2		GET # BYTES STORED
	JEQ  MOVERT		BRIF NOTHING MOVED
	MOV  @IDEBUG,R0		USER SCREEN OUTPUT REQUESTED?
	JEQ  MOVERU		BRIF YES
	MOV  R11,@PDEBRT	SAVE RETURN VECTOR
	BL   *R0		USE USER ROUTINE
	MOV  @PDEBRT,R11
	JMP  MOVERT
MOVERU	EQU  $
	LI   R0,WRITET		WRITETTY	
	XOP  @DVIDXP,0		WRITE TO SCREEN
MOVERT	EQU  $
	B    *R11		RETURN
*
*  LOCAL DATA AREA CELLS:
*
KX80	DATA >0080		BIT TO SAY TAKE SPECIAL SETTINGS
DVIDXP	DATA VIDXOP		VIDEO XOP NUMBER
DKEYXP	DATA KEYXOP		KEYBOARD XOP NUMBER
DIOXOP	DATA IOXOP		I/O XOP NUMBER
DUTXOP	DATA UTLXOP		UTILITY LIBRARY XOP NUMBER
*
*  MISC TEXT STRINGS:
*
KXON	EQU  $			XON (CNTRL/S) CHARACTER
	BYTE >13
KXOFF	EQU  $			XOFF (CNTRL/Q) CHARACTER
	BYTE >11
KCR	EQU  $			CARRAIGE RETURN
	BYTE >0D
KLF	EQU  $			LINE FEED
	BYTE >0A
KFF	EQU  $			STRING TERMINATOR
	BYTE >FF
KESC	EQU  $
	BYTE >1B		ESCAPE (PART OF CURSOR MOVE)
BLANKI	EQU  $
	BYTE >08,>20,>20,>08,>08,>00
CRLFP	EQU  $
	BYTE >20,>0D,>0A,>00
CURSOR	EQU  $
	BYTE >5F,>08,>00
WAIMSG	EQU  $
	BYTE >0D,>0A
	TEXT 'Press ENTER to Continue'
	BYTE >0D,>0A,>00
CMPLIS	EQU  $
	BYTE >FF,>8F,>86,>1B,>03
	EVEN
BLANK	DATA '  '
*
*  DSKSS, TABLE OF DISK DEVICE NAMES
*
DSKSS	EQU  $
	DATA 'DS'		FLOPPY DISK
	DATA 'RD'		RAM DISK (HORIZON?)
	DATA 'WD'		WINCHESTER DISK (OLD GPL)
	DATA 'HD'		HARD DISK (NEW)
	DATA 'hd'		HARD DISK (PERSONALITY CARD)
	DATA 0
	DATA 0			SPARES
	DATA 0
	DATA 0
	DATA 0
*
*  SPEDEV, TABLE OF MDOS SPECIAL HANDLING DEVICES
*
SPEDEV  EQU  $
SCRDEV	DATA 'CR'		CRT
	DATA 'RS'		RS232
	DATA '23'
	DATA '2/'
	DATA 'PI'		PIO
	DATA 'O '
*
*  END OF FILE MARKER
*
BEOD	EQU  $
	TEXT '>EOD'
	EVEN
*
*  SPECIAL CLOSE FILES COMMAND STACK
*
ALCLOS	EQU  $
	DATA CLOOPC		CLOSE FILE
	DATA 0			DYNAMIC FILE #
*
