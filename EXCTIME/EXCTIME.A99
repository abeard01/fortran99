	TITL 'NEW Execution Program Support'
	IDT  'NEXCTIM'
*
*  EXCTIM provides the following support functions:
*
*	1. Input/Output Support
*	2. Format Statement Execution
*	4. Error Handling
*	5. SCALAR and ARRAY and ADJDIO Input/Output
*	6. Debugger Initialization and Debugger Error Calls
*
*  Update History:
*
*  28-Aug-89 :  Major rewrite to reduce overall size and streamline
*		operation.  Also added list directed i/o; A format
*		based on variable list size; complex i/o.
*
*  13-dec-89 :  Added status set at end of STOPIO processing to return
*		status of # of bytes read back to user.  This was for
*		TI-99 version of symbolic debugger.
*
*  04-Jan-90 :  Fix wild card read logic.
*  07-JAN-90 :  Enable Interrupts, since MENU doesn't do it anymore
*  10-FEB-90 :  More fixes to list directed output for complex
*
	UNL
	COPY  "FORTPAR:"
	IF    GENEVE
	COPY  "equates:key.eq9"
	COPY  "equates:vid.eq9"
	COPY  "equates:mem.eq9"
	COPY  "equates:io.eq9"
	COPY  "equates:util.eq9"
	ENDIF
*
	COPY  "equates:fortio.eq9"
	COPY  "equates:fortex.eq9"
	UNL
	IF   GENEVE
	LIST
*
*  OPTIONS ON GENEVE ASSEMBLY, BASICALLY SIZES OF BUFFERS AND TABLES:
*
SCRBSZ	EQU  >0100		SCREEN BUFFER SIZE
IOBBFS	EQU  >0100		I/O BUFFER SIZE
IOTANO	EQU  14			NUMBER OF GENNED I/O TABLES
MYWSPO	EQU  >F040		MY WORKSPACE OFFSET
MEMDEB	EQU  >FD00		MEMORY RESERVED FOR DEBUGGER
DEBXOP	EQU  3			DEBUGGER XOP NUMBER
	ENDIF
	LIST
*
	DEF  INITE$		INITIAL ENTRY
*
	UNL
	IFEQ GENEVE
	LIST
	DEF  START,SEND		FOR LINKER
	ELSE
	LIST
	REF  DEBUG$		REF THE DEBUGGER
	ENDIF
*
	TITL 'EXCTIME DATA AREA'
*
*  REGISTERS USED AS VARIABLES FOR CODE REDUCTION
*
VINOUT	EQU  12			INPUT/OUTPUT FLAG
VIOBUF	EQU  7			POINTER TO I/O BUFFER START
VSCANP	EQU  8			CURRENT SCAN POSITION
VSTOPI	EQU  9			STOP I/O FLAG
VINSPO	EQU  10			POSITION WITHIN I/O BUFFER
*
*  SOME OTHER EQUATES:
*
ESCCHA	EQU  >1B		ESCAPE CHARACTER
EQUALS	EQU  >3D		EQUALS SIGN
*
*  INITIAL ENTRY POINT (SETUP)
*
*  ON ENTRY:
*
*    R3 HAS THE START ADDRESS OF THE MAIN PROGRAM DATA AREA
*   *R8 HAS THE ADDRESS OF THE USER I/O BUFFER (GPL ONLY)
*    R5 IS SET TO 0 IF NO DEBUGGER, -1 IF DEBUGGER
*
START	EQU  $
	IFEQ GENEVE
	B    @PROGST		BRANCH TO PROGRAM START IF ENTERED HERE
	ENDIF
INITE$	EQU  $
	MOV  R11,R8		SAVE RETURN
	LIMI 2			ENABLE INTERRUPTS
	UNL
	IF   GENEVE
	LIST
	LI   R3,DEBUG$		GET NON-SYMBOLIC DEBUGGER
	JEQ  NODEBU		BRIF NOT HERE
	BL   *R3		ELSE, GO TO IT
NODEBU	EQU  $
*
*  INITIALIZE THE I/O SUBSYSTEM.  HIGH RAM IS FIRST ALLOCATED TO
*  THE USER (RUNTIME) WORKSPACE, AND THEN TO THE VARIOUS BUFFERS
*  AND DATA AREAS NEEDED BY THE I/O PACKAGE.
*
	CLR  @IDEBUG		CLEAR "IN DEBUGGER" FLAG
	MOV  R5,@PDEBUG		SET OR RESET "MONITORED BY DEBUGGER" FLAG
	BLWP @INIT$
	DATA IOBBUF+ENDIOA	USER I/O BUFFER START
	DATA SCRBSZ		SCREEN BUFFER SIZE
	DATA IOBBFS		I/O BUFFER SIZE
	DATA IOTANO		NUMBER OF I/O TABLES
	ENDIF
	LIST
*
	LI   VIOBUF,IOBBUF	POINTER TO I/O BUFFER START
	MOV  VIOBUF,@MYWSPO+14	SAVE IOBBUF ADDRESS IN MY R7 WORKSPACE
*
	BL   @SHOPEN		ATTACH THE CRT
	DATA CRTARG		  CHARACTERS PER LINE
	DATA CRTNAM		  CRT NAME ADDRESS
	DATA CRTNO		  CRT NUMBER
*
	BL   @SHOPEN		ATTACH THE PRINTER
	DATA CHAPPL		  CHARACTERS PER LINE
	DATA PRTADR		  PRINTER NAME ADDRESS
	DATA PRTDOP		  DEVICE NUMBER
*
	LI   R10,EXCTIM		EXECUTION ENTRANCE ADDRESS
*
	IFEQ GENEVE		FOR TI-99/4A VERSION
	MOV  @DEBUGT,R3		GET DEBUG TRANSFER ADDRESS
	JEQ  EXCTI1		BRIF NO DEBUGGER HERE
	BL   *R3		ELSE, EXECUTE DEBUGGER
EXCTI1	EQU  $
	LIMI 2			ENABLE INTERRUPTS
	ENDIF
	B    *R8		RETURN
*
EXCTIM	EQU  $
	DATA MYWSPO		MY WORKSPACE POINTER
	DATA BEXCTI		EXCTIME ENTRY POINT
*
	UNL
	IF   GENEVE
	LIST
INIT$	EQU  $			INITIALIZATION
	DATA WREGS
	DATA EINIT
*
CIO$	EQU  $			INPUT/OUTPUT
	DATA WREGS
	DATA EIO
*
COPFI$	EQU  $			OPEN A FILE
	DATA WREGS
	DATA EOPFIL
*
CWAIT$	EQU  $			WAIT FOR KEYPRESS
	DATA WREGS
	DATA EWAIT
*
CMENU$	EQU  $
	B    @MENU$		USER ABORT ENTRANCE
*
SCSN$	EQU  $
	DATA WREGS
	DATA ESCSN
*
ALLMEM	EQU  $			ALLOCATE MEMORY SUBROUTINE
	DATA WREGS
	DATA EALLME
*
PRNTC$	EQU  $			TURN PRINT FLAG ON/OFF
	DATA WREGS
	DATA EPRNTC
*
	DATA MYWSPO		CLOSE ALL OPEN FILES SUBROUTINE
	DATA ECLOSA
*
DEBMO$	EQU  $
	DATA WREGS		SET DEBUG MODE (I AM IN DEBUGGER)
	DATA EDEBMO
	ENDIF
	LIST
*
*  ENTRY INTO ALL EXECUTION TIME FUNCTIONS (FROM BLWP *R10)
*
BEXCTI	EQU  $
	MOV  @10(R13),R5  	GET R5 FROM OLD WORKSPACE
	MOV  *R14+,R1		GET FUNCTION CODE
	MOV  R1,R2		SAVE IT
	ANDI R1,>007F		MASK EXECUTION INDEX
	AI   R1,BTABLE		GET FUNCTION
	MOV  *R1,R1
	B    *R1	 	EXECUTE FUNCTION
*
*  SHOPEN - Short Open List for PAB
*
*  This routine is passed three arguments:
*
*	Line Length
*	Device Number
*	Device Name (terminated with a blank)
*
*  It creates a PAB of output type in the I/O buffer area, and calls
*  the OPFILE routine to open it
*
SHOPEN	EQU  $
	MOV  VIOBUF,R2		Get I/O buffer start
	LI   R5,>0002		Open status, with display/var output
	MOV  R5,*R2+
	CLR  *R2+
	MOV  *R11+,R5		Get line length
	MOV  *R5,R5
	SWPB R5
	MOV  R5,*R2+
	CLR  *R2+
	CLR  *R2+		Now move the Name
	CLR  R3		 	Device Name Length
	MOV  *R11+,R4		Name address start
	MOV  *R4,R4
MOVNAM  EQU  $
	CB   *R4,@BLANK2	Is this the terminator?
	JEQ  MOVNA1		brif yes
	MOVB *R4+,*R2+		else, move a character
	INC  R3
	JMP  MOVNAM
MOVNA1  EQU  $
	SWPB R3
	MOVB R3,@9(VIOBUF)	Store the length
	MOV  VIOBUF,R1		Get length for open
	MOV  *R11+,R5		Get device number
	MOV  *R5+,R0
	JEQ  MOVNA2		brif null device, skip open
	BLWP @COPFI$
MOVNA2  EQU  $
	B    *R11		return
*
BTABLE	EQU  $-2
	DATA EERROR		02 ERROR
	DATA ERRCAL		04 ERROR ON CALL
	DATA ESTOPI		06 STOP I/O
	DATA ESTARI		08 START I/O
	DATA ESCLRI		0A SCALAR I/O
	DATA EARRYI		0C ARRAY I/O
	DATA EADJDI		0E ADJUSTABLE ARRAY I/O
	DATA ECHRIO		10 CHARACTER I/O
	DATA EBASEI		12 BASE START I/O
	TITL 'EXCTIME - DATA AREA'
*
*  EXECUTION TIME ERROR:
*
EXCTEM	EQU  $
	TEXT '0 * '
IERRNO	BYTE >00,>00
	TEXT ' ERROR @ '
IERRN1	BYTE >00,>00,>00,>00,>0D
	TEXT ' * 1='
IERRN2	BYTE >00,>00,>00,>00
	TEXT ' 2='
IERRN3	BYTE >00,>00,>00,>00
	TEXT ' 3='
IERRN4	BYTE >00,>00,>00,>00
	BYTE >0D
EXCTEE	EQU  $
	COPY "VERSION.A99"	SO I CAN DUMP IT & SEE VERSION
*
*  I/O PARAMETERS FOR CRT
*
	EVEN
CRTNO	DATA 6			DEVICE NUMBER FOR CRT
CRTARG  DATA 80			80 BYTE RECORDS
CRTNAM  DATA CRTNA1
CRTNA1  EQU  $
	TEXT 'CR '
	EVEN
*
*  SIZE OF EACH ELEMENT TYPE
*
ELESIZ	EQU  $
	DATA 2,1,4,4,8,4,8,2	SIZE OF EACH ELEMENT
CMPFLS	EQU  $
	DATA 0,0,0,0,0,1,1,0	WHETHER TYPE IS COMPLEX OR NOT
*
STOTBL	EQU  $
	DATA STOVI2		00 I*2
	DATA STOVB1		01 I*1
	DATA STOVI4		02 I*4
	DATA BADTYP		03 R*4  - NOT INTEGER ERROR
	DATA BADTYP		04 R*8  - NOT INTEGER ERROR
	DATA BADTYP		05 C*8  - NOT INTEGER ERROR
	DATA BADTYP		06 C*16 - NOT INTEGER ERROR
	DATA BADTYP		07 L*2  - NOT INTEGER ERROR
*
LOATBL	EQU  $
	DATA LOAVI2		00 I*2
	DATA LOAVB1		01 I*1
	DATA LOAVI4		02 I*4
	DATA BADTYP		03 R*4  - NOT INTEGER ERROR
	DATA BADTYP		04 R*8  - NOT INTEGER ERROR
	DATA BADTYP		05 C*8  - NOT INTEGER ERROR
	DATA BADTYP		06 C*16 - NOT INTEGER ERROR
	DATA BADTYP		07 L*2  - NOT INTEGER ERROR
*
*  BRANCH TABLE PARALLEL THE FORMAT ITEMS
*
*  FIRST BRANCH TABLE IS INITIALIZATION ENTRY FOR EACH TYPE
*
CHRBRT	EQU  $
	DATA NXTFTC		0 COMMA, NOTHING TO DO
	DATA DOLPAR		1 LEFT PARENTHESIS
	DATA DORPAR		2 RIGHT PARENTHESIS
	DATA FMTEXI		3 X FORMAT
	DATA FMTEXI		4 QUOTE
	DATA FMTEXI		5 QUOTE IN ARRAY	
*
*  SECOND BRANCH TABLES PARALLELS INITIALIZATION ENTRY, AND IS ACTUAL
*  FORMAT HANDLER FOR EACH TYPE
*
VECTOR	EQU  $
	DATA FMTEXI		 0 COMMA
	DATA FMTEXI		 1 LEFT PARENTHESIS
	DATA ENDIO		 2 FINAL RIGHT PARENTHESIS
*
*  OUTPUT ONLY FORMAT CODES
*
	DATA XIO		 3 X PROCESSING
	DATA QUOTEF		 4 QUOTE
	DATA QUOTEA		 5 QUOTE (IN ARRAY)
ENDVC1	EQU  $-VECTOR/2-1
	DATA CIO		 6 Cn
	DATA MIO		 7 Mn.n
*
*  INPUT AND OUTPUT FORMAT CODES
*
	DATA DIO		 8 Dn.n
	DATA EIOC		 9 En.n
	DATA FIO		10 Fn.n
	DATA ZIO		11 Zn
	DATA RIO		12 Rn
	DATA AIO		13 An
	DATA LIO		14 Ln
	DATA IIO		15 In
	DATA QIO		16 Q
*
*  FORMAT HANDLERS WHICH REQUIRE NO WIDTH/DECIMAL CHECKS
*
ENDVC2	EQU  $-VECTOR/2
	DATA SLASHI		17 /
	DATA HIO		18 nH..... (IN ARRAY)
	DATA HVARIO		19 nH.....
*
*  FUNCTION TABLE OF CODES
*
FCTBL	EQU  $
COMMA	TEXT ','
LPAREN	TEXT '('
RPAREN	TEXT ')'
	TEXT 'X'
FAKEQT	BYTE 13
QUOTE	TEXT ''''
*
	TEXT 'CM'
*
*  FOLLOWING ARE FORMAT ITEMS WHICH ARE VALID FOR INPUT AND OUTPUT
*
INPITE	EQU  $
LETTED	EQU  $
	TEXT 'D'
LETTEE	EQU  $
	TEXT 'EFZRALIQ'
SLASH	EQU  $
	TEXT '/H'
FCTBLE	EQU  $	   		FORMAT CHAR TABLE END +1
*
PERIOD	TEXT '.'
*
LETTEN	TEXT 'N'
LETTET	TEXT 'T'
*
*  THE FOLLOWING FIVE CHARACTERS MUST BE CONTINOUS
*
LETTBL	TEXT ' '
LETTE0	TEXT '0'
LETTE9	TEXT '9'
	TEXT 'A'
	TEXT 'F'
*
*  END OF CONTINOUS VARIABLES
*
MINUS4	TEXT '-'
PLUS	TEXT '+'
MLETTA	BYTE >37
	EVEN
BLANK2	TEXT '  '
TMSG	TEXT 'TRUE  '
FMSG	TEXT 'FALSE '
	EVEN
*
*  DEFAULT FORMATS FOR EACH TYPE
*
DEFADR	EQU  $			OUTPUT TYPE DEFAULT
	DATA DEFFO0
	DATA DEFFO1
	DATA DEFFO2
	DATA DEFFO3
	DATA DEFFO4
	DATA DEFF5A
	DATA DEFF6A
	DATA DEFFO7
	DATA DEFF08		CHARACTER I/O
*
DEFAD1	EQU  $-10
	DATA DEFF5B
	DATA DEFF6B
*
DEFIDR	EQU  $				SAME FOR INPUT HANDLERS
	DATA DEFFO0
	DATA DEFFO1
	DATA DEFFO2
	DATA DEFFO3
	DATA DEFFO4
	DATA DEIF5A
	DATA DEIF6A
	DATA DEIFO7
*
*
DEFFOM	TEXT '(1X)'			DEFAULT IF NOTHING ELSE
DEFFO0	TEXT '(I8)'			INTEGER *2
DEFFO1	TEXT '(I5)'			INTEGER *1
DEFFO2	TEXT '(I13)'			INTEGER *4
DEFFO3	TEXT '(F16.7)'			REAL *4
DEFFO4	TEXT '(F26.16)'			REAL *8
DEFF5A	TEXT '(F17.7)'			COMPLEX *8  (PART 1)
DEFF5B	TEXT '('','',F16.7)'		COMPLEX *8  (PART 2)
DEFF6A	TEXT '(F27.16)'			COMPLEX *16 (PART 1)
DEFF6B	TEXT '('','',F26.16)'		COMPLEX *16 (PART 2)
DEFFO7	TEXT '(1X,L5)'			LOGICAL *2
DEFF08	TEXT '(1X,A)'			CHARACTER
*
DEIF5A	TEXT '(F16.7)'			INPUT - COMPLEX *8
DEIF6A	TEXT '(F26.16)'			INPUT - COMPLEX *16
DEIFO7	TEXT '(L5)'			INPUT - LOGICAL *2
	EVEN
*
*  MISC CONSTANTS
*
K10	DATA 10			CONSTANT 10
KM1	DATA -1			Z'FFFF'
DUMZER	DATA >4000		DUMMY ZERO (FOR CONVERT)
	DATA 0
	DATA 0
	DATA 0
*
*  DEFAULT DEVICE AREA (USER PREFERENCES)
*
	UNL
	IF   GENEVE
	LIST
EXCDEV	DATA 6			WILD CARD LABEL BINDING
*
PRTDOP	DATA 9			PRINTER NUMBER
CHAPPL	DATA 132		# CHARACTERS PER LINE
PRTADR	DATA PRTAD1
PRTAD1	EQU  $
	TEXT 'PRN: '
	EVEN
	ENDIF
	LIST
	LIST
	TITL 'NON I/O EXECUTION TIME SUPPORT'
	PAGE
*
*  ERRCAL is used to indicate an illegal attempted entry point or
*	function.
EERRCA	EQU  $
	BL   @ERRPTA		DISPLAY ERROR & ABORT
	TEXT 'EC'
*
*  ERROR CALL ENTRANCE
*
EERROR	EQU  $
	MOV  *R14+,@USERER
	MOV  @22(R13),R1	USER R11
	MOV  R5,R6		USER R5
	BL   @ERRPTR		DO IT
USERER	DATA 0			USER ERROR
*
COMRTN	EQU  $
	MOV  R5,@10(R13)	SET USER R5
	STST R15		SET STATUS
	RTWP			RETURN
*
*  Error Display Routines:
*
*  There are three entry points to the error display routine,
*  depending on the return action required after displaying the
*  error:
*
*  ERRPTO - returns to the address in IORTN (execution time local)
*  ERRPTR - returns to the program at current R14 setting
*  ERRPTA - returns to the menu (unconditional QUIT)
*
*  CALLING SEQUENCE:
*
*	BL   @ERRPTO  	(OR ERRPTR, ERRPTA)
*	TEXT 'XX'	WHERE 'XX' IS THE ERROR TEXT TO DISPLAY
*
*  THE ERROR MESSAGE IS DISPLAYED IN THE FORM:
*
*		            R14
*               * XX ERROR @YYYY
*               * 1=AAAA  2=BBBB  3=CCCC
*                @6(R13)    R1      R6
*
*		WHERE:
*	        WP-13  CALLED FROM VALUE
*
ERRPTO	EQU  $			RETURN TO IORTN
	MOV  @IORTN,R8
	JMP  ERRCMM
*
ERRPTR	EQU  $			RETURN TO PROGRAM
	LI   R8,COMIOR
	JMP  ERRCMM
*
ERRPTA	EQU  $			RETURN TO MENU
	LI   R8,CMENU$
*
ERRCMM	EQU  $
	MOVB *R11+,@IERRNO	SET ERROR TEXT 'XX'
	MOVB *R11+,@IERRNO+1
	MOV  R5,@TEMP1
	MOV  R14,R5		SET PROGRAM ADDRESS
	BL   @HEXCVT
	DATA IERRN1
	MOV  @6(R13),R5		DISPLAY PROGRAM DATA AREA START
	BL   @HEXCVT
	DATA IERRN2
	MOV  R1,R5	 	I/O STATUS OR SC BASE ADDRESS
	BL   @HEXCVT
	DATA IERRN3
	MOV  R6,R5	 	I/O FILE # OR SC INDEX
	BL   @HEXCVT
	DATA IERRN4
	BL   @WRICRT		WRITE MESSAGE TO CRT
	DATA EXCTEM		MESSAGE ADDRESS
	DATA EXCTEE-EXCTEM
	MOV  @TEMP1,R5
	UNL
	IFEQ GENEVE
	LIST
	MOV  @DEBUGT,R3		GET DEBUGGER ADDRESS
	JEQ  ERRNRT		BRIF NOT HERE, JUST RETURN
	BL   @4(R3)		ELSE, CALL DEBUGGER
	ELSE
	LIST
	MOV  @PDEBUG,R3		MONITORED BY DEBUGGER?
	JEQ  ERRNRT		BRIF NO
	BL   @CLOSIT		CLOSE ANY OPEN FILE
	XOP  R1,DEBXOP		AND DO DEBUGGER XOP
	ENDIF
ERRNRT	EQU  $
	BLWP @CWAIT$
ERRNR1	EQU  $
	B    *R8		RETURN
	TITL 'SUBROUTINES'
	PAGE
*
*  HEXCVT - Convert BINARY to ASCII text
*
HEXCVT	EQU  $
	MOV  *R11+,R2		GET OUTPUT ADDRESS
	LI   R0,-4	 	4 DIGITS TO CONVERT
CVTNLO	EQU  $
	SRC  R5,16-4		GET NEXT NIBBLE
	MOV  R5,R4
	ANDI R4,>F
	CI   R4,9	  	IS IT A NUMBER ?
	JGT  ISLETE		BRIF NO, ITS A LETTER
	AI   R4,>30		NUMBER, ADD ASCII '0'
	JMP  GETNCC
ISLETE	EQU  $
	AI   R4,>41-10		LETTER, ADD ASCII 'A'
GETNCC	EQU  $
	SWPB R4
	MOVB R4,*R2+
	INC  R0			DONE ?
	JNE  CVTNLO		BRIF NO
	B    *R11	  	ELSE, RETURN
*
*  KEYXLA translates the key in the first 2 bits of R4 and the
*  argument pointed to by R14 into an absolute address of the
*  corresponding I/O parameter.  This address is returned in R5
*  and the pointer R14 is incremented.  In both cases, R4 is
*  shifted left 2 bits so that the next key is in position for
*  the next call to KEYXLA.
*
KEYXLA	EQU  $
	MOV  R4,R4	 	BRIF DIRECT OR INDIRECT ARG
	JLT  KX1
	SRC  R4,16-1
	JLT  KX2	  	BRIF PARAMETER IN ARG LIST
	CLR  R5			ELSE, RETURN WITH R2=0 IF PARAM
	JMP  KX3		NOT SPECIFIED
KX2	EQU  $
	MOV  R14,R5
	JMP  KX5
KX1	EQU  $
	SRC  R4,16-1
	JLT  KX4	   	BRIF INDIRECT ARG
	MOV  R14,R5
	MOV  *R5,R5
	JMP  KX5
KX4	EQU  $
	MOV  R14,R5
	MOV  *R5,R5
	MOV  *R5,R5
KX5	EQU  $
	INCT R14
KX3	EQU  $
	SRC  R4,16-1
	B    *R11
*
*  WRICRT:  WRITE A MESSAGE TO THE CRT.  CALLING SEQUENCE:
*
*     BL   @WRICRT
*     DATA MSGADR	; MESSAGE ADDRESS
*     DATA MSGBYT	; # OF BYTES TO WRITE
*
WRICRT	EQU  $
	LI   R4,CMDSTK		INTO COMMAND STACK
	MOV  R4,R6
	LI   R5,WRAOPC		WRITE ASCII OPCODE
	MOV  R5,*R6+		SET OPCODE
	LI   R5,6		IS IT END OF FILE?
	MOV  R5,*R6+		SET DEVICE NUMBER
	MOV  *R11+,*R6+		SET ADDRESS TO WRITE
	MOV  *R11+,*R6		SET # BYTES TO WRITE
	BLWP @CIO$		WRITE IT
	B    *R11		RETURN
*
*  INPUT - read a record
*
*  INPUT reads a record from the file number contained in UNITSA.
*  The byte count is set to 255,  the I/O buffer is pointed to by
*  VIOBUF.  IOCALL links to the I/O routine in the menu lowcore routine.
*
*  An end of file status (6) causes the program to be given control
*  if a user specified end action exists, otherwise the program is
*  aborted.   In addition, if the status parameter was specified and
*  an error condition occurs,  then the returned I/O status will be
*  stored in the specified FORTRAN variable for the user.
*
*  OUTPUT - Write an output record
*
*  OUTPUT writes a record to the file number contained in UNITSA.
*  The variable VINSPO is used to set the byte count since it
*  normally contains the number of bytes which have been stored
*  into the I/O buffer.
*
OUTPUT	EQU  $
	S    VIOBUF,VINSPO	GET # OF BYTES IN BUFFER
	JNE  OUTPU1		BRIF SOMETHING TO OUTPUT
	INC  VINSPO		ALWAYS OUTPUT AT LEAST 1 BYTE
OUTPU1	EQU  $
	LI   R4,WRAOPC	  	WRITE FUNCTION
	JMP  IOCOMM
*
INPUT	EQU  $
	LI   VINSPO,255		DEFAULT I/O BYTE COUNT
	LI   R4,REAOPC	 	 READ FUNCTION
IOCOMM	EQU  $
	MOV  R11,@RTNPTR 	SAVE RETURN
	LI   R2,CMDSTK		COMMAND STACK START
	MOV  R4,*R2+		FUNCTION
	MOV  @UNITSA,R4		GET UNIT NUMBER
	JNE  IOCOM1		BRIF SOMETHING SPECIFIED
	MOV  @EXCDEV,R4		ELSE, USE THE WILDCARD BINDING
IOCOM1  EQU  $
	MOV  R4,*R2+		FILE NUMBER
	MOV  VIOBUF,*R2+	I/O BUFFER ADDRESS
	MOV  VINSPO,*R2+	I/O BYTE COUNT
	MOV  VIOBUF,VINSPO	RESTORE VINSPO POSITION START
	LI   R4,CMDSTK		RESTORE COMMAND STACK ADDRESS
	MOV  @RECADR,R5 	RANDOM RECORD ?
	JEQ  IN4A	  	BRIF NONE
	MOV  *R5,*R2+		SET RECORD #
	LI   R5,>0800		READ RELATIVE
	AB   R5,*R4		OR IN RELATIVE ORDER BIT
IN4A	EQU  $
	BLWP @CIO$
	MOV  R0,@NOBYTE		SAVE # BYTES READ/WRITTEN
	MOV  R1,R1		GET I/O STATUS	
	JEQ  NOIOER		BRIF NO ERROR
	CI   R1,IEOFER	 	 IS IT EOF ?
	JNE  IOERR		 BRIF NO
	MOV  @ENDADR,R4 	WAS AN END ADR SPECIFIED?
	JNE  IOERR2
*
IOERR	EQU  $
	MOV  @STATUS,R4 	USER SPECIFIED STATUS VARIABLE ?
	JEQ  IOERR1		BRIF NO
	MOV  R1,*R4		ELSE, SAVE STATUS FOR USER
*
IOERR1	EQU  $
	MOV  @ERRADR,R4 	ERROR ADDRESS SPECIFIED?
	JEQ  IOERR3		BRIF NO
*
IOERR2	EQU  $
	MOV  R4,R14		YES, SAVE AS RETURN ADDRESS
	JMP  IOERR4
*
IOERR3	EQU  $
	MOV  @UNITSA,R6 	GET DEVICE NUMBER FOR DISPLAY
	BL   @ERRPTR		ELSE, ENNUCIATE ERROR
	TEXT 'IO'
*
IOERR4	EQU  $
	RTWP			RETURN TO USER
*
NOIOER	EQU  $			IF NO ERROR
	MOV  @RTNPTR,R11 	JUST RETURN TO EXCTIME
	B    *R11
	TITL 'START & STOP I/O'
	PAGE
*
*  STARTI - Start Input/Output
*
*  STARTI is called at the beginning of each read or write
*  statement to setup for subsequent calls to scalar or
*  array I/O routines.
*
*  The calling sequence is as follows:
*
*	BL   @STARTI
*	DATA KEYWORD
*	DATA UNIT # ARGUMENT    (MIGHT BE WILDCARDED, OR 0)
*	DATA FORMAT STMT ADRL   (IF SPECIFIED)
*	DATA END LABEL ARG	(IF SPECIFIED)
*	DATA ERR LABEL ARG	(IF SPECIFIED)
*	DATA RELATIVE REC #     (IF SPECIFIED)
*	DATA STATUS VAR ARG     (IF SPECIFIED)
*
*  WHERE THE KEYWORD DESCRIBES THE CONTENTS OF THE ARGUMENT LIST
*  AND WHETHER THE OPERATION REQUESTED WAS A READ OR A WRITE:
*
*      BITS 0,1  -  00 IF READ
*		    10 IF WRITE
*
*  THE NEXT 7 BIT PAIRS LOCATE THE I/O PARAMETERS ACCORDING TO 
*  THE KEY VALUES GIVEN BELOW:
*
*	00 - I/O PARAMETER NOT SPECIFIED
*	01 - I/O PARAMETER IN ARG LIST
*	10 - ADDRESS OF I/O PARAM IN ARG LIST
*	11 - ADR OF ADR OF I/O PARAM IN ARG LIST
*
EBASEI	EQU  $
	MOV  @6(R13),R5		GET USER BASE REGISTER
	MOV  R5,@OFFSET		AND SAVE AS OFFSET
	JMP  ESTAR0
*
ESTARI	EQU  $
	CLR  @OFFSET
ESTAR0	EQU  $
	MOV  *R14+,R4
	MOV  R4,VINOUT		SET INPUT/OUTPUT FLAG
	ANDI VINOUT,>8000
*
	SRC  R4,16-2		SETUP FOR NEXT KEY
	BL   @KEYXLA		TRANSLATE NEXT KEY
	MOV  R5,@UNITSA		IN CASE WILD CARD SPECIFIED
	JEQ  ESTAR1
	MOV  *R5,@UNITSA
ESTAR1	EQU  $
	LI   R3,FORMAT		FORMAT # IS FIRST PARAMETER
	LI   R2,3		TRANSLATE 5 MORE PARAMETERS
ESTAR2	EQU  $
	BL   @KEYXLA
	MOV  R5,R5		IS PARAMETER ZERO?
	JEQ  ESTA2A		BRIF YES
	A    @OFFSET,R5		ELSE, ADD IN BASE OFFSET
ESTA2A	EQU  $
	MOV  R5,*R3+		SAVE THE PARAMETER
	DEC  R2
	JNE  ESTAR2
*
	LI   R2,2		LOAD 2 MORE PARAMETERS
ESTA2B	EQU  $
	BL   @KEYXLA
	MOV  R5,*R3+
	DEC  R2
	JNE  ESTA2B
*
	BL   @INITBU		INITIALIZE I/O BUFFER
*
	MOV  @FORMAT,VSCANP	GET CURRENT SCAN POSITION
	CLR  VSTOPI		SET I/O IN PROGRESS
	MOV  VIOBUF,VINSPO	POSITION WITHIN I/O BUFFER
*
	CLR  @COUNT		REPEAT COUNT
	CLR  @PARENC		PARENTHESIS COUNT
	CLR  @NFLAG		PROCESSING N OR NOT
*
	SETO @LISFOR		SEE IF LIST DIRECTED FORMATTING
	CB   *VSCANP,@KM1	IS THIS LIST DIRECTED FORMATTING?
	JEQ  ESTARA		BRIF YES
	CLR  @LISFOR		ELSE, CLEAR LIST DIRECT FORMAT FLAG
	CB   *VSCANP,@LPAREN	MAKE SURE FORMAT STARTS W/PARENTHESIS
	JNE  PNSTER
	JMP  ESTAR3
*
ESTARA	EQU  $
	LI   VSCANP,DEFFOM	GET DEFAULT FORMAT (IN CASE NO I/O LIST)
	MOV  VSCANP,@FORMAT
*
ESTAR3	EQU  $
	ABS  VINOUT		IF OUTPUT, RETURN
	JNE  COMIOR
*
*  OTHERWISE, IT IS A READ OR ACCEPT STATEMENT.
*
*  THIS IS THE BASIC FORMAT PARSING LOOP.  SCAN THE FORMAT STATEMENT
*  TO SEE IF AN INPUT RECORD SHOULD BE READ OR NOT.
*
	ABS  @LISFOR		LIST DIRECTED FORMAT PROCESSING?
	JNE  ESTAR9		BRIF YES - FORCE INPUT
	CLR  R1			PARENTHESIS COUNT
	MOV  VSCANP,R2		START OF FORMAT STATEMENT
ESTAR4	EQU  $
	CB   *R2,@LPAREN	IS THIS A LEFT PARENTHESIS?
	JNE  ESTAR5
	INC  R1			INCREMENT PARENTHESIS COUNT
	JMP  ESTAR6
ESTAR5	EQU  $
	CB   *R2,@RPAREN	IS THIS A RIGHT PARENTHESIS?
	JNE  ESTAR7		WHEN R1 FALLS TO ZERO AND HAVEN'T FOUND
	DEC  R1			 DATA TRANSFER TYPE OF FORMAT, CODE
	JEQ  COMIOR		 RETURN TO PROGRAM WITHOUT READING A
ESTAR6	EQU  $			 RECORD.
	INC  R2
	JMP  ESTAR4
*
*  NOT A LEFT OR RIGHT PARENTHESIS.  SCAN THE CHARACTER AGAINST THE
*  FORMAT CODES.
*
ESTAR7	EQU  $
	LI   R1,INPITE		COMPARE AGAINST LAST ENTRIES IN TABLE
ESTAR8	EQU  $
	CB   *R0+,*R1+		IS THIS THE CHARACTER?
	JEQ  ESTAR9		BRIF YES
	CI   R1,FCTBLE		AM I AT THE END?
	JNE  ESTAR8		BRIF NO
	JMP  ESTAR6		HANDLER NOT FOUND, TRY NEXT CHAR
*
ESTAR9	EQU  $
	BL   @INPUT		READ ASCII RECORD
COMIOR	EQU  $
	RTWP			RETURN TO USER
*
*  STOPIO is called at the end of each i/o operation to finish
*  things up.  This involves scanning the rest of the FORMAT
*  statement to do anything else not requiring an I/O list
*  item.  Scanning stops whenever the final right parenthesis
*  is found or when a data transfer type of format I/O item
*  is found.
*
*  NOTE: LOGIC WAS ADDED HERE TO SET STATUS OF # OF BYTES READ BACK TO
*        USER.  THIS WAS FOR THE DEBUGGER WHICH IS EXTREMELY TIGHT ON
*	 MEMORY SPACE IN THE TI-99 VERSION.
*
ESTOPI	EQU  $	   		STOP I/O OPERATION
	SETO VSTOPI		SET FLAG SO DATA TRANSFER FORMAT
*				CODES KNOW THERE ARE NO MORE LIST ITEMS.
	BL   @NXTFTR		TRANSFER NEXT FORMAT GROUP
	MOV  @NOBYTE,R5		GET # OF BYTES INPUT
	STST R15		SAVE STATUS FOR USER
	RTWP			AND RETURN TO USER
*
*  SCALAR AND ARRAY INPUT/OUTPUT
*
*  THE FOLLOWING IS THE ENTRANCE FOR SCALAR AND ARRAY INPUT/OUTPUT.
*  THERE ARE THREE ENTRY POINTS, AS FOLLOWS:
*
*     SCLRIO    -   FOR SCALARS
*     ARRYIO    -   FOR ARRAYS
*     ADJDIO    -   FOR ADJUSTABLY DIMENSIONED ARRAYS
*     CHARIO	-   FOR CHARACTER I/O (CURRENTLY JUST DIRECT)
*
*  THE PASSED POINTER IS STRUCTURED AS FOLLOWS:
*
*     BIT 0     -   CONTAINS A 1 IF THE ADDRESS IS INDIRECT
*     BITS 5-7  -   CONTAINS THE ARGUMENT TYPE (0-7)
*     BITS 8-15 -   CONTAIN THE FUNCTION CODE (SCRLIO, ARRYIO, ADJDIO)
*
*  THE FOLLOWING WORD HAS THE ADDRESS (OR ADDRESS OF ADDRESS IF INDIRECT)
*  OF THE SCALAR OR ARRAY TO TRANSFER.
*
*  FOR ARRAY I/O, THE FOLLOWING WORD HAS THE NUMBER OF BYTES TO PROCESS.
*
*  FOR TYPES I*1, I*2, I*4, R*4, R*8, AND L*2, THE TRANSFER IS FAIRLY
*  SIMPLE, EACH ELEMENT IN THE I/O LIST IS TRANSFERRED BY CALLING THE
*  IOTRAN SUBROUTINE, AND IS DISPLAYED ACCORDING TO THE FORMAT CODE.
*  FOR C*8 AND C*16, IOTRAN MUST BE CALLED TWICE, EACH TIME WITH A
*  LIST OF SIZE/2.
*
ECHRIO	EQU  $
	CLR  @CMPFLG		CLEAR COMPLEX FLAG
	MOV  *R14+,@ARGSIZ	GET ARGUMENT SIZE
	MOV  R14,@ARRAYP	GET ARGUMENT ADDRESS
	MOV  R14,R2		IN R2 ALSO
	A    @ARGSIZ,R14	BUMP ADDRESS
	INC  R14
	ANDI R14,>FFFE		MAKE SURE EVEN ADDRESS
	LI   R5,8		USE ARGUMENT TYPE 8
	MOV  R5,@ARGTYP		CHARACTER TYPE ARGUMENT
	MOV  @ARGSIZ,@ARRAYS	PRETEND IT IS AN ARRAY
	JMP  NXTARY		GO PROCESS IT
*
ESCLRI	EQU  $
	BL   @DETSIZ		DETERMINE ARGUMENT SIZE
	MOV  @ARGSIZ,@ARRAYS	PRETEND IT IS AN ARRAY
	ABS  @CMPFLG		IS THIS COMPLEX?
	JEQ  NXTARY		BRIF NO, PROCESS AS ARRAY
	A    @ARGSIZ,@ARRAYS	IF COMPLEX, DOUBLE ARGUMENT SIZE
	JMP  NXTARY
*
*  ADJUSTABLE ARRAY I/O TYPE
*
EADJDI	EQU  $	   		SAVE REGISTERS
	ORI  R2,>8000		FORCE INDIRECTNESS
*
*  NORMAL ARRAY TYPE OF I/O:
*
EARRYI	EQU  $
	BL   @DETSIZ		DETERMINE SIZE OF ARGUMENT
	MOV  *R14+,@ARRAYS	= REMAINING BYTES TO TRANSFER
*
NXTARY	EQU  $
	SETO @CMPTIC		SET TIC-TOC FLAG
NXTAR1	EQU  $
	BL   @IOTRAN	 	TRANSFER NEXT ARRAY ELEMENT
	S    @ARGSIZ,@ARRAYS	DECREMENT ARRAY SIZE
	JEQ  COMIOR		BRIF DONE
	A    @ARGSIZ,@ARRAYP	COMPUTE NEXT ARRAY ELEMENT POINTER
	MOV  @ARRAYP,R2		RESTORE ARRAY POINTER
	NEG  @CMPTIC		NEGATE COMPLEX TIC-TOC FLAG
	JMP  NXTAR1
*
PNSTER	EQU  $	   		GOTO SYSERR POINTER
	BL   @ERRPTA		FORMAT PARENTHESIS NESTED TOO DEEP
	TEXT 'NE'
*
*  IOTRAN HANDLES THE I/O TRANSFER OF ONE SCALAR OR ARRAY ELEMENT.
*  IT GIVES CONTROL TO NXTFTG TO FORMAT THE I/O.
*
IOTRAN	EQU  $
	MOV  R2,@VARLO1		SAVE ADDRESS OF I/O VARIABLE
	ABS  @LISFOR		LIST DIRECTED FORMAT?
	JEQ  NXTFTR		BRIF NO
	MOV  @ARGTYP,R5		GET ARGUMENT TYPE
	SLA  R5,1		* 2
	ABS  VINOUT		INPUT?
	JEQ  IOTRA0		BRIF YES
	ABS  @CMPFLG		PROCESSING COMPLEX?
	JEQ  IOTRA1		BRIF NO
	MOV  @CMPTIC,R1		GET COMPLEX TIC-TOC FLAG
	JLT  IOTRA1		BRIF PROCESSING 1ST PART (REAL) OF NUMBER
*				ELSE, PROCESSING 2ND, GET 2ND HALF OF
*				 FORMAT STATEMENT
	MOV  @DEFAD1(R5),@FORMAT
	JMP  IOTRA2
*
*  ELSE, PROCESSING FIRST DIGIT OF COMPLEX, OR OTHER DIGIT.  GET THE
*  DEFAULT FORMAT ADDRESS AND SAVE AS NEW SCAN POSITION.
*
IOTRA0	EQU  $			INPUT
	MOV  @DEFIDR(R5),@FORMAT
	JMP  IOTRA2
IOTRA1	EQU  $			OUTPUT
	MOV  @DEFADR(R5),@FORMAT
IOTRA2	EQU  $
	MOV  @FORMAT,VSCANP	SET SCAN POSITION
	CLR  @PARENC		CLEAR PARENTHESIS COUNT
*
*  NXTFTG :  IS CALLED TO TRANSFER THE NEXT FORMAT GROUP.  IT SCANS
*	     THE CURRENT FORMAT STATEMENT FOR THE NEXT ITEM, AND
*	     CALLS THE APPROPRIATE FORMAT HANDLER.
*
NXTFTR	EQU  $
	MOV  R11,@IORTN		SAVE RETURN
NXTFTG	EQU  $
	MOV  @NFLAG,R2		IS THIS VIA A DETOUR DUE TO N
	JEQ  NXTFT1		 PROCESSING?
	CLR  @NFLAG		IF YES, THEN RETURN BACK TO CALLER
	B    *R2
*
NXTFT1	EQU  $
	DEC  @COUNT   		DECREMENT POSSIBLE REPEAT COUNT
	JGT  FMTEXI
	JEQ  FMTEXI
*
*  NXTFTC : SCANS FORMAT FOR THE NEXT FORMAT CODE AND SETS UP
*	    THE REPEAT COUNT, THE WIDTH, AND DECIMALS WHERE
*	    APPLICABLE.   THE VECTOR TO THE FORMAT HANDLER
*	    IS SET (GNFGID).   PARENTHESIS HANDLING IS ALSO
*	    PERFORMED BY NXTFTC INCLUDING SENSING OF FINAL
*	    RIGHT PARENTHESIS AND THE REINITIALIZATION OF THE
*	    FORMAT SCAN POSITION WHEN RESCANNING OF PART OF
*	    A FORMAT IS NECESSARY.
*
NXTFTC	EQU  $
	BL   @SCANFM		SCAN FORMAT UNTIL HIT NON-DIGIT
	DEC  R4			 AND RETURN PRECEDING INTEGER VALUE
	MOV  R4,@COUNT  	 INITIALIZE REPEAT COUNT IF ONE WAS
*				 SPECIFIED.  ELSE SET COUNT NEGATIVE
	MOV  @FCTIDX,R2		GET FUNCTION INDEX
	JLT  FMTERR		BRIF BAD FORMAT
	MOV  R2,@GNFGID		SAVE IT
*
	CI   R2,ENDVC1		INITIALIZE WIDTH AND DECIMALS IF
	JGT  FMTIN0		 I,L,A,R,Z,F,E,D,W,S,M,C
	SLA  R2,1
	MOV  @CHRBRT(R2),R2
	B    *R2
*
FMTIN0	EQU  $
	CI   R2,ENDVC2		SKIP INITIALIZION IF /, HIO, OR HVARIO
	JLT  FMTINI
	JMP  FMTEXI
*
	TITL 'FORMAT HANDLER INITIALIZATIONS'
	PAGE
*
*  THE FOLLOWING ARE HANDLERS FOR INITIALIZATION OF EACH FORMAT TYPE.
*
*  FMTEXI   :   QUOTE OR X FORMAT, JUST EXECUTE HANDLER
*  DORPAR   :   RIGHT PARENTHESIS PROCESSING
*  DOLPAR   :   LEFT PARENTHESIS PROCESSING
*
*  FMTINI   :   FORMAT INITIALIZATION
*
FMTINI	EQU  $
	BL   @SCANFM		GO SCAN INTEGER VALUE OF FIELD AND
	MOV  R4,@WIDTH 		STORE IN WIDTH
	CB   @PERIOD,R5
	CLR  R5
	JNE  FMTIN1		IF SO THEN SCAN INTEGER VALUE AND
	BL   @SCANFM		 STORE IN DECIMALS
FMTIN1	EQU  $
	MOV  R4,@DECIMA 	OTHERWISE, SET DECIMALS=0
	DEC  VSCANP
*
*  EXECUTE FORMAT CODE
*
FMTEXI	EQU  $
	MOV  @GNFGID,R2
	SLA  R2,1		*2
	MOV  @VECTOR(R2),R2
	B    *R2	 	EXECUTE FORMAT CODE
*
*  FMTERR - FORMAT ERROR PROCESSING
*
FMTERR	EQU  $
	BL   @ERRPTA		ILLEGAL FORMAT CHARACTER ERROR
	TEXT 'IC'
*
*  DORPAR - RIGHT PARENTHESIS PROCESSING
*
DORPAR	EQU  $
	DEC  @GRPCNT  		CHECK IF MUST REPEAT PROCESSING AT
	JLT  DORPA1	 	FIRST BYTE AFTER THIS LEVEL'S (.
*				BRANCH IF REPEAT COUNT USED UP
*				ELSE, SET FORMAT SCAN POSITION
*				TO FIRST BYTE AFTER ( OF THIS LEVEL.
	MOV  @LPARPO,VSCANP
	JMP  NXTFTC
*
DORPA1	EQU  $
	DEC  @PARENC  		DECREMENT COUNT OF # OF ) STILL
	JLT  PNSTER		NEED TO FIND. IF <0, THEN PARENTHESIS
	JEQ  DORPA3		 NESTING ERROR. BRIF RIGHT PARENTHESIS.
	MOV  @PARENC,R5
	DEC  R5	  		BRIF IF NEED TO FIND 1 MORE
	JEQ  NXTFTC
*				ELSE, LOOKING FOR 2 SO THIS ONE
*				CONCLUDES INNERMOST PAREN GROUP
	MOV  @GRPCNS,@GRPCNT
*				SETUP POINTERS TO CONTINUE PROCESSING
*				MIDDLE GROUP
	MOV  @RESCNP,@LPARPO
	JMP  NXTFTC
*				SET NEXT FORMAT GROUP INDEX TO
DORPA3	EQU  $			 THAT OF FINAL ) SO CONTROL GOES
*				 TO ENDIO WHEN RETURN TO FMTEXI.
	LI   R5,RPAREN-FCTBL
	MOV  R5,@GNFGID
	MOV  @RESCNP,VSCANP
	MOV  @PCNTSA,@PARENC
	MOV  @RESCNC,@GRPCNT
	JMP  FMTEXI
*
*  DOLPAR - LEFT PARENTHESIS PROCESSING
*
DOLPAR	EQU  $	   		SAVE BYTE POSITION AFTER (.
	MOV  VSCANP,@LPARPO
	INC  @PARENC		PARENC HAS # OF ) NEED TO FIND
	MOV  @PARENC,R5 	IF >3, NESTING ERROR
	AI   R5,-3
	JEQ  DOLPA2		IF =3, OK
	JLT  DOLPA1		IF <3, OK
	B    @PNSTER		IF >3, ERROR
*				ELSE, 1 OR 2
DOLPA1	EQU  $	   		SAVE STATISTICS SO CAN RE-SCAN WHEN
*				 HIT FINAL RIGHT PARENTHESIS AND
*				 THERE ARE REMAINING LIST ITEMS
	MOV  @LPARPO,@RESCNP
	MOV  @PARENC,@PCNTSA
	MOV  @COUNT,@RESCNC
*
DOLPA2	EQU  $	   		SAVE REPEAT COUNTS OF PREVIOUS AND
*				CURRENT LEFT PARENTHESIS
	MOV  @GRPCNT,@GRPCNS
	MOV  @COUNT,@GRPCNT
	JMP  NXTFTC
*
	TITL 'INDIVIDUAL FORMAT CODE HANDLERS'
	PAGE
*
*  THIS MODULE CONTAINS THE INDIVIDUAL FORMAT CODE HANDLERS FOR
*  X,A,R,Z,/,HVAR,H,FAKEQ,',W,S,L
*
*  XIO - HANDLE nX FORMAT CODE
*
XIO	EQU  $
	A    @COUNT,VINSPO	UPDATE ABSOLUTE BUFFER POINTER
	INC  VINSPO
	CLR  @COUNT
	JMP  NXTFTG		GO HANDLE NEXT FORMAT
*
*  RIO - HANDLE Rn FORMAT CODE
*  AIO - HANDLE An FORMAT CODE
*
AIO	EQU  $
	MOV  @BLANK2,R3		SET A PROCESSING
	JMP  RACOMM
*
RIO	EQU  $
	CLR  R3			SET R PROCESSING
*
RACOMM	EQU  $
	ABS  VSTOPI		ANY MORE LIST ITEMS?
	JNE  BENDIO		BRIF NO, ALL DONE
*
*  FORMAT ITEMS "R" OR "A" OUTPUT:
*
	MOV  @WIDTH,R5  	IF WIDTH = 0 (E.G. JUST A), THEN USE
	JNE  AIO0		 THE VARIABLE'S WIDTH
	MOV  @ARGSIZ,@WIDTH
*
AIO0	EQU  $
	BL   @SETBDS		SET BORDERS
	MOV  @WIDTH,R5
	S    @ARGSIZ,R5
	JLT  AIO1		MOVE VINSPO DOWN IF WIDTH GREATER
	A    R5,VINSPO		 THAN # BYTES IN I/O LIST ITEM
*
AIO1	EQU  $
	ABS  VINOUT		INPUT OR OUTPUT?
	JEQ  RAINPU		BRIF INPUT PROCESSING
*
*  OUTPUT PROCESSING
*
	MOV  @VARLO1,R0		GET VARIABLE ADDRESS
*
	MOV  R3,R3		IS THIS "R" OR "A" I/O?
	JNE  AIO3		BRIF "A" OUTPUT
*
	MOV  @ARGSIZ,R5		ADJUST FETCHC SO TRUNCATE OFF
	S    @WIDTH,R5		 LEFT IF WIDTH LESS THAN # OF BYTES
	JEQ  AIO3
	JLT  AIO3
	A    R5,R0		ADJUST BY THIS OFFSET (ARGSIZ-WIDTH)
	JMP  AIO3
*
AIO3	EQU  $
	MOV  @ARGSIZ,R2		USE ARGUMENT SIZE FOR LOOP CONTROL
	C    @WIDTH,R2		 UNLESS FIELD WIDTH IS LESS
	JEQ  AIO4
	JGT  AIO4
	MOV  @WIDTH,R2		THEN USE WIDTH (E.G. A1)
*
AIO4	EQU  $
	MOVB *R0+,R5		GET THE NEXT CHARACTER
	BL   @STOREC		AND STORE IT
	DEC  R2
	JNE  AIO4		BRIF MORE
	JMP  ENDIO1		BRIF DONE
BENDIO	B    @ENDIO
*
*  INPUT PROCESSING FOR R & A
*
RAINPU	EQU  $
	MOV  @VARLO1,R0		GET VARIABLE LOCATION START
	MOV  @ARGSIZ,R1		IF VARIABLE WIDTH MATCHES FIELD
	C    @WIDTH,R1		 WIDTH, DON'T PRE-BLANK VARIABLE.
	JEQ  RIO3
*
RIO0	EQU  $
	MOVB R3,*R0+		CLEAR OUT (OR BLANK) THE VARIABLE
	DEC  R1
	JNE  RIO0
*
	MOV  @VARLO1,R0		GET VARIABLE LOCATION START AGAIN
	MOV  @ARGSIZ,R1		GET ARGUMENT SIZE AGAIN
	MOV  R3,R3		IF DOING A INPUT
	JNE  RIO2		THEN JUST CONTINUE
*
	C    @WIDTH,R1		ELSE, LOOK AT FIELD WIDTH
	JGT  RIO3		IF    WIDTH>VARSIZ
*				ELSE, WIDTH<VARSIZ
	S    @WIDTH,R1		COMPUTE # OF BYTES
	A    R1,R0		OFFSET VARIABLE BY THAT AMOUNT
	S    @ARGSIZ,R1
	NEG  R1
	JMP  RIO3
*
RIO2	EQU  $
	C    @WIDTH,R1		IS WIDTH < ARGSIZ?
	JGT  RIO3		BRIF NO, PROCESS
	MOV  @WIDTH,R1		ELSE, USE FIELD WIDTH AS TRANSFER LEN
*
RIO3	EQU  $
	BL   @FETCHD		GET NEXT CHARACTER FROM I/O BUFFER
	MOVB R5,*R0+		AND SAVE IN USER VARIABLE
	DEC  R1
	JNE  RIO3
*
	MOV  @FIELDE,VINSPO
	JMP  ENDIO1	   	I/O RETURN ENTRY
*
*  ZIO - Z FORMAT FORMAT CODE HANDLER
*
ZIO	EQU  $
	ABS  VSTOPI
	JNE  ENDIO		BRIF I/O FINISHED
	BL   @SETBDS		SET BOUNDRIES
	MOV  @WIDTH,R5		LOOK AT WIDTH SPECIFIED
	JEQ  ENDIO1		BRIF 0, RETURN
	A    R5,VINSPO
	MOV  @ARGSIZ,R1		GET ARGUMENT SIZE
	SLA  R1,1
	S    R1,VINSPO		INSPOS=INSPOS+WIDTH-(2*ARGSIZ)
	MOV  @VARLO1,R0		R0 - VARIABLE LOCATION
	SETO R3			R3 - SET PROCESSING LEFTMOST DIGIT
	CLR  R4			R4 - HOLDS NEXT DIGIT (INPUT)
	ABS  VINOUT
	JEQ  ZINPUT
*
*  Z FORMAT OUTPUT PROCESSING.  CONVERT THE UP TO 16 HEXADECIMAL
*  DIGITS IN THE POSSIBLE 8 BYTE I/O LIST ITEM TO ASCII CHARACTERS
*  AND OUTPUT THEM TO THE I/O BUFFER.
*
ZOUTPU	EQU  $
	MOVB *R0,R5		CONVERT TWO DIGITS AT A TIME
	INC  R3			PROCESSING LEFT DIGIT?
	JNE  ZIO2		BRIF NO
	SRC  R5,4		ELSE, MOVE OVER LEFT DIGIT
	JMP  ZIO3
ZIO2	EQU  $
	SETO R3			RESET FLAG
	INC  R0			INCREMENT TO NEXT CHARACTER
ZIO3	EQU  $
	ANDI R5,>0F00		MASK OFF HEX DIGIT
	CI   R5,>0A00		IS THIS A DECIMAL DIGIT?
	JLT  ZIO4		BRIF YES
	AB   @MLETTA,R5		ADD ASCII OFFSET TO FORM LETTERS A-F
	JMP  ZIO5
ZIO4	EQU  $
	AB   @LETTE0,R5		ADD ASCII OFFSET TO FORM NUMBERS 0-9
ZIO5	EQU  $
	BL   @STOREC		STORE THE CHARACTER
	DEC  R1
	JNE  ZOUTPU		BRIF MORE DIGITS TO BE PROCESSED
	MOV  @FIELDE,VINSPO	SET ENDING POSITION
	JMP  ENDIO1		AND RETURN
*
*  Z FORMAT INPUT ROUTINE
*
ZINPUT	EQU  $
	BL   @FETCHC		FETCH NEXT CHARACTER TO PROCESS
	JLT  ENDIO1		BRIF PAST END OF FIELD, DONE
	LI   R2,LETTBL		START WITH BLANKS
	CB   R5,*R2+		IS IT A BLANK?
	JNE  ZIO6		BRIF NO, TRY NEXT
	CLR  R5			A BLANK IS A ZERO
	JMP  ZIO8		AND GO PROCESS
*
*  A VALID CHARACTER HAS BEEN READ.  TRY FOR A DIGIT 0-9, OR AN
*  ASCII CHARACTER A-F.
*
ZIO6	EQU  $
	CB   R5,*R2+		TRY AN ASCII 0
	JLT  BADCHA
	CB   R5,*R2+		TRY AN ASCII 9
	JGT  ZIO7		GREATER, MUST BE A LETTER
*
	SB   @LETTE0,R5		SUBTRACT NUMBER 0 TO GET HEX DIGIT
	JMP  ZIO8
*
ZIO7	EQU  $
	CB   R5,*R2+		TRY AN ASCII A
	JLT  BADCHA		BRIF BAD
	CB   R5,*R2		TRY AN ASCII F
	JGT  BADCHA
*
	SB   @MLETTA,R5		FORM HEX DIGIT
*
*  A HEX DIGIT IS SITTING IN R5 2ND NIBBLE.  OR IT INTO R4.
*
ZIO8	EQU  $
	ANDI R5,>0F00		MASK OFF DIGIT
	SLA  R4,4
	SOC  R5,R4
	INC  R3
	JEQ  ZINPUT		IF 1ST DIGIT, PROCESS ANOTHER
	MOVB R4,*R0+		ELSE, STORE THIS DIGIT
	SETO R3			SETUP FOR ANOTHER TWO
	DECT R1			DECREMENT COUNT OF DIGITS
	JNE  ZINPUT		BRIF MORE BYTES TO PROCESS
	JMP  ENDIO1		ELSE, END OF PROCESSING
*
*  ENDIO - TERMINATE I/O PROCESSING
*
*  ENDIO IS GIVEN CONTROL WHEN FINAL RIGHT PARENTHESIS OF FORMAT
*  STRING IS SENSED.
*
ENDIO	EQU  $
	ABS  VSTOPI		IF NXTFTG CALLED BY STOPIO THEN
	JEQ  SLASHI		 MUST OUTPUT FINAL BUFFER WHEN
	ABS  VINOUT		 COMPLETING A WRITE OPERATION
	JEQ  ENDIO1		ELSE, GO TO SLASHI TO SET UP FOR
	BL   @OUTPUT		 PROCESSING A NEW BUFFER
*
ENDIO1	EQU  $
	MOV  @IORTN,R11
	B    *R11		RETURN
*
BADCHA	EQU  $
	MOV  @ERRADR,R4 	GET ERROR ADDRESS
	JEQ  BADCHX		BRIF NONE SPECIFIED
	LI   R1,11	 	ELSE, RETURN STATUS OF 11
	B    @IOERR		THROUGH I/O ERROR RECOVERY
*
BADCHX	EQU  $
	BL   @ERRPTO		BAD CHARACTER IN INPUT PROCESSING
	TEXT 'BC'
*
*  SLASHI - SLASH FORMAT CODE PROCESSING
*
*  SLASHI INPUTS A RECORD DURING READ OPERATION AND OUTPUTS A RECORD
*  DURING WRITE OPERATION. IT IS CALLED WHEN SLASH CHARACTER IS SENSED,
*  OR IF FINAL RIGHT PARENTHESIS IS SENSED WHEN THERE ARE STILL
*  MORE I/O LIST ITEMS TO BE PROCESSED.
*
SLASHI	EQU  $
	ABS  VINOUT		READ/WRITE?
	JEQ  SLASH1
*
	BL   @OUTPUT		OUTPUT RECORD THEN BLANK OUT
	BL   @INITBU		BUFFER IF WRITE OPERATION
	JMP  BNXTFT
*
SLASH1	EQU  $			BLANK OUT BUFFER THEN READ RECORD
	BL   @INITBU		IF READ OPERATION
	BL   @INPUT
	JMP  BNXTFT
*
*  HVARIO - HOLLERITH VARIABLE I/O PROCESSING
*
*  HVARIO HANDLES THE TRANSFER OF HOLLERITH VARIABLES.  THE HOLLERITH
*  VARIABLES ARE CREATED FROM H STRINGS USED IN FORMAT STATEMENTS.
*  THEY ARE DESCRIBED IN A FORMAT STATEMENT STRING BY THE VARIABLE'S
*  ADDRESS. THE USE OF THE H FORMAT CODE IN A FORMAT STRING STORED
*  IN AN ARRAY IS HANDLED SEPERATELY BY HIO.
*
HVARIO	EQU  $
	MOV  VSCANP,R2		GET CURRENT SCAN ADDRESS
	ANDI R2,>FFFE		MAKE SURE IT'S EVEN
	MOV  *R2,R5		GET HVAR ADDRESS
	JNE  HVARI3		BRIF NOT FIRST TIME THROUGH
*
*  FIRST TIME THROUGH.  EXTRACT H STRING ADDRESS AND SAVE IN 
*  VARIABLE HVARAD.
*
	INCT VSCANP		POINT TO MIDDLE OF HVAR ADDRESS WORD
	INCT R2			 SO WE WILL KNOW HAVE GONE THROUGH
	MOV  *R2,@HVARAD	 THE ROUTINE ALREADY
*
HVARI3	EQU  $
	ABS  VINOUT		READ OR WRITE?
	JEQ  HVARIN		BRIF READ OPERATION
*
*  OUTPUT, MOVE THE H STRING TO THE OUTPUT BUFFER
*
	MOV  @HVARAD,R0		GET CURRENT HVAR ADDRESS
	INC  @HVARAD
	MOVB *R0,R5		GET CHARACTER TO STORE
	BL   @STORED		JUST DO NORMAL END BUFFER CHECKS
	JMP  HVARI4
*
*  HVAR INPUT, MOVE FROM I/O BUFFER TO HVAR STRING
*
HVARIN	EQU  $
	BL   @FETCHD		GET A CHAR FROM INPUT BUFFER
	MOV  @HVARAD,R0		GET CURRENT HVAR ADDRESS
	INC  @HVARAD
	MOVB R5,*R0		SAVE IT IN HOLLERITH VARIABLE
*
HVARI4	EQU  $
	MOV  @COUNT,R5  	IF COUNT=0, THEN THIS IS LAST TIME
	JNE  BNXTFT	 	 THRU FOR THIS GROUP SO MOVE VSCANP
*				 TO FIRST BYTE OF FORMAT FOLLOWING
*				 H VAR
	INC  VSCANP
BNXTFT	EQU  $
	B    @NXTFTG
*
*  HIO - H FORMAT CODE PROCESSING
*
*  HIO HANDLES H FORMAT CODE PROCESSING WHEN IT IS USED IN A FORMAT
*  STRING STORED IN AN ARRAY.
*
HIO	EQU  $
	ABS  VINOUT		INPUT OR OUTPUT?
	JEQ  HINPUT		BRIF INPUT
*
	BL   @LDFMTC		H OUTPUT, GET CHAR FROM FORMAT
	BL   @STORED		 STORE IN I/O BUFFER
	JMP  BNXTFT
*
*  INPUT - MOVE CHARACTER FROM I/O BUFFER TO H VARIABLE STRING
*
HINPUT	EQU  $	   		H INPUT
	BL   @FETCHD		GET CHARACTER FROM INPUT BUFFER
	MOVB R5,*VSCANP+	SAVE IN FORMAT STRING
	JMP  BNXTFT
*
*  QUOTEA - ' FORMAT CODE PROCESSING (ARRAY)
*
*  QUOTEI HANDLES ' FORMAT CODE WHEN IT IS USED IN A
*  FORMAT STRING STORED IN AN ARRAY OR FORMAT STATEMENT
*
QUOTEF	EQU  $
	CLR  R4			IN FORMAT STATEMENT (ACCEPT SINGLE QUOTES)
	JMP  QUOTEC
*
QUOTEA	EQU  $
	SETO R4			IN ARRAY STATEMENT (DON'T ACCEPT SINGLE QUOTES)
*
QUOTEC	EQU  $
	ABS  VINOUT		INPUT OR OUTPUT?
	JEQ  NOINER		ERROR IF TRY ' INPUT
*				SAVE START OF STRING ADDRESS IN CASE
*				REPEAT COUNT EXISTS
QUOTE0	EQU  $
	MOV  VSCANP,R0		GET SCAN POSITION START
*
QUOTE1	EQU  $
	MOVB *R0+,R5		GET NEXT CHARACTER FROM FORMAT
	CB   R5,@FAKEQT		FAKE QUOTE (FROM PARSER?)
	JEQ  QUOTE3		BRIF YES, DONE WITH STRING
	CB   R5,@QUOTE		REAL QUOTE?
	JNE  QUOTE2		BRIF NO, STORE CHAR IN STRING
	MOV  R4,R4		IN FORMAT STATEMENT?
	JEQ  QUOTE2		BRIF YES, STORE CHAR IN STRING
	MOVB *R0+,R5		LOAD ANOTHER CHARACTER
	CB   R5,@QUOTE		ANOTHER QUOTE FOLLOWS?
	JEQ  QUOTE2		BRIF YES, STORE QUOTE IN STRING
	DEC  R0
	JMP  QUOTE3		AND DONE
*
QUOTE2	EQU  $
	CI   VINSPO,IOBUFE	DID I OVERFLOW OUTPUT BUFFER?
	JGT  QUOTE1		BRIF YES, SKIP CHARACTER
	MOVB R5,*VINSPO+	STORE CHARACTER IN OUTPUT BUFFER
	JMP  QUOTE1		REPEAT TIL DONE
*
*  STRING WAS MOVED.  NOW UPDATE THE POINTERS TO THE SCAN POSITION AND
*  THE FORMAT STATEMENT.
*
QUOTE3	EQU  $
	DEC  @COUNT
	JEQ  QUOTE0		BRIF REPEAT
	JGT  QUOTE0
	MOV  R0,VSCANP		SAVE ENDING FORMAT POINTER
*
*  SCAN READ CHARACTER FOR LEGAL FORMAT CODE
*
RETFTG	EQU  $
	BL   @LDFMTD		SCAN FORMAT GROUP
	JMP  BNXTFT
*
*  MIO - HANDLE Mn.n FORMAT CODE
*
*    Note:  changed on 29-august-88 to emulate adm3a (for Geneve
*           initially, but will be for GPL also).
*
MIO	EQU  $
	ABS  VINOUT		INPUT OR OUTPUT?
	JEQ  NOINER		ERROR IF M INPUT
	LI   R5,ESCCHA		ESCAPE
	BL   @STOREB
	LI   R5,EQUALS		EQUAL SIGN
	BL   @STOREB
	MOV  @WIDTH,R5		ROW
	AI   R5,>001F		 + BASE
	INC  R5
	BL   @STOREB
	MOV  @DECIMA,R5		COLUMN
	AI   R5,>001F		 + BASE
	BL   @STOREB
	JMP  BNXTFT		SCAN NEXT FORMAT GROUP
*
*  CIO - HANDLE Cn FORMAT CODE
*
CIO	EQU  $
	ABS  VINOUT		INPUT OR OUTPUT?
	JEQ  NOINER		ERROR IF TRY C INPUT
*				CHARACTER IS STRAIGHT ASCII
	MOV  @WIDTH,R5
	BL   @STOREB
	JMP  BNXTFT
*
NOINER	EQU  $	   		CALL ERROR ROUTINE
	BL   @ERRPTA
	TEXT 'II'		INPUT TRIED FOR OUTPUT ONLY ITEM
*
*  LIO - HANDLE Ln FORMAT CODE
*
LIO	EQU  $
	ABS  VSTOPI		I/O FINISHED?
	JNE  CENDIO	
	BL   @SETBDS		SET I/O BUFFER FIELD BOUNDRIES
	ABS  VINOUT
	JEQ  LINPUT		BRIF INPUT
*
	MOV  @VARLO1,R5
	MOV  *R5,R5		GET VARIABLE
	JEQ  LIO1
	LI   R1,TMSG		GET TRUE MESSAGE
	JMP  LIO2
LIO1	EQU  $
	LI   R1,FMSG		GET FALSE MESSAGE
LIO2	EQU  $
	LI   R2,-5
LIO3	EQU  $
	MOVB *R1+,R5
	BL   @STOREC
	INC  R2
	JNE  LIO3
	JMP  BENDI1
*
LINPUT	EQU  $			LOGICAL INPUT
	MOV  @VARLO1,R1  	RESULT FALSE UNLESS FIND T
	CLR  *R1		IN FIELD
LIO4	EQU  $			CHECK IF SCANNED ENTIRE FIELD
	C    VINSPO,@FIELDE
	JGT  BENDI1
	JEQ  BENDI1
LIO5	EQU  $
	BL   @FETCHD		GET NEXT CHARACTER
	CB   R5,@COMMA		CHECK FOR TERMINATION OF INPUT
	JEQ  BENDI1	   	FIELD BY COMMA. IF SO, RETURN TO
*				 PROCESS NEXT I/O LIST ITEM.
	CB   R5,@LETTET		IF CHARACTER IS T THEN SET RESULT
	JNE  LIO4		 TRUE BY STORING 1 IN I/O LIST ITEM
	LI   R5,1
	MOV  @VARLO1,R6
	MOV  R5,*R6		CONTINUE TIL END OF FIELD IN CASE
	JMP  LIO4		 COMMA USED TO TERMINATE
*
	TITL 'CONTINUE FORMAT HANDLERS'
	PAGE
*
*  THIS MODULE CONTAINS FORMAT CODE HANDLERS FOR FORMATS I,F,E AND D
*
*  IIO - HANDLE I FORMAT CODE
*
*  MAXIMUM VALUES ARE -2,147,483,648 TO +2,147,483,647 (32-BIT INTEGER)
*
IIO	EQU  $			I FORMAT CODE PROCESSING
	ABS  VSTOPI
	JNE  CENDIO		BRIF IF NO MORE I/O
	BL   @SETBDS		SET BOUNDRIES
	ABS  VINOUT
	JEQ  IIN	  	BRIF INPUT
	MOV  @FIELDE,VINSPO	SET CHARACTER POSITION AT FIELD END
	DEC  VINSPO		 MINUS 1 CHARACTER
	CLR  @VARSIG		RESET SIGN FLAG
	BL   @LOAVAR		LOAD THE VARIABLE
	MOV  R5,R5		TEST VALUE STATUS
	JGT  INTPOS		BRIF POSITIVE INTEGER
	JEQ  INTZER		BRIF ZERO INTEGER
*
INTNEG	EQU  $			NEGATIVE INTEGER, MAKE POSITIVE
	SETO @VARSIG		SET SIGN FLAG
	INV  R5			TWO'S COMPLEMENT 32-BIT INTEGER
	INV  R6
	INC  R6
	JNC  INTPOS
	INC  R5			ELSE, INCREMENT TOP END
	JMP  INTPOS
*
*  AT ZERO.  SET A SINGLE ZERO IN THE OUTPUT BUFFER
*
INTZER	EQU  $			MAYBE ZERO, TEST SECOND WORD
	MOV  R6,R6
	JNE  INTPOS		BRIF POSITIVE VALUE
	MOVB @LETTE0,R5
	BL   @STOREC
	JMP  IOUTRT
*
*  POSITIVE VALUE, OR NEGATIVE VALUE MADE POSITIVE.  START CONVERTING
*
INTPOS	EQU  $
	LI   R2,-11		DIGIT COUNTER
INTLOP	EQU  $
	INC  R2			DONE?
	JEQ  INTCDO		BRIF YES
	MOV  R5,R5		MAKE SURE NOT ZERO LEFT
	JNE  INTLO1
	MOV  R6,R6
	JEQ  INTCDO		BRIF ZERO, DONE
INTLO1	EQU  $
	MOV  R6,R0		SAVE LOW END
	MOV  R5,R6
	CLR  R5			DIVIDE HIGH END
	DIV  @K10,R5
	MOV  R5,R1		SAVE NEW HIGH END
	MOV  R6,R5		GET MODULO 10 HIGH END
	MOV  R0,R6		GET OLD LOW END
	DIV  @K10,R5		NOW DO (ALMOST) DOUBLE WORD DIVIDE
	MOV  R5,R0		SAVE NEW LOW END
	SWPB R6
	AB   @LETTE0,R6		R6 HAS REMAINDER OF DOUBLE WORD DIVIDE BY 10
	MOVB R6,R5
	BL   @STOREC		STORE THE CHARACTER
	DECT VINSPO		MOVE TO NEXT POSITION (DOUBLE DECR SINCE
*				 STOREC INCREMENTED ONCE)
	MOV  R1,R5		RESTORE HIGH END
	MOV  R0,R6		RESTORE LOW END
	JMP  INTLOP		DO NEXT CHARACTER
*
INTCDO	EQU  $			NOW SET SIGN FLAG
	ABS  @VARSIG		WAS VALUE NEGATIVE?
	JEQ  IOUTRT		BRIF NO, JUST EXIT
	MOVB @MINUS4,R5		PUT A MINUS SIGN IN OUTPUT
	BL   @STOREC		 AND STORE IT
IOUTRT	EQU  $
*				SET END OF FIELD, NEXT ITEM START
	MOV  @FIELDE,VINSPO
BENDI1	EQU  $
	B    @ENDIO1
CENDIO	EQU  $
	B    @ENDIO
*
*  QIO - HANDLE Q FORMAT CODE
*
*  Q Format returns the byte count of the last I/O written or read.
*
QIO	EQU  $
	ABS  VSTOPI		ANY MORE I/O LIST ITEMS?
	JNE  CENDIO		BRIF NO, DONE
	ABS  VINOUT		OUTPUT?
	JNE  NOOUER		BRIF YES, ERROR
	CLR  R5
	MOV  @NOBYTE,R6		GET THE VALUE
	BL   @STOVAR
	JMP  BENDI1		AND RETURN
*
NOOUER	EQU  $
	BL   @ERRPTA
	TEXT 'OI'		OUTPUT FOR INPUT ITEM ERROR
*
*  IIN - I FORMAT INPUT PROCESSING
*
IIN	EQU  $
	BL   @SCANSI		SCAN FOR SIGN
	MOV  R5,@VARSIG		SAVE SIGN FLAG
	BL   @DIGITC
	CI   R5,-1		TERMINATE ON END OF FIELD?
	JEQ  IIN1		BRIF YES
	CB   R5,@LETTBL		TERMINATE ON A BLANK?
	JEQ  IIN1		BRIF YES
	CB   R5,@COMMA
	JNE  BBADCH		MUST TERMINATE WITH , OR ' ' OR EOF
IIN1	EQU  $
	MOV  @NUMBE1,R5		GET RESULT
	MOV  @NUMBE2,R6
	ABS  @VARSIG		GET DESIRED SIGN OF RESULT
	JEQ  IIN2		BRIF POSITIVE, NOTHING TO DO
	INV  R5
	INV  R6
	INC  R6			DOUBLE WORD NEGATE
	JNC  IIN2
	INC  R5
IIN2	EQU  $
	BL   @STOVAR		STORE IT IN VARIABLE
BENDI0	EQU  $
	MOV  @IORTN,R11
	B    *R11		RETURN
*
*  SCANSI - SCAN FOR SIGN
*
*  SCANSI SCANS THE INPUT BUFFER TO DETERMINE THE
*  SIGN OF THE NEXT INPUT VALUE.
*
SCANSI	EQU  $
	MOV  R11,R1		SAVE RETURN
SCSN	EQU  $
	BL   @FETCHC		GET INPUT FIELD CHAR
	JLT  SCSN1	 	RETURN R5=0 IF FIND + SIGN OR
	CB   R5,@PLUS		 TRY TO INPUT FROM PAST FIELD
	JEQ  SCSN1
	CB   R5,@MINUS4		RETURN R5='-' IF MINUS
	JEQ  SCSN2
	CB   R5,@BLANK2
	JEQ  SCSN	  	CONTINUE SCAN UNTIL NON-BLANK
	DEC  VINSPO		RESET POINTER SINCE WENT PAST
SCSN1	EQU  $
	CLR  R5
SCSN2	EQU  $
	B    *R1
BBADCH	B    @BADCHA
*
*  FIO HANDLES THE F FORMAT CODE
*
FIO	EQU  $
	ABS  VSTOPI
	JNE  CENDIO		BRIF NO MORE LIST ITEMS
	ABS  VINOUT
	JNE  FOUT		BRIF OUTPUT
	JMP  FIN
*
*  EIO HANDLES THE E FORMAT CODE
*
EIOC	EQU  $
	ABS  VSTOPI
	JNE  CENDIO		BRIF NO MORE LIST ITEMS
	ABS  VINOUT
	JEQ  FIN
	MOVB @LETTEE,R5
	JMP  DANDEO		GOTO COMMON 'E' OR 'D' OUTPUT
*
*  DIO HANDLES THE D FORMAT CODE
*
DIO	EQU  $
	ABS  VSTOPI
	JNE  CENDIO		BRIF NO MORE LIST ITEMS
	ABS  VINOUT
	JEQ  FIN		BRIF INPUT
	MOVB @LETTED,R5
*
*  DANDEO - D OR E FORMAT OUTPUT
*
DANDEO	EQU  $
	MOVB R5,@DOREFL 	SAVE 'D' OR 'E'
	BL   @CONVER		CONVERT # BEFORE OUTPUT
	CLR  R2
	LI   R4,6	 	 # digits for exponent
	BL   @REALOU		OUTPUT REAL # UP TO EXP
	MOVB @DOREFL,R5
	BL   @STOREC		OUTPUT 'D' OR 'E'
	MOV  @DECEXP,R5
	JLT  DEOUT1
	MOVB @PLUS,R5
	JMP  DEOUT2
DEOUT1	EQU  $
	NEG  R5			FORCE DECEXP POSITIVE
	MOV  R5,@DECEXP
	MOVB @MINUS4,R5
DEOUT2	EQU  $
	BL   @STOREC		SET + OR -
	MOV  @DECEXP,R5
	CI   R5,100		IF EXP >100, MAKE IT 100
	JLT  NOT100
	LI   R5,99
NOT100	EQU  $
	CLR  R4
	DIV  @K10,R4		DO DIVIDE
	SWPB R4	  		BUILD HI DIGIT
	A    R4,R5
	AI   R5,>3030		2 ASCII DIGITS
	BL   @STOREC
	SWPB R5
	BL   @STOREC
*
FDERTN	EQU  $			RESET INSPOS IN CASE DIDN'T
	MOV  @FIELDE,VINSPO	FILL ENTIRE FIELD
	JMP  BENDI0
*
*  FOUT - F FORMAT OUTPUT
*
FOUT	EQU  $
	CLR  @DOREFL		=0 IF F OUTPUT
	BL   @CONVER		CONVERT FLOATING POINT NUMBER
	MOV  @DECEXP,R2
	LI   R4,2
	BL   @REALOU
	JMP  FDERTN		RETURN
BADTYP	EQU  $
	BL   @ERRPTA
	TEXT 'IR'		INTEGER ITEM FOR REAL
*
*  FIN - FLOATING POINT INPUT
*
*  FIN CONVERTS AN ASCII STRING FROM THE INPUT BUFFER TO THE
*  CORRESPONDING INTERNAL RADIX 100 REAL NUMBER REPRESENTAION AND
*  STORES IT IN THE REAL I/O LIST VARIABLE ITEM.
*
FIN	EQU  $
	BL   @SETBDS		SET BOUNDRIES
	BL   @SCANSI		SCAN FOR SIGN
	CLR  @FNDDEC		RESET FOUND A DECIMAL FLAG
	LI   R2,RESSTR
	MOV  R5,R5		WAS A MINUS READ?
	JEQ  MOVMAN		BRIF NO
	MOVB @MINUS4,*R2+
MOVMAN	EQU  $
	BL   @FETCHC		FETCH A CHARACTER
	JLT  DIGITD		BRIF WENT PAST FIELD
	CB   R5,@BLANK2   	IS IT A BLANK ?
	JEQ  DIGITD		BRIF YES, DONE
	CB   R5,@COMMA		IS IT A COMMA ?
	JEQ  DIGITD		BRIF YES, DONE
	CB   R5,@LETTED   	IS IT A D ?
	JNE  SAVEDD
	MOVB @LETTEE,R5   	SUBSTITUTE LETTER E FOR D
SAVEDD	EQU  $
	CB   R5,@PERIOD   	DECIMAL POINT ?
	JNE  SAVEDE
	ABS  @FNDDEC		FOUND A DECIMAL POINT ALREADY?
	JNE  BBADCH		BRIF YES, ERROR
	SETO @FNDDEC		ELSE, SET DECIMAL FOUND
SAVEDE	EQU  $
	CI   R2,RESEND		AT END OF STRING
	JEQ  OVFERR		BRIF YES, TERMINATE
	MOVB R5,*R2+		ELSE, MOVE DIGIT
	JMP  MOVMAN		MOVE ANOTHER CHARACTER
*
DIGITD	EQU  $
	CLR  R5
	MOVB R5,*R2+		TERMINATOR DIGIT
	LI   R1,RESSTR
	S    R1,R2		R2 HAS LENGTH OF STRING
	UNL
	IF   GENEVE
	LIST
	MOV  R2,R3		FOR MDOS CSN CALL
	DEC  R3			DON'T INCLUDE TERMINATOR
	MOV  R1,R2		STRING ADDRESS
	LI   R1,FAC		RESULT IN FAC
	CLR  *R1		IN CASE RESULT OVERFLOWS, ZERO FAC
*	LI   R0,CSN		CONVERT STRING TO NUMBER
*	XOP  @DMATXP,0
	BLWP @SCSN$		CONVERT STRING TO NUMBER
	ELSE
	LIST
	MOV  @IOTBUF,R0   	USE I/O BUFFER AS FREE VDP AREA
	BLWP @CVMBW$		WRITE THE STRING
	MOV  R0,@FAC+12   	SET ADR IN ARG
	BLWP @CXMLLN		CONVERT THE STRING
	DATA >1000		CSN
	LI   R1,FAC		PUT RESULT FROM FAC
	ENDIF
	MOV  @VARLO1,R2
	MOV  @ARGSIZ,R5
	CI   R5,4
	JLT  BBADTY	
	JEQ  DOSTSP		SINGLE PRECISION
	CI   R5,8
	JNE  CBADCH		BAD TYPE
	MOV  *R1+,*R2+
	MOV  *R1+,*R2+
DOSTSP	EQU  $
	MOV  *R1+,*R2+
	MOV  *R1,*R2
	B    @ENDIO1
BBADTY	B    @BADTYP
OVFERR	EQU  $
	BL   @ERRPTA
	TEXT 'OV'		OVERFLOW INPUT FIELD (40 CHARACTERS)
*
*  REALOU OUTPUTS THE REAL NUMBER CONVERTED VIA D,E OR F FORMAT CODES.
*
*  ON ENTRY:    R2 HAS THE DECIMAL EXPONENT
*		R4 HAS THE # OF PLACES FOR DECIMAL
*
REALOU	EQU  $
	MOV  R11,@DCNVRT 	SAVE RETURN
	BL   @SETBDS		SET BOUNDRIES FOR FIELD
	MOV  @FIELDE,R5		GET ENDING FIELD POSITION
	S    @DECIMA,R5  	COMPUTE WHERE TO START STORING
	S    R4,R5	  	 NUMBER IN I/O BUFFER FIELD
	MOV  R5,R1
	MOV  R2,@DIGTM3
	MOV  R2,R5
	JLT  REALO1		# OF DIGITS TO APPEAR ON THE LEFT
	JEQ  REALO1		 OF DECIMAL POINT OR - # OF ZEROS
*				 TO APPEAR AFTER DECIMAL POINT
	S    R5,R1
	JMP  REALO2
REALO1	EQU  $
	DEC  R1
REALO2	EQU  $
	MOV  R1,VINSPO		OUTPUT BLANK IF NUMBER POSITIVE
	MOV  @VARSIG,R5
	JLT  REALO3		MINUS IF NUMBER NEGATIVE
	INC  VINSPO
	JMP  REALO4
REALO3	EQU  $
	MOVB @MINUS4,R5
	BL   @STOREC
REALO4	EQU  $
	MOV  @DIGTM3,R5
*
REALOC	EQU  $
	DEC  R5
	JLT  REALO5		BRIF NO CHAR DIGITS
	MOV  R5,@DIGTM3
	BL   @DIGITO		OUTPUT CHAR DIGIT
	MOV  @DIGTM3,R5
	JNE  REALOC		BRIF MORE
	JMP  REALO6
REALO5	EQU  $
	LI   R5,>3000		OUTPUT 0 BEFORE DEC PT
	BL   @STOREC		IF NO DIGITS EXIST
REALO6	EQU  $
	MOVB @PERIOD,R5		OUTPUT DECIMAL PT
	BL   @STOREC
	MOV  @DECIMA,R2
	INV  R2
	JMP  REALO9		OUTPUT MANTISSA DIGITS WITH AS
REALO8	EQU  $			MANY LEADING DIGITS AS SCALE FACTOR
	MOV  @DIGTM3,R5 	FACTOR CALLS FOR
	JLT  REALOA
	MOV  R2,@R2SAVE
	BL   @DIGITO
	MOV  @R2SAVE,R2
REALO9	EQU  $
	INC  R2
	JNE  REALO8
	MOV  @DCNVRT,R11
	B    *R11	  	RETURN
REALOA	EQU  $
	INC  @DIGTM3
	MOVB @LETTE0,R5
	BL   @STOREC
	JMP  REALO9
*
*  DIGITO PICKS UP THE NEXT DECIMAL DIGIT IN NUMBE1 to NUMBE4 AND
*  STORES IT IN THE OUTPUT BUFFER, THEN SETS UP FOR NEXT CALL.
*  IN NUMBE1-NUMBE4 AND STORES IT IN THE
*
DIGITO	EQU  $
	MOV  R11,R2		SAVE RETURN
	MOV  @SMRTN,R3  	GET ADDRESS OF NEXT ITEM
	LI   R5,NUMBE4+1	MAKE SURE NOT PAST END
	S    R3,R5
	CLR  R5			IF PAST END, JUST RETURN ZERO
	JLT  DIGIO1
	MOVB *R3,R5		ELSE, RETURN NEXT RAD100 DIGIT
DIGIO1	EQU  $
	SWPB R5
	CLR  R4
	DIV  @K10,R4
	MOV  @TICTOC,R1		ODD OR EVEN ?
	JEQ  DODD
	CLR  @TICTOC
	INC  @SMRTN		INCR TO NEXT BYTE
	JMP  DOCONE
DODD	EQU  $
	SETO @TICTOC
	MOV  R4,R5
DOCONE	EQU  $
	SWPB R5
	AB   @LETTE0,R5		CONVERT TO ASCII
	BL   @STOREC		SAVE IT
	B    *R2	   	RETURN
CBADCH	B    @BADCHA
*
*  CONVER - CONVER PICKS UP THE REAL I/O LIST ITEM AND CONVERTS
*  IT FOR OUTPUT AS A STRING OF DECIMAL DIGITS.
*
*  REAL NUMBERS ARE STORED IN NORMAL TI RADIX 100 NOTATION.
*
CONVER	EQU  $
	MOV  R11,@CNVRTN 	SAVE RETURN
	MOV  @ARGSIZ,R5
	CI   R5,4	   	Make sure a real or double prec item
	JLT  BBADTY
	MOV  @VARLO1,R2
	MOV  *R2,R5	 	GET 1ST WORD OF VALUE
	JNE  CNV0	   	BRIF NOT ZERO
	LI   R2,DUMZER		ELSE, USE MY DUMMY ZERO VALUE
CNV0	EQU  $
	LI   R3,NUMBE1
	MOV  *R2+,*R3+		MOVE 1ST 2 DIGITS
	MOV  *R2+,*R3+
	MOV  @ARGSIZ,R5
	CI   R5,4	  	CHECK I/O LIST TYPE
	JEQ  CNV9	  	SINGLE PRECISION
	MOV  *R2+,*R3+		MOVE LAST 2 DIGITS
	MOV  *R2,*R3
	JMP  CNV1
CNV9	EQU  $			SINGLE PRECISION
	CLR  *R3+	  	CLEAR LAST 2 DIGITS
	CLR  *R3
CNV1	EQU  $
	MOV  R5,R2		SAVE # BYTES
	LI   R3,NUMBE1
	CLR  @VARSIG		CLEAR SIGN FLAG
	MOV  *R3,R5		GET SIGN
	JGT  CNV2
	SETO @VARSIG		SET SIGN FLAG
	NEG  R5			NEGATE VALUE
	MOV  R5,*R3		& SAVE
CNV2	EQU  $
	CLR  R1
	MOVB *R3+,R1		GET EXPONANT
	SWPB R1
	AI   R1,->40
	SLA  R1,1
	CLR  R5
	MOVB *R3,R5		GET 1ST BYTE MANTISSA
	CLR  @TICTOC		INITIALIZE ODD/EVEN FLAG
	SWPB R5			GET 1ST WORD MANTISSA
	CI   R5,9
	JGT  NOTIC
	SETO @TICTOC		USE 2ND DIGIT
	JMP  NOTIC1
NOTIC	EQU  $
	INC  R1			INCREMENT EXPONENT
NOTIC1	EQU  $
	INC  R1
	MOV  R1,@DECEXP 	SET DECIMAL EXPONENT (POWER OF TEN)
	MOV  R3,@SMRTN  	SAVE POINTER TO START
	MOV  @CNVRTN,R11
	B    *R11	  	RETURN
*
	TITL  'SUBROUTINES FOR I/O PROCESSING'
*
*  LDFMTC - LOAD NEXT FORMAT CHAR
*
*  LDFMTC IS CALLED TO RETRIEVE THE NEXT CHARACTER FROM THE FORMAT
*  STRING EVEN IF CHARACTER IS BLANK.  THE CHARACTER IS RETURNED IN R5
*  AND CHAR.  IN ADDITION,  GENFGI IS INITIALIZED TO -1 IF THE CHARACTER
*  IS NOT A LEGAL FORMAT CODE, OR THE CHARACTER'S INDEX VALUE OTHERWISE.
*  THIS INDEX VALUE IS USED BY NXTFTG TO GRANT CONTROL TO THE APPROPRIATE
*  FORMAT CODE HANDLER.
*
LDFMTC	EQU  $
	CLR  R5
	MOVB *VSCANP+,R5	GET NEXT CHARACTER IN FORMAT STATEMENT
*
*  SCAN READ CHARACTER FOR LEGAL FORMAT CODE
*
LDFMTD	EQU  $
	LI   R4,FCTBL		START OF FUNCTION TABLE
LDFMT1	EQU  $
	CB   *R4+,R5		CHECK IF LEGAL FORMAT CODE
	JEQ  LDFMT2		BRIF YES
	CI   R4,FCTBLE		ELSE, COMPARE AGAINST END
	JNE  LDFMT1
LDFMT2	EQU  $
	DEC  R4
	NEG  R4			COMPUTE ACTUAL TABLE INDEX
	AI   R4,FCTBL
	NEG  R4
	MOV  R4,@FCTIDX		SAVE FUNCTION INDEX
	B    *R11
*
*  SETBDS - SET BOUNDRIES
*
*  SETBDS ESTABLISHES THE BOUNDRIES OF THE FIELD AS SPECIFIED BY
*  CURRENT WIDTH VALUE AND PREVIOUS FIELD; AND MAKES SURE THE
*  FIELD IS CLAMPED BEFORE THE END OF THE I/O BUFFER. 
*
SETBDS	EQU  $
	MOV  VINSPO,@FIELDB	SET FIELD START
	MOV  VINSPO,@FIELDE	SET FIELD END
	A    @WIDTH,@FIELDE	 + WIDTH
	B    *R11
*
*  SCANFM - SCAN FORMAT STATEMENT
*
*  SCANFM CALLS DIGITI IN ORDER TO FIND NEXT FORMAT CHARACTER AND
*  REPEAT COUNT IN FORMAT STRING
*
*  RETURNS:   ANY REPEAT COUNT IN R4
*	      CHARACTER WHICH TERMINATED I/O IN MSB R5
*
SCANFM	EQU  $
	MOV  R11,@SCANRT
	BL   @DIGITI		CONVERT INTEGER STRING & GET NEXT
*				NON-DIGIT
	CB   R5,@LETTEN
	JNE  SCNXIT		BRIF SCAN DIDN'T STOP ON N
*
*  N PROCESSING
*
	ABS  VSTOPI		STOP I/O FLAG?
	JNE  DENDIO		BRIF NO LIST ITEM FOR N
*
	BL   @LOAVAR		GET INTEGER VARIABLE IN R5, R6
	MOV  R5,@NUMBE1		SET ANSWER
	JLT  NERROR		IF N NEGATIVE, ERROR
	JNE  MAGERR		MAGNITUDE ERROR
*
	MOV  R6,@NUMBE2
	JEQ  NERROR		IF 0, ERROR
*
	MOV  @ASCNXI,@NFLAG	RETURN TO SCAN EXIT AFTER I/O
	BL   @DIGIII
	MOV  R5,@CHAR		SAVE TERMINATING CHARACTER
*
	MOV  @IORTN,R11		RETURN TO CALLER
	B    *R11
*
ASCNXI	DATA SCNXI0		ADDRESS OF SCAN EXIT
*
SCNXI0	EQU  $
	MOV  @CHAR,R5		RESTORE TERMINATING CHARACTER
SCNXIT	EQU  $	   		RETURN WITH INTEGER VALUE IN R5
	MOV  @NUMBE2,R4 	USE ONLY LOW 16 BITS
	MOV  @SCANRT,R11
	B    *R11		RETURN TO CALLER
*
DENDIO	B    @ENDIO
*
*  DIGITI - Scan Integer Digit String
*
*  DIGITI is called to scan an ASCII string from the FORMAT statement
*  and convert it to an integer absolute number.  Blanks are ignored.
*  The scanning stops when a non-numeric character (excluding a blank)
*  is detected.  Result is returned in the variables NUMBE1 and NUMBE2.  
*
*  There are three entry points:
*
*  DIGITI   :  CONVERT NEW NUMBER FROM FORMAT STATEMENT
*  DIGIII   :  CONVERT & APPEND TO OLD NUMBER FROM FORMAT STATEMENT
*  DIGITC   :  CONVERT NEW NUMBER FROM I/O BUFFER
*
DIGIII	EQU  $
	MOV  R11,@DIGCVA	SAVE RETURN VECTOR
	MOV  @NUMBE1,R0		GET CURRENT DOUBLE WORD NUMBER
	MOV  @NUMBE2,R1
	JMP  DIGIT0		W/NO INITIALIZATION
*
DIGITI	EQU  $
	MOV  R11,@DIGCVA	SAVE RETURN VECTOR
	CLR  R0
	CLR  R1
*
DIGIT0	EQU  $
	BL   @LDFMTC		GET A CHARACTER
	BL   @DIGCVT		CONVERT IT
	JMP  DIGIT0		TIL TERMINATOR SEEN
*
DIGITC	EQU  $
	MOV  R11,@DIGCVA	SAVE RETURN VECTOR
	CLR  R0
	CLR  R1
DIGIT1	EQU  $
	BL   @FETCHC		GET CHARACTER
	BL   @DIGCVT		CONVERT IT
	JMP  DIGIT1		TIL TERMINATOR SEEN
*
*  DIGCVT - CONVERT THE FETCHED DIGIT UNTIL NON A NUMBER FOUND
*
DIGCVT	EQU  $
	MOV  R11,R6		SAVE RETURN
DIGCV0	EQU  $
	LI   R2,LETTBL		GET CONVERSION TABLE START
	CB   R5,*R2+		IS IT A BLANK?
	JEQ  DIGCV2		BRIF YES, SKIP IT
	CB   R5,*R2+		IS IT LESS THAN A ZERO?
	JLT  DIGCV3		BRIF YES, EXIT
	CB   R5,*R2+		IS IT GREATER THAN A NINE?
	JGT  DIGCV3		BRIF YES, EXIT
	SB   @LETTE0,R5		ELSE, CONVERT THE DIGIT
	SWPB R5
	BL   @SHIFTL		SHIFT THE CURRENT NUMBER LEFT *4
	MOV  R0,R3
	MOV  R1,R4		SAVE NUMBER *2
	BL   @SHIFTL		*4
	BL   @SHIFTL		*8
	A    R3,R0
	A    R4,R1		+ 2*NUMBER
	JNC  DIGCV1
	INC  R0
DIGCV1	EQU  $
	A    R5,R1		ADD NEW NUMBER
	JNC  DIGCV2
	INC  R0
*
DIGCV2	EQU  $
	B    *R6		RETURN
*
DIGCV3	EQU  $
	MOV  R0,@NUMBE1		SAVE NUMBER
	MOV  R1,@NUMBE2
	MOV  @DIGCVA,R11	EXIT, CHARACTER IN R5
	B    *R11
*
*  SHIFTL - SHIFT R0 & R1 LEFT 1 (*2)
*
SHIFTL	EQU  $
	SLA  R0,1		SHIFT 1ST NUMBER
	SLA  R1,1
	JNC  SHIFT1
	INC  R0
SHIFT1	EQU  $
	B    *R11
*
*  DETSIZ :  DETERMINE THE SIZE OF THE PASSED ELEMENT.  THE SIZE
*	     IS LOCATED IN THE POINTER PASSED BY R2.
*
DETSIZ	EQU  $
	MOV  R2,R5		SAVE WORD I ENTERED WITH
	MOV  *R14+,R2		GET ADDRESS OF SCALAR VARIABLE
	MOV  R5,R5		IS THIS INDIRECT?
	JGT  DETSI0
	MOV  *R2,R2		YES, GET ADDRESS OF ADDRESS
DETSI0	EQU  $
	MOV  R2,@ARRAYP		SAVE POINTER TO ELEMENT
	ANDI R5,>0F00		MASK BYTE LENGTH OF ARGUMENT
	SWPB R5
	MOV  R5,@ARGTYP		SAVE ARGUMENT TYPE
	SLA  R5,1
	MOV  @ELESIZ(R5),@ARGSIZ  GET ARGUMENT SIZE
	MOV  @CMPFLS(R5),@CMPFLG  GET COMPLEX TYPE OR NOT
	B    *R11
*
*  INITBU - Initialize I/O buffer with blanks.
*
*  The I/O buffer is initialized when:
*
*   1. STARTI is entered (start of any I/O)
*   2. Before an input caused by a slash
*   3. After an output caused by a slash
*
INITBU EQU   $
	MOV  VIOBUF,R2		Address of I/O buffer
INITB1	EQU  $
	MOV  @BLANK2,*R2+	CLEAR A WORD
	CI   R2,IOBUFE		DID I CLEAR ENTIRE BUFFER?
	JNE  INITB1		BRIF NO
	B    *R11	 	ELSE, RETURN
*
NERROR	EQU  $
	MOV  R5,R1
	BL   @ERRPTA		N CODE ERROR
	TEXT 'NR'
*
MAGERR	EQU  $
	BL   @ERRPTA
	TEXT 'MA'		MAGNITUDE ERROR
*
*  STOREC - STORE IF CHECK OK
*
*  STOREC TAKES THE CHARACTER SENT IN R5 AND STORES IT IN THE
*  I/O BUFFER AS LONG AS IT REMAINS WITHIN THE BOUNDRIES OF THE OUTPUT
*  FIELD.
*
*  STOREB : SWAP BYTE IN R5, STORE IF NOT PAST BUFFER END
*  STOREC : CHECK FIELD START/END AND PAST BUFFER END
*  STORED : CHECK PAST BUFFER END
*
STOREB	EQU  $
	SWPB R5
	JMP  STORED
STOREC	EQU  $
	C    VINSPO,@FIELDB	BEFORE START OF FIELD?
	JLT  STORE1
	C    VINSPO,@FIELDE	AFTER END OF FIELD?
	JGT  STORE1
	JEQ  STORE1
STORED	EQU  $
	CI   VINSPO,IOBUFE	BEFORE END OF I/O BUFFER?
	JGT  STORE1
*
	MOVB R5,*VINSPO+	ELSE, STORE CHARACTER
	B    *R11
*
STORE1	EQU  $
	INC  VINSPO		THROW AWAY CHARACTER.
	B    *R11
*
*  FETCHC - RETRIEVE NEXT CHAR FROM INPUT
*
*  FETCHC IS CALLED TO RETRIEVE THE NEXT CHARACTER FROM THE INPUT FIELD.
*  IT CHECKS TO MAKE SURE VINSPO POINTS WITHIN THE FIELD. IF IT DOES
*  THEN CONTROL IS GIVEN TO FETCH, ELSE A BLANK IS RETURNED IN R5 IS SET
*  TO -1.
*
FETCHC	EQU  $
	CLR  R5			CLEAR RESULTING CHARACTER
	C    VINSPO,@FIELDB	BEFORE START OF FIELD?
	JLT  FETCH2		BRIF YES
	C    VINSPO,@FIELDE	PAST END OF FIELD?
	JEQ  FETERR		BRIF YES, ERROR
	JGT  FETERR		BRIF YES, ERROR
FETCHD	EQU  $
	CI   VINSPO,IOBUFE	PAST END OF I/O BUFFER?
	JGT  FETERR
*
FETCH1	EQU  $
	MOVB *VINSPO+,R5	GET NEXT CHARACTER
	B    *R11
*
FETCH2	EQU  $
	INC  VINSPO		SKIP NON-CHARACTER
	MOVB @BLANK2,R5		LOAD A BLANK IF PRECEEDING FIELD
	B    *R11
*
FETERR	EQU  $
	LI   R5,-1		SET CHARACTER TO -1
	B    *R11
*
*  LOAVAR : LOAD A VALUE ACCORDING TO TYPE.  R5 AND R6 ARE
*	    LOADED WITH AN INTEGER *4 VALUE.
*
LOAVAR	EQU  $
	MOV  @VARLO1,R2		GET VARIABLE LOCATION
	MOV  @ARGTYP,R4		GET ARGUMENT TYPE
	SLA  R4,1
	MOV  @LOATBL(R4),R4
	B    *R4
*
LOAVB1	EQU  $			LOAD INTEGER *1
	MOVB *R2,R5		GET BYTE VALUE
	SRA  R5,8
	MOV  R5,R6
	SRA  R5,7
	B    *R11
*
LOAVI2	EQU  $
	MOV  *R2,R6		GET LOW END INTEGER *2
	MOV  R6,R5
	SRA  R5,15		SET SIGN BIT
	B    *R11
*
LOAVI4	EQU  $			GET INTEGER *4
	MOV  *R2+,R5
	MOV  *R2,R6
	B    *R11
*
*  STOVAR : SAVE A VALUE ACCORDING TO TYPE.  THE VALUE IS IN
*	    REGISTERS R5 AND R6 IN INTEGER *4 FORMAT.  CONVERT
*	    IT TO APPROPRIATE OUTPUT FORMAT AND STORE.
*
STOVAR	EQU  $
	MOV  @VARLO1,R2		GET VARIABLE LOCATION
	MOV  @ARGTYP,R4		GET ARGUMENT SIZE
	SLA  R4,1		* 2
	MOV  @STOTBL(R4),R4	GET BRANCH LOCATION
	B    *R4
*
STOVB1	EQU  $			STORE A BYTE
	SWPB R6
	MOVB R6,*R2
	B    *R11
*
STOVI2	EQU  $
	MOV  R6,*R2		SAVE INTEGER *2
	B    *R11
*
STOVI4	EQU  $			SAVE INTEGER *4
	MOV  R5,*R2+
	MOV  R6,*R2
	B    *R11
*
	UNL
	IF   GENEVE
	COPY "excsupp.a99"
	ENDIF
	LIST
SEND	EQU  $
*
*  THE FOLLOWING EQUATES ARE TO THE FORTRAN PROGRAM
*  DATA AREA, AND IS THE WORKSPACE FOR THE EXECUTION SUPPORT
*  PACKAGE.
*
	IF   GENEVE
	AORG IOBBUF		GENEVE - LOCATE DYNAMIC DATA IN HIGH RAM
	ELSE
IOBBUF	EQU  $			TI-99/4A, JUST PUT AT END OF EXCTIME
	ENDIF
*
IOBUF	BSS  256		* I/O BUFFER START
IOBUFE	EQU  $
*
UNITSA	BSS  2			CURRENT UNIT NUMBER
FORMAT	BSS  2			CURRENT FORMAT ADDRESS
ENDADR	BSS  2			END LABEL ADDRESS OR 0 IF NOT SPECIFIED
ERRADR	BSS  2			ERR LABEL ADDRESS OR 0 IF NOT SPECIFIED
RECADR	BSS  2			RELATIVE RECORD OR 0 IF NOT SPECIFIED
STATUS	BSS  2			STATUS VARIABLE ADDRESS OR 0 IF NOT SPECIFIED
COUNT	BSS  2			REPEAT COUNT
PARENC	BSS  2			PARENTHESIS NESTING COUNT
NFLAG	BSS  2			0 UNLESS PROCESSING N ITEM
TICTOC	BSS  2			ODD/EVEN FLAG
CMPTIC	BSS  2			COMPLEX TIC-TOC FLAG (FOR LIST-DIRECTED)
FNDDEC	BSS  2			FOUND A DECIMAL POINT (1) OR NOT(0)
ARGTYP	BSS  2			ARGUMENT TYPE, 0-7
ARGSIZ	BSS  2			ARGUMENT SIZE, 1-8
CMPFLG	BSS  2			COMPLEX (1) OR NOT (0)
LISFOR	BSS  2			LIST DIRECTED FORMATTING (1) OR NOT(0)
DECIMA	BSS  2			# OF DECIMAL PLACES
WIDTH	BSS  2			WIDTH OF FORMAT ITEM
VARLO1	BSS  2			VARIABLE LOCATION
LPARPO	BSS  2			RELATIVE POSITION OF LATEST (
RESCNP	BSS  2			RESCAN POSITION IN FORMAT IF MORE ITEMS
PCNTSA	BSS  2			PAREN COUNT IF MUST RESCAN FORMAT
GRPCNT	BSS  2			REPEAT COUNT OF PARENTHESIS 2ND/3RD
GRPCNS	BSS  2			REPEAT COUNT OF PARENTHESIS 2ND
FIELDE	BSS  2			END OF FIELD POSITION IN I/O BUFFER
FIELDB	BSS  2			START OF FIELD POSITION IN I/O BUFFER
FCTIDX	BSS  2			CURRENT I/O BUFFER BEGIN
DIGCVA	BSS  2			ADDRESS OF ROUTINE CALLED BY DIGITC
DCNVRT	BSS  2			RETURN LOCATION FOR INPUT # CONVERSION
ARRAYS	BSS  2			REMAINING # OF BYTES IN ARRAY TO TRANSFER
ARRAYP	BSS  2			ADDRESS OF NEXT ARRAY ELEMENT TO TRANSFER
HVARAD	BSS  2			ADDRESS OF HOLLERITH VARIABLE
RESCNC	BSS  2			RESCAN REPEAT COUNT FOR () GROUP
IORTN	BSS  2			RETURN LOCATION OF VARIOUS ROUTINES
SCANRT	BSS  2			RETURN LOCATION USED BY SCANFM
DOREFL	BSS  2			HAS 'D' 'E' OR 0 FOR 'D','E', OR 'F' OUTPUT
R2SAVE	BSS  2			TEMP TO SAVE R2 WHEN CALLING DIGOUT
SMRTN	BSS  2			RETURN LOCATION FOR SHFMANT
GNFGID	BSS  2			INDEX TO VECTOR TABLE
TEMP1	BSS  2			ERROR RETURN TEMP SAVE
NUMBE1	BSS  2			4 WORD TEMP AREA
NUMBE2	BSS  2
NUMBE3	BSS  2
NUMBE4	BSS  2
RTNPTR	BSS  2			RETURN POINTER
CNVRTN	BSS  2			CONVERSION ROUTINE RETURN
DECEXP	BSS  2			DECIMAL EXPONENT
DIGTM3	BSS  2			TEMP SAVE CELL
NOBYTE	BSS  2			# OF BYTES READ/WRITTEN
VARSIG	BSS  2			VARIABLE SIGN
CHAR	BSS  2			CHARACTER SAVE
OFFSET	BSS  2			OFFSET TO FORMAT
CMDSTK	BSS  10			I/O COMMAND STACK
RESSTR	BSS  30			REAL INPUT STRING SAVE
RESEND	EQU  $
*
*  GENEVE ONLY SPECIFIC VARIABLES
*
	UNL
	IFEQ GENEVE
MYWSPO	BSS  32			MY WORKSPACE
ENDIOA	EQU  $
	UNL
	ELSE
	LIST
FAC	BSS  8			FLOATING POINT ACCUMULATOR
NOIOTA	BSS  2			# OF I/O TABLES (SET BY INIT)
SCRBFS	BSS  2			SCREEN BUFFER SIZE (BYTES)
IOBUFS	BSS  2			I/O BUFFER SIZE (BYTES)
IOTABL	BSS  2			I/O TABLE START ADDRESS (SET BY INIT)
SIOBUF	BSS  2			SCREEN I/O DATA START
IIOBUF	BSS  2			INPUT/OUTPUT DATA START
CHARSV	BSS  2			CHARACTER SAVE (FOR FSCROU)
TERCHA	BSS  2			TERMINATING SCREEN I/O CHARACTER
CSNPTR	BSS  2			CELLS FOR FAC CSN CONVERSION
MINUSF	BSS  2			  |  NEGATE FLAG
EXPONF	BSS  2			  V  EXPONANT FLAG
ESCCNT	BSS  2			ESCAPE CHARACTER COUNT
PRINTC	BSS  2			CHECK FOR CNTRL/S AFTER PRINT FLAG
PDEBUG	BSS  2			DEBUGGER (1) OR NOT (0)
IDEBUG	BSS  2			IN DEBUGGER (1) OR NOT(0)
PDEBRT	BSS  2			DEBUGGER RETURN VECTOR SAVE
FREMEM	BSS  2			FREE MEMORY START
ENDIOA	EQU  FREMEM-IOBBUF+2	RELATIVE
	ENDIF
	LIST
	RORG SEND		END WITH RELATIVE OFFSET
	END
