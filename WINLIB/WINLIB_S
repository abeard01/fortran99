* TIC V1.70 (12-Dec-1993) (c) 1991, 1993 by LGMA Products
	EVEN
*
	DEF	GETSRP			; GET SERVER PAGE
*
*  USER CALLABLE ROUTINES
*
	DEF	MENU			; DEFINE A MENU ITEM
	DEF	INMENU			; WAIT FOR MENU SELECTION

	DEF	QUITWINDOWS		; QUIT WINDOWS FROM TASK

	DEF	EXPICK			; EXTERNAL PICK REFRESH
	DEF	INPICK			; WAIT FOR PICK SELECTION

	DEF	DISPINT			; DISPLAY INTEGER
	DEF	DISPDATE		; DISPLAY DATE
	DEF	DISPTIME		; DISPLAY TIME
	DEF	DISPTEXT		; DISPLAY TEXT
	DEF	DISPROLL		; DISPLAY ROLL
	DEF	DISPICON		; DISPLAY ICON
	DEF	DISPBUTTON		; DISPLAY BUTTON

	DEF	PICKINT			; PICK INTEGER
	DEF	PICKDATE		; PICK DATE
	DEF	PICKTIME		; PICK TIME
	DEF	PICKTEXT		; PICK TEXT ITEM
	DEF	PICKROLL		; PICK ROLL
	DEF	PICKICON		; PICK ICON
	DEF	PICKBUTTON		; PICK BUTTON

	DEF	WGPUTS			; PUT STRING

	DEF	DEFINEFONT		; DEFINE A FONT
	DEF	SETFONT			; SET CURRENT FONT
	DEF	DELETEFONT		; DELETE A FONT
	DEF	SEARCHFONT		; SEARCH FOR A FONT

	DEF	WAITFOREVENT		; WAIT FOR AN EVENT
	DEF	WAKEUP			; WAKEUP WINAPI
	DEF	EXITSERVER		; EXIT THE SERVER
	
	DEF	CLOSEWINDOW		; CLOSE A WINDOW
	DEF	RELEASEWINDOW		; RELEASE A WINDOW
	DEF	CLEARWINDOW		; CLEAR A WINDOW
	DEF	OUTPUTWINDOW		; OUTPUT TO A WINDOW
	DEF	FORCESAVE		; FORCE SAVE TO A WINDOW
	DEF	REFRESHSCREEN		; REFRESH SCREEN
	DEF	WINDOW			; CREATE A WINDOW
	DEF	CHECKBOUNDS		; CHECK TO SEE IF IN BOUNDS

	DEF	EXCLUSIVEWINDOW		; DECLARE EXCLUSIVE TASK
	DEF	HIDEWINDOW		; HIDE A WINDOW
	DEF	SHAREWINDOW
	
*
*  REFERENCES - FROM MAIN TIC LIBRARY AND ALSO INTERTASK
*
	REF	FINDTASK		; FIND A TASK GIVEN NAME
	REF	PRINTF			; TIC PRINTF FUNCTION
	REF	EXIT			; EXIT ROUTINE
	REF	SENDMESSAGE		; SEND MESSAGE ROUTINE
	REF	GETMESSAGE		; GET MESSAGE ROUTINE
*
*  COPY FILES
*
	UNL
	COPY	":TIC/INCLUDES/GENVIDEO_I"
	COPY	":TIC/INCLUDES/GENBENCH_I"
	COPY	":TIC/INCLUDES/GENMESS_I"
	LIST
*
*  EQUATES
*
MMRREG	EQU	>F110		; MEMORY MAP REGISTER
*
*
*  data area for winlib subs
*
	EVEN
SERVERPAGE
	DATA	0		; PAGE SERVER EXISTS ON

RMESSAGE
	BSS	20		; RETURNED MESSAGE
	EVEN
SERVNAME			; NAME OF SERVER FUNCTION
	TEXT    'WINAPI'
	BYTE	0
	EVEN
BADSERV	TEXT	'Missing Windows Server Task'
	BYTE	>0d,>0a,>00
	EVEN
DVIDXP	DATA	VIDXOP
*
*******************************************************************************
*
*  GENERAL ROUTINES
*
*  WINLSETUP		:	GENERAL PURPOSE WINLSETUP ROUTINE
*  GETSERVERPAGE	:	RETURNS THE SERVER PAGE #
*  CHECKGADGET		:	DUMMY ROUTINE FOR MOUSE DRIVER
*  QUITWINDOWS		:	QUITS THE WINDOWS SERVER
*
**
**  ZERO - ZERO TERMINATE A STRING (TO MAKE COMPATIBLE WITH c)
**
**   BL @ZERO
**     ADDR OF ADDR OF SOURCE
**     ADDR OF ADDR OF DESTINATION
**
ZERO
	MOV	*R11+,R1	; GET 1ST ADDRESS
	MOV	*R1,R1
	MOV	*R11+,R2	; GET TO ADDRESS
	MOV	*R2,R2
*
MOVLOP	EQU	$
	CB	*R1,@KBLANK	; IS THIS A BLANK?
	JEQ	MOVDON		; BRIF YES, ALREADY TERMINATED
*
	CB	*R1,@KZERO	; IS IT ALREADY ZERO TERMINATED?
	JEQ	MOVDON		; BRIF YES
*
	MOVB	*R1+,*R2+	; ELSE, THEN COPY ANOTHER BYTE
	JMP 	MOVLOP
*
MOVDON	EQU	$
	CLR	R1
	MOVB	R1,*R2
	B	*R11		; DONE
KBLANK	TEXT  ' '
KZERO	BYTE  0
*
***********************************
*
*  WINLSETUP - SETUP FOR WINDOWS CALL
*
WINLSETUP
	AI	R14,40		; SPACE FOR SENT MESSAGE
	MOV	R11,R4		; SAVE RETURN VECTOR
*
*  CLEAR THE OUTBOUND MESSAGE (JUST TO MAKE DEBUGGING EASIER)
*
	MOV	R7,R5		; THE OUTBOUND MESSAGE
	LI	R6,20
CLRNEXT	EQU	$
	CLR	*R5+
	DEC	R6
	JNE	CLRNEXT
*
*  GET THE PAGE # THAT THE SERVER IS ON
*
	MOV	@SERVERPAGE,R8	; GET SERVER PAGE #
	JNE	SKIPSERV	; BRIF ALREADY FOUND IT

	BL	*R12
	DATA	GETSERVERPAGE

SKIPSERV
	MOV	R7,R5		; STUFF THE MESSAGE TO THE SERVER
*
	MOV	*R4+,*R5+	; SET OPCODE (FROM CALLING ROUTINE)
	CLR	R8
	MOVB	@MMRREG,R8	; GET MY PAGE ZERO OPCODE
	SWPB	R8
	MOV	R8,*R5+		; AND SAVE IT IN MESSAGE
	LI	R6,4		; THE LENGTH OF THE MESSAGE
*
*  loop for each argument in list, moving argument to message stack
*
NEXTPARS
	MOV	*R4+,R8		; GET NEXT ARGUMENT
	JEQ	STUFZERO	; STUFF A ZERO POINTER
*
	CI	R8,-1		; IS THIS TERMINATOR FOR LIST?
	JEQ	DONEPARS	; BRIF YES
*
*  else, this is a pointer to the stack of where the argument is pointing
*  now.  move it to the message buffer.
*
	A	R7,R8		; to get final offset
	MOV	*R8,*R5+
	INCT	R6		; and bump message count
	JMP	NEXTPARS
*
STUFZERO
	CLR	*R5+		; clear next word
	INCT	R6		; bump message count
	JMP	NEXTPARS	; and go extract another
*
*  when done parsing message, then call the server 
*
DONEPARS
	MOV	R7,*R14+	; THE OUTBOUND MESSAGE
*
	MOV	R6,*R14+	; THE LENGTH OF OUTBOUND MESSAGE
*
	MOV	@SERVERPAGE,*R14+
*
	BL	*R12
	DATA	SENDMESSAGE	; SEND THE MESSAGE
*
	CLR	@RMESSAGE+2
	LI	R8,RMESSAGE	; RETURNED MESSAGE AREA
	MOV	R8,*R14+
	BL	*R12
	DATA	GETMESSAGE	; GET ANY RETURNED MESSAGE
*
	AI	R14,>ffd0	; POP STACKS FOR BOTH ROUTINES & temp area
*
	B	*R4		; RETURNS IN R8 LENGTH OF RETURNED MESSAGE
*
************************
*
* GETSERVERPAGE - LOOK UP GEN WINDOWS SERVER PAGE
*
GETSERVERPAGE
*
*  NEED TO LOOK FOR THE SERVER PAGE.  USE THE FINDTASK ROUTINE WHICH
*  IS PART OF THE INTERTASK SUBROUTINE SET
*
	LI	R8,SERVNAME
	MOV	R8,*R14+
	BL	*R12
	DATA	FINDTASK
	DECT	R14
	MOV	R8,@SERVERPAGE	; SAVE THE NEW SERVER PAGE
	JNE	SERVDONE	; BRIF FOUND, THEN DONE
*
*  SERVER NOT FOUND.  JUST DISPLAY A MESSAGE AND LET THE USER TAKE CARE OF IT
*
	LI	R8,BADSERV
	MOV	R8,*R14+
	BL	*R12
	DATA	PRINTF		; PRINT IT
	DECT	R8
	LI	R8,999		; EXIT WITH ERROR CODE
	MOV	R8,*R14+
	BL	*R12
	DATA	EXIT
*
*  SERVER FOUND, JUST RETURN
*
SERVDONE
	CLR	R8
	MOV	@SERVERPAGE,R8	; RETURN SERVER PAGE
	B	*R11

**************************
*
*  THE FOLLOWING ROUTINE IS A DUMMY JUST IN CASE THE MOUSE ROUTINE IS THROWN IN
*
CHECKGADGET
	B 	*13

**************************
*
*  QUITWINDOWS QUITS THE WINDOWS PROGRAM AND DISCONNECTS THE PROGRAM FROM
*  THE WINDOWS API.
*
QUITWINDOWS
	BL	@WINLSETUP		; GO WINLSETUP MESSAGE
	DATA	FQUITWINDOWS	; THE OPCODE
	DATA	-1		; END OF PARSE TREE
	B	*R11		; AND RETURN

*******************************************************************************
*
*  MENU ROUTINES
*
*  MENU  	:	CREATE MENU ITEM
*  INMENU	:	WAITS FOR MENU SELECTION
*
MENU	EQU	$
	BL	@WINLSETUP		; WINLSETUP THE MESSAGE
	DATA	FMENU		; MENU OPCODE
	DATA	ARG#1		; COLUMN
	DATA	ARG#2		; ROW
	DATA	ARG#3		; TITLE
	DATA	-1
	B	*R11		; DONE
**************************
*
*  INMENU -
*
INMENU	EQU	$
	DATA	0
	DATA	BASEAD
	BL	@WINLSETUP
	DATA	FINMENU		; WINLSETUP THE MESSAGE
	DATA	-1		; NO PASSED ARGUMENTS
*
	MOV	@BASEAD,R3
	MOV	@RETUAD,R11
	MOV	@RMESSAGE+2,R5
	B	*R11		; AND RETURN

*********************************************************************************
*
*  EXPICK - EXTERNAL DISPLAY OF PICK LIST
*
EXPICK	EQU	$
	DATA	0
	DATA	BASEAD
	BL	@WINLSETUP
	DATA	FEXPICK		; OPCODE
	DATA	ARG#1		; 2 WINDOWNO
	DATA	-1
	MOV	@BASEAD,R3
	MOV	@RETUAD,R11
	B	*R11

****************************
*
*   INPICK - WAIT FOR A PICK LIST ITEM TO BE SELECTED
*
INPICK	EQU	$
	DATA	-1
	DATA	BASEAD
	BL	@WINLSETUP
	DATA	FINPICK		; OPCODE
	DATA	ARG#1		; WINDOWNO
	DATA	-1		; DONE
	MOV	@RMESSAGE+2,R5	; RETURN ANY VALUE
	MOV	@BASEAD,R3
	MOV	@RETUAD,R11
	MOV	R5,R5
	B	*R11

*********************************************************************************
*
*  DISPFUNC - DISP LIST FUNCTIONS
*
*
DISPINT	EQU	$
	DATA	-5
	DATA	BASEAD
	BL	@WINLSETUP
	DATA	FDISPINT	; DISP INTEGER
	DATA	ARG#1		; WINDOWNO
	DATA	ARG#2		; X COORD
	DATA	ARG#3		; Y COORD
	DATA	ARG#4		; NUMBCHARS
	DATA	ARG#5		; INTPTR
	DATA	-1		; DONE
	MOV	@BASEAD,R3
	MOV	@RETUAD,R11
	B	*R11
**************************
*
*  DISPDATE - 
*
DISPDATE EQU	$
	DATA	-4
	DATA	BASEAD
	BL	@WINLSETUP
	DATA	FDISPDATE	; DISP DATE
	DATA	ARG#1		; WINDOWNO
	DATA	ARG#2		; X COORD
	DATA	ARG#3		; Y COORD
	DATA	0		; NUMBCHARS
	DATA	ARG#4		; INTPTR
	DATA	-1		; DONE
	MOV	@BASEAD,R3
	MOV	@RETUAD,R11
	B	*R11

**************************
*
*  DISPTIME
*
DISPTIME EQU	$
	DATA	-4
	DATA	BASEAD
	BL	@WINLSETUP
	DATA	FDISPTIME	; OPCODE
	DATA	ARG#1		; WINDOWNO
	DATA	ARG#2		; XCOORD
	DATA	ARG#3		; YCOORD
	DATA	0		; NUMBCHARS
	DATA	ARG#4		; INTPTR
	DATA	-1		; DONE
	MOV	@BASEAD,R3
	MOV	@RETUAD,R11
	B	*R11

**************************
*
*  DISPTEXT
*
DISPTEXT EQU	$
	DATA	-4
	DATA	BASEAD
	BL	@WINLSETUP
	DATA	FDISPTEXT	; OPCODE
	DATA	ARG#1		; WINDOWNO
	DATA	ARG#2		; XCOORD
	DATA	ARG#3		; YCOORD
	DATA	ARG#4		; NUMBCHARS
	DATA	0		; INTPTR
	DATA	ARG#5		; TEXTPTR
	DATA	-1		; DONE
	MOV	@BASEAD,R3
	MOV	@RETUAD,R11
	B	*R11

**************************
*
*  DISPROLL
*
DISPROLL EQU	$
	DATA	-6
	DATA	BASEAD
	BL	@WINLSETUP
	DATA	FDISPROLL	; OPCODE
	DATA	ARG#1		; WINDOWNO
	DATA	ARG#2		; XCOORD
	DATA	ARG#3		; YCOORD
	DATA	ARG#4		; NUMBCHARS
	DATA	ARG#5		; INTPTR
	DATA	ARG#6		; TEXTPTR
	DATA	-1		; DONE
	MOV	@BASEAD,R3
	MOV	@RETUAD,R11
	B	*R11

***************************
*
*   DISPICON -
*
DISPICON EQU	$
	DATA	-7
	DATA	BASEAD
	BL	@WINLSETUP
	DATA	FDISPICON	; OPCODE
	DATA	ARG#1		; WINDOWNO
	DATA	ARG#2		; XCOORD
	DATA	ARG#3		; YCOORD
	DATA	ARG#4		; NUMBCHARS
	DATA	0		; INTPTR
	DATA	ARG#6		; TEXTPTR
	DATA    ARG#5		; BITMAP
	DATA	0		; LOWLIMIT
	DATA	0		; HIGHLIMIT
	DATA	ARG#7		; VALUE
	DATA	-1
	MOV	@BASEAD,R3
	MOV	@RETUAD,R11
	B	*R11

****************************
*
*   DISPBUTTON
*
DISPBUTTON EQU	$
	DATA	-6
	DATA	BASEAD
	BL	@WINLSETUP
	DATA	FDISPBUTTON	; OPCODE
	DATA	ARG#1		; WINDOWNO
	DATA	ARG#2		; XCOORD
	DATA	ARG#3		; YCOORD
	DATA	ARG#4		; NUMBCHARS
	DATA	0		; INTPTR
	DATA	ARG#5		; TEXTPTR
	DATA	0		; BITMAP
	DATA	0		; LOWLIMIT
	DATA	0		; HIGHLIMIT
	DATA	ARG#6		; VALUE
	DATA	-1
	MOV	@BASEAD,R3
	MOV	@RETUAD,R11
	B	*R11

*********************************************************************************
*
*  PICKFUNC - PICK LIST FUNCTIONS
*
*
PICKINT	EQU	$
	DATA	-7
	DATA	BASEAD
	BL	@WINLSETUP
	DATA	FPICKINT	; PICK INTEGER
	DATA	ARG#1		; WINDOWNO
	DATA	ARG#2		; X COORD
	DATA	ARG#3		; Y COORD
	DATA	ARG#4		; NUMBCHARS
	DATA	ARG#5		; INTPTR
	DATA	0		; TEXTPTR
	DATA	0		; BITMAP
	DATA	ARG#6		; LOWLIMIT
	DATA	ARG#7		; HIGHLIMIT
	DATA	-1		; DONE
	MOV	@BASEAD,R3
	MOV	@RETUAD,R11
	B	*R11
**************************
*
*  PICKDATE - 
*
PICKDATE EQU	$
	DATA	-4
	DATA 	BASEAD
	BL	@WINLSETUP
	DATA	FPICKDATE	; PICK DATE
	DATA	ARG#1		; WINDOWNO
	DATA	ARG#2		; X COORD
	DATA	ARG#3		; Y COORD
	DATA	0		; NUMBCHARS
	DATA	ARG#4		; INTPTR
	DATA	-1		; DONE
	MOV	@BASEAD,R3
	MOV	@RETUAD,R11
	B	*R11

**************************
*
*  PICKTIME
*
PICKTIME EQU	$
	DATA	-4
	DATA	BASEAD
	BL	@WINLSETUP
	DATA	FPICKTIME	; OPCODE
	DATA	ARG#1		; WINDOWNO
	DATA	ARG#2		; XCOORD
	DATA	ARG#3		; YCOORD
	DATA	0		; NUMBCHARS
	DATA	ARG#4		; INTPTR
	DATA	-1		; DONE
	MOV	@BASEAD,R3
	MOV	@RETUAD,R11
	B	*R11

**************************
*
*  PICKTEXT
*
PICKTEXT EQU	$
	DATA	-5
	DATA	BASEAD
	BL	@WINLSETUP
	DATA	FPICKTEXT	; OPCODE
	DATA	ARG#1		; WINDOWNO
	DATA	ARG#2		; XCOORD
	DATA	ARG#3		; YCOORD
	DATA	ARG#4		; NUMBCHARS
	DATA	0		; INTPTR
	DATA	ARG#5		; TEXTPTR
	DATA	-1		; DONE
	MOV	@BASEAD,R3
	MOV	@RETUAD,R11
	B	*R11

**************************
*
*  PICKROLL
*
PICKROLL EQU	$
	DATA	-8
	DATA	BASEAD
	BL	@WINLSETUP
	DATA	FPICKROLL	; OPCODE
	DATA	ARG#1		; WINDOWNO
	DATA	ARG#2		; XCOORD
	DATA	ARG#3		; YCOORD
	DATA	ARG#4		; NUMBCHARS
	DATA	ARG#5		; INTPTR
	DATA	ARG#6		; TEXTPTR
	DATA	0		; BITMAP
	DATA	ARG#7		; LOWLIMIT
	DATA	ARG#8		; HIGHLIMIT
	DATA	-1		; DONE
	MOV	@BASEAD,R3
	MOV	@RETUAD,R11
	B	*R11

***************************
*
*   PICKICON -
*
PICKICON EQU	$
	DATA	-6
	DATA	BASEAD
	BL	@WINLSETUP
	DATA	FPICKICON	; OPCODE
	DATA	ARG#1		; WINDOWNO
	DATA	ARG#2		; XCOORD
	DATA	ARG#3		; YCOORD
	DATA	ARG#4		; NUMBCHARS
	DATA	0		; INTPTR
	DATA	ARG#6		; TEXTPTR
	DATA    ARG#5		; BITMAP
	DATA	0		; LOWLIMIT
	DATA	0		; HIGHLIMIT
	DATA	ARG#7		; VALUE
	DATA	-1
	MOV	@BASEAD,R3
	MOV	@RETUAD,R11
	B	*R11

****************************
*
*   PICKBUTTON
*
PICKBUTTON EQU	$
	DATA	-6
	DATA	BASEAD
	BL	@WINLSETUP
	DATA	FPICKBUTTON	; OPCODE
	DATA	ARG#1		; WINDOWNO
	DATA	ARG#2		; XCOORD
	DATA	ARG#3		; YCOORD
	DATA	ARG#4		; NUMBCHARS
	DATA	0		; INTPTR
	DATA	ARG#5		; TEXTPTR
	DATA	0		; BITMAP
	DATA	0		; LOWLIMIT
	DATA	0		; HIGHLIMIT
	DATA	ARG#6		; VALUE
	DATA	-1
	MOV	@BASEAD,R3
	MOV	@RETUAD,R11
	B	*R11

********************************************************************************
*
*   FONTFUNC   :  FONT FUNCTIONS
*
*
WGPUTS	EQU	$		; WRITE GIVEN STRING TO WINDOW
	DATA	-2
	DATA	BASEAD
	BL	@WINLSETUP
	DATA	FWGPUTS		; OPCODE
	DATA	ARG#1		; WINDOWNO
	DATA	ARG#2		; STRING
	DATA	-1
	MOV	@BASEAD,R3
	MOV	@RETUAD,R11
	B	*R11	


***********************************
*
*  DEFINEFONT - 
*
DEFINEFONT
	DATA	-4
	MOV	BASEAD
	BL	@WINLSETUP		; DEFINE FONT
	DATA	FDEFINEFONT
	DATA	0		; FONTNO
	DATA	ARG#1		; HEIGHT
	DATA	ARG#2		; WIDTH
	DATA	ARG#3		; FONTNAME
	DATA	ARG#4		; BITMAP
	DATA	-1
	MOV	@BASEAD,R3
	MOV	@RETUAD,R11
	B	*R11

***********************************
*
*  SETFONT - SET FONT GIVEN FONT NAME
*
SETFON	EQU	$
	DATA	-1
	DATA	BASEAD
	BL	@WINLSETUP		; SET FONT
	DATA	FSETFONT	; OPCODE
	DATA	ARG#1		; FONT NAME
	DATA	-1
	MOV	@BASEAD,R3
	MOV	@RETUAD,R11
	B	*R11

***********************************
*
*  DELETEFONT - DELETE THE GIVEN FONT NAME
*
DELETE
	DATA	-1
	DATA	BASEAD
	BL	@WINLSETUP		; DELETE FONT
	DATA	FDELETEFONT
	DATA	ARG#1		; FONT NAME
	DATA	-1
	MOV	@BASEAD,R3
	MOV	@RETUAD,R11
	B	*R11

***********************************
*
*  SEARCHFONT - SEARCH FOR A GIVEN FONT NAME, RETURN ATTRIBUTES
*
SEARCH
	DATA	-1
	DATA	BASEAD
	BL	@WINLSETUP
	DATA	FSEARCHFONT	; SEARCH FOR FONT
	DATA	ARG#1		; FONT NAME
	DATA	-1
*
	MOV	R5,R5		; ANY GOOD RETURNED MESSAGE?
	JEQ	SEARCHRT	; BRIF NO
	MOV	@RMESSAGE+2,R5
SEARCHRT
	MOV	@BASEAD,R3
	MOV	@RETUAD,R11
	MOV	R5,R5
	B	*R11

***********************************************************************************
*
*  MISCFUNC - MISCELLANEOUS FUNCTIONS
*
*  WAITFOREVENT - WAIT FOR ANY EVENT
*
WAITFO
	DATA	0
	DATA	BASEAD
	BL	@WINLSETUP
	DATA	FWAITFOREVENT	; WAIT FOR ANY EVENT
	DATA	-1
*
	MOV	R5,R5		; ANY RETURNED MESSAGE?
	JEQ	SEARCHWA	; BRIF NO
	MOV	@RMESSAGE+2,R5
SEARCHWA
	MOV	@BASEAD,R3
	MOV	@RETUAD,R11
	MOV	R5,R5
	B	*R11

********************************
*
*  WAKEUP - IS A SPECIAL FUNCTION THAT JUST SENDS AN EVENT TO THE WINDOWS
*  SERVER TO SEE IF IT IS ALIVE.  IF SO, IT RETURNS A -1.
*
WAKEUP
	DATA	0
	DATA	BASEAD
	BL	@WINLSETUP
	DATA	FWAKEUP
	DATA	-1
*
	MOV	R5,R5		; WAS A MESSAGE RETURNED?
	JEQ	SEARCHWK	; BRIF NO
	MOV	@RMESSAGE+2,R5
SEARCHWK
	MOV	@BASEAD,R3
	MOV	@RETUAD,R11
	MOV	R5,R5
	B	*R11

*********************************
*
*  EXITSERVER - EXITS THE WINAPI SERVER (NOT RECOMMENDED) 
*
EXITSE
	DATA	0		; NO ARGUMENTS
	DATA	BASEAD
*
	LI	R5,IMESSAGE	; CREATE MESSAGE TO SEND
*
	LI	R8,FEXIT	; EXIT SERVER
	MOV	R8,*R5+
*
	CLR	R8
	MOVB	@MMRREG,R8
	SWPB	R8
	MOV	R8,*R5+		; SAVE MY PAGE ZERO
	
	BLWP	*R10		; CALL SEND MESSAGE
	DATA	SENDME
	DATA	0
	DATA	0
	DATA	>0388
	DATA	
	MOV	R7,*R14+	; START OF SENT MESSAGE
*
	LI	R6,4		; # OF BYTES TO SEND
	MOV	R6,*R14+	; THE LENGTH OF OUTBOUND MESSAGE
*
	MOV	@SERVERPAGE,*R14+
*
	BL	*R12
	DATA	SENDMESSAGE	; SEND THE MESSAGE
*
	AI	R14,-46		; POP STACK FOR SENDMESSAGE & TEMP MESSAGE
*
	B	*R11		; RETURNS IN R8 LENGTH OF RETURNED MESSAGE

*********************************************************************************
*
*  WINDOWS FUNCTIONS
*
*  CLOSEWINDOW - CLOSE A WINDOW
*

CLOSEWINDOW
	DATA	-1
	DATA	BASEAD
	BL	@WINLSETUP
	DATA	FCLOSEWINDOW
	DATA	ARG#1		; WINDOWNO
	DATA	-1
	MOV	@BASEAD,R3
	MOV	@RETUAD,R11
	B	*R11

*************************************
*
*  RELEASEWINDOW - RELEASE A WINDOW
*
RELEASE
	DATA	-1
	DATA	BASEAD
	BL	@WINLSETUP
	DATA	FRELEASEWINDOW
	DATA	ARG#1		; WINDOWNO
	DATA	-1
	MOV	@BASEAD,R3
	MOV	@RETUAD,R11
	B	*R11

*************************************
*
*  CLEARWINDOW - CLEAR THE CURRENT WINDOW
*
CLEARW
	DATA	-1
	DATA	BASEAD
	BL	@WINLSETUP
	DATA	FCLEARWINDOW
	DATA	ARG#1
	DATA	-1
	MOV	@BASEAD,R3
	MOV	@RETUAD,R11
	B	*R11

*************************************
*
*  OUTPUTWINDOW - SELECT A WINDOW FOR OUTPUT
*
OUTPUT
	DATA	-1
	DATA	BASEAD
	BL	@WINLSETUP
	DATA	FOUTPUTWINDOW
	DATA	ARG#1
	DATA	-1

	MOV	R5,R5		; DID A MESSAGE GET RETURNED?
	JEQ	OUTDONE		; BRIF NO

	MOV	@RMESSAGE+2,R5
	JEQ	OUTDONE		; BRIF NOTHING RETURNED

	LI	R0,SETTCO	; SETTEXTCOLOR
	SWPB	R8
	MOV	R8,R1		; SET COLORS
	XOP	@DVIDXP,0	; AND SET VIDEO XOP TEXT COLOR
*
OUTDONE
	MOV	@BASEAD,R3
	MOV	@RETUAD,R11
	MOV	R5,R5
	B	*R11

************************************
*
*  FORCESAVE - FORCE A SAVE OF ALL WINDOWS TO MEMORY
*
FORCES
	DATA	0
	DATA	BASEAD
	BL	@WINLSETUP
	DATA	FFORCESAVE
	DATA	-1		; NO ARGUMENTS
	MOV	@BASEAD,R3
	MOV	@RETUAD,R11
	B	*R11

*************************************
*
*  REFRESHSCREEN - REFRESH ALL WINDOWS ON THE SCREEN
*
REFRES
	DATA	0
	DATA	BASEAD
	BL	@WINLSETUP
	DATA	FREFRESHSCREEN
	DATA	-1		; NO ARGUMENTS
	MOV	@BASEAD,R3
	MOV	@RETUAD,R11
	B	*R11

*************************************
*
*  WINDOW - OPEN A NEW WINDOW ON THE SCREEN
*
WINDOW
	DATA	-9		; #ARGS
	DATA	BASEAD
*
	BL	@ZERO		; ZERO TERMINATE TITLE
	DATA	ARG#8
	DATA	ASTRNG1
*
	BL	@ZERO		; ZERO TERMINATE FONTNAME
	DATA	ARG#9
	DATA	ASTRNG2
*
	BL	@WINLSETUP
	DATA	FWINDOW		; OPCODE
	DATA	ARG#1		; WINDOWNO
	DATA	ARG#2		; TOPX
	DATA	ARG#3		; TOPY
	DATA	ARG#4		; XPIXELS
	DATA	ARG#5		; YPIXELS
	DATA	ARG#6		; FGCOLOR
	DATA	ARG#7		; BGCOLOR
	DATA	ASTRNG1		; TITLE
	DATA	ASTRNG2		; FONTNAME
	DATA	-1

	MOV	R5,R5		; DID A MESSAGE GET RETURNED?
	JEQ	WINDONE		; BRIF NO

	MOV	@RMESSAGE+2,R5
	JNE	WINDONE		; BRIF NOTHING RETURNED

	MOV	@ARG#6(R7),R5	; FGCOLOR
	DEC	R5
	MOV	@ARG#7(R7),R6	; BGCOLOR
	DEC	R6
	ANDI	R6,>FF
	SWPB	R6
	ANDI	R5,>FF
	SOC	R5,R6
	LI	R0,SETTCO	; SETTEXTCOLOR
	MOV	R6,R1		; SET COLORS
	XOP	@DVIDXP,0	; AND SET VIDEO XOP TEXT COLOR
*
WINDONE
	MOV	@BASEAD,R3	; RESTORE USER BASE
	MOV	@RETUAD,R11	; RESTORE RETURN
	B	*R11

*********************************8
*
*  CHECKBOUNDS - CHECK IF MOUSE CLICK INSIDE THIS WINDOW DEFINITION
*
CHECKB
	DATA	-3
	DATA	BASEAD
	MOV	@ARG#1,R1	; IX
	MOV	*R1,R1
	MOV	@ARG#2,R2	; IY
	MOV	*R2,R2
	MOV	@ARG#3,R3	; WPTR
	MOV	*R3,R3
*
	MOV	R3,R4
	AI	R4,WINTLCX
	C	R1,*R4
	JLT	OUTBOUNDS

	MOV	R3,R4
	AI	R4,WINBRCX
	C	R1,*R4
	JGT	OUTBOUNDS

	MOV	R3,R4
	AI	R4,WINTLCY
	C	R2,*R4
	JLT	OUTBOUNDS

	MOV	R3,R4
	AI	R4,WINBRCY
	C	R2,*R4
	JGT	OUTBOUNDS

	MOV	@BASEAD,R3
	LI	R5,TRUE
	B	*R11
*
OUTBOUNDS
	MOV	@BASEAD,R3
	LI	R5,FALSE
	B	*R11

****************************************************************************
*
*  SHARE - WINDOW SHARING
*
*  EXCLUSIVE - SET EXCLUSIVE WRITE MODE
*
EXCLUS
	DATA	-1
	DATA	BASEAD
	BL	@WINLSETUP
	DATA	FEXCLUSIVEWINDOW
	DATA	0
	DATA	ARG#1		; TPAGENO
	DATA	-1
	MOV	@BASEAD,R3
	MOV	@RETUAD,R11
	B	*R11

*********************************************
*
*  HIDEWINDOW - HIDE A CERTAIN TASK'S WINDOW
*
HIDEWI
	DATA	-1
	DATA	BASEAD
	BL	@WINLSETUP
	DATA	FHIDEWINDOW
	DATA	0
	DATA	ARG#1		; TPAGENO
	DATA	-1
	MOV	@BASEAD,R3
	MOV	@RETUAD,R11
	B	*R11

*********************************************
*
*  SHAREWINDOW - SHARE ALL TASKS
*
SHAREW
	DATA	-1
	DATA	BASEAD
	BL	@WINLSETUP
	DATA	FSHAREWINDOW
	DATA	0
	DATA	0
	DATA	-1
	MOV	@BASEAD,R3
	MOV	@RETUAD,R11
	B	*R11
*
*  DATA AREA
*
BASEAD	BSS	2
RETUAD	BSS	2		; RETURN TO CALLER ADDRESS
ARG#1	BSS	2
ARG#2	BSS	2
ARG#3	BSS	2
ARG#4	BSS	2
ARG#5	BSS	2
ARG#6	BSS	2
ARG#7	BSS	2
ARG#8	BSS	2
ARG#9	BSS	2
*
ASTRNG1	DATA	STRNG1
ASTRNG2	DATA	STRNG2
*
STRNG1	BSS	40
STRNG2	BSS	40
	END
????????????
	EVEN
**
** BUILDC - BUILD A CHARACTER ARRAY, SIMULATING A C TEXT POINTER ARRAY
**
**  ADR = BUILDC ( TEXT_ARRAY_START, #CHARS, #ELEMENTS )
**
BUILDC  EQU  $
	DATA -3			; 3 ARGUMENTS
	DATA BASEAD
*
	MOV  @ARG1,R1		; GET START ADDRESS OF TEXT ARRAY
	MOV  @ARG2,R2		; GET # CHARS IN ARRAY
	MOV  *R2,R2
	MOV  @ARG3,R3		; GET # ELEMENTS IN ARRAY
	MOV  *R3,R3
*
	MOV  @SBUFFER,R4	; START OF MY BUFFER POINTER
**
MAKEARY EQU  $
	MOV  R1,*R4+		; SAVE NEXT POINTER
	A    R2,R1		; + # CHARS IN ARRAY
	DEC  R3
	JNE  MAKEARY
*
	MOV  @SBUFFER,R5	; START OF CURRENT BUFFER
	MOV  R4,@SBUFFER	; UPDATE POINTER
	MOV  @BASEAD,R3
	MOV  @RETUAD,R11
	MOV  R5,R5
	B    *R11
*
*  ARGUMENTS
*
BASEAD  BSS   2			; BASE ADDRESS
RETUAD  BSS   2			; RETURN ADDRESS
ARG1    BSS   2			; 4 ARGUMENTS
ARG2    BSS   2
ARG3    BSS   2
*
SBUFFER	DATA  BUFFER		; START OF BUFFER
BUFFER	BSS   500		; UP TO 250 ENTRIES
        END

