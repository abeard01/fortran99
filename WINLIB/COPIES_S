        TITL   'UTLITY COPY ROUTINES'
        IDT    'COPYS'
**
** COPIES    : Several utility copy routines (across task boundries)
**
** void  pbytecpy ( mytaskadr, pageno, usertaskadr, #bytes )
**
** (c) 1992 by LGMA Products
**
	DEF  PBYTEC		; COPY SPECIFIED BYTES FROM USER TASK
**
	UNL
	COPY ":TIC/INCLUDES/UTILITY_I"
	LIST
*
*  PAGE ZERO TASK EQUATES AND OTHERS
*
TSKMAP	EQU  >0114		; TASK MAP 
MMRREG	EQU  >F110		; MEMORY MAP REGISTERS
*
*  EQUATES IN OS TASK PAGE 0
*
HEAD#T  EQU  >0028		; Start of task header
*
**
START   EQU  $
**
** PBYTECPY      - COPY #BYTES FROM ANOTHER TASK TO THIS TASK
**
PBYTEC  EQU  $
	DATA -4			; 4 ARGUMENTS
	DATA BASEAD
	MOV  @ARG2,R1		; GET THE USER TASK PAGE 0 ADDRESS
	MOV  *R1,R1
	SWPB R1
	MOVB R1,@PAGZER		; PAGE ZERO ADDRESS
	BL   @DETERM		; GET IT
	LI   R1,TSKMAP
	A    R9,R1		; SAVE A COPY OF USER TASK MAP
	LI   R2,UTSKMAP		; TO MY COPY OF USER TASK MAP
	MOV  *R1+,*R2+
	MOV  *R1+,*R2+
	MOV  *R1+,*R2+
	MOV  *R1,*R2
	BL   @RESTOR		; RESTORE MY ORIGINAL MAP
*
*  STRING IS COPIED IN TWO STEPS.  FIRST, THE STRING IS COPIED TO MY STACK,
*  WHICH ENSURES THAT IT WILL ALWAYS BE MAPPED.  SECONDLY, IT IS COPIED TO
*  THE FINAL USER TARGET LOCATION.
*
	MOV  @ARG3,R1		; MOVE FROM ADDRESS
	SRL  R1,13		; GET PAGE ADDRESS
	MOVB @UTSKMAP(R1),@PAGZER
	BL   @DETERM		; DETERMINE START ADDRESS
*
	MOV  @ARG3,R1
	MOV  @ARG3,R4		; REAL ADDRESS
	MOV  @ARG4,R6		; # OF BYTES TO MOVE
	MOV  *R6,R6
	ANDI R1,>1FFF		; MASK LOW ORDER PART
	A    R9,R1		; + START OFFSET
	LI   R2,TEMPBU		; MOVE TO ADDRESS
	LI   R3,>2000		; BREAKPOINT ADDRESS
	A    R9,R3
*
PBYTMV	EQU  $
	INC  R4
	MOVB *R1+,*R2+		; GET A BYTE
	DEC  R6			; DECR # BYTES TO MOVE
	JEQ  PBYTDN		; BRIF DONE
*
	C    R1,R3		; DID I GO OFF PAGE?
	JNE  PBYTMV
*
*  WENT OFF A PAGE.  SAVE MY CURRENT ADDRESSES, RECOMPUTE PAGE, AND CONTINUE
*
	MOV  R4,@SAVER4		; SAVE FROM ADDRESS
	MOV  R2,@SAVER2		; SAVE TO ADDRESS
	BL   @RESTOR		; RESTORE ORIGINAL PAGE
*
	MOV  @SAVER4,R1		; GET NEW START
	SRL  R1,13
	MOVB @UTSKMAP(R1),@PAGZER
	BL   @DETERM		; DETERMINE START ADDRESS
	MOV  @SAVER4,R1
	MOV  @SAVER4,R4
	ANDI R1,>1FFF
	A    R9,R1
	MOV  @SAVER2,R2		; RESTORE MY "MOVE TO" ADDRESS
	LI   R3,>2000
	A    R9,R3
	JMP  PBYTMV
*
PBYTDN	EQU  $
	BL   @RESTOR
*
*  NOW DO A STRAIGHT STRING COPY FROM MY STACK TO FINAL USER AREA
*
	LI   R1,TEMPBU		; MOVE FROM ADDRESS
	MOV  @ARG1,R2		; MOVE TO ADDRESS
	MOV  @ARG4,R6		; # OF BYTES TO MOVE
	MOV  *R6,R6
*
PBYTCP	EQU  $
	MOVB *R1+,*R2+		; DO UNTIL NULL
	DEC  R6
	JNE  PBYTCP
*
	B    *R13
**
** DETERM - DETERMINE WHAT PAGE & ADDRESS I CAN USE FOR MULTITASKING
**          BASED UPON WHAT START/END PAGES THIS ROUTINE IS MAPPED IN.
**
DETERM	EQU  $
	CLR  R5
CHKNEXT	EQU  $
	INC  R5			; BUMP TO NEXT PAGE
	LI   R1,START		; GET STARTING ADDRESS
	SRL  R1,13		; GET PAGE #
	C    R1,R5
	JEQ  CHKNEXT		; THIS ONE ISN'T GOOD, TRY NEXT
	LI   R1,SEND
	SRL  R1,13
	C    R1,R5
	JEQ  CHKNEXT		; THIS ONE ISN'T GOOD EITHER, TRY NEXT
	LIMI 0			; DISABLE INTERRUPTS
	MOV  R5,@PAGMAP		; SAVE PAGE NUMBER TO MAP
	SLA  R5,13
	MOV  R5,@PAGADR		; SAVE STARTING ADDRESS OF PAGE
	LI   R5,MMRREG		; GET STARTING MEMORY MAP REG
	A    @PAGMAP,R5		; + MY MAP PAGE
	MOVB *R5,@SAVPAG
	MOVB @PAGZER,*R5	; SET THE MAPPER REG
	MOV  @PAGADR,R9		; SET START OF PAGE ADDRESS IN R9
	B    *R11
**
** RESTOR - RESTORE MY PAGE AND ENABLE INTERRUPTS
**
RESTOR	EQU  $
	LI   R2,MMRREG			; RESTORE MEMORY PAGE
	A    @PAGMAP,R2
	MOVB @SAVPAG,*R2
	LIMI 2				; ENABLE INTERRUPTS
	B    *R11
**
** DATA AREA
**
*
BASEAD  BSS  2
RETUAD  BSS  2
ARG1	BSS  2
ARG2	BSS  2
ARG3	BSS  2
ARG4 	BSS  2
*
DUTLXP	DATA UTLXOP			; UTILITY XOP NUMBER
PAGMAP	DATA 0				; PAGE # THAT I CAN MAP ON
PAGADR	DATA 0				; PAGE ADDRESS THAT I CAN MAP ON
SAVPAG  BYTE 0				; SAVED PAGE # AT MY PAGE ADDRESS
PAGZER	BYTE 0				; PAGE ZERO SAVE
	EVEN
UTSKMAP DATA 0,0,0,0			; USER TASK MAP
SAVER2  DATA 0
SAVER4	DATA 0
*
TEMPBU  BSS  80				; MAXIMUM 80 BYTE MOVE
	EVEN
SEND    EQU  $
	END
