        TITL   'FORTRAN MISC SUPPORT ROUTINES FOR WINDOWING'
        IDT    'MISC'
**
**  ADR - RETURN ADDRESS OF ARGUMENT AS ARGUMENT
**
	DEF    ADR
	DEF    ZERO
	DEF    BUILDC
*
*
* ADR
*
ADR
	DATA  -1
        DATA  BASEAD
	MOV   @BASEAD,R3
	MOV   @RETUAD,R11
        MOV   @ARG1,R5		; RETURN THIS AS ADDRESS
        B     *R11
**
**  ZERO - ZERO TERMINATE A STRING (TO MAKE COMPATIBLE WITH c)
**
**      call zero ( string1, string2 )
**
**  where:   string1 is the input string
**           string2 is a copy with zero termination
**
ZERO
	DATA  -2		; 2 ARGUMENTS
	DATA  BASEAD
	MOV   @ARG1,R1		; MOVE FROM ADDRESS
	MOV   @ARG2,R2		; MOVE TO ADDRESS
*
MOVLOP	EQU  $
	CB    *R1,@KBLANK	; IS THIS A BLANK
	JEQ   MOVDON		; BRIF YES, DONE
	CB    *R1,@KZERO	; IS IT ALREADY ZERO TERMINATED?
	JEQ   MOVDON
	MOVB  *R1+,*R2+		; ELSE, MOVE IT
	JMP   MOVLOP
*
MOVDON	EQU   $
	CLR   R1
	MOVB  R1,*R2		; ZERO TERMINATE THE STRING
	MOV   @BASEAD,R3
	MOV   @RETUAD,R11
	B     *R11
*
KBLANK	TEXT  ' '
KZERO	BYTE  0
	EVEN
**
** BUILDC - BUILD A CHARACTER ARRAY, SIMULATING A C TEXT POINTER ARRAY
**
**  ADR = BUILDC ( TEXT_ARRAY_START, #CHARS, #ELEMENTS )
**
BUILDC  EQU  $
	DATA -3			; 3 ARGUMENTS
	DATA BASEAD
*
	MOV  @ARG1,R1		; GET START ADDRESS OF TEXT ARRAY
	MOV  @ARG2,R2		; GET # CHARS IN ARRAY
	MOV  *R2,R2
	MOV  @ARG3,R3		; GET # ELEMENTS IN ARRAY
	MOV  *R3,R3
*
	MOV  @SBUFFER,R4	; START OF MY BUFFER POINTER
**
MAKEARY EQU  $
	MOV  R1,*R4+		; SAVE NEXT POINTER
	A    R2,R1		; + # CHARS IN ARRAY
	DEC  R3
	JNE  MAKEARY
*
	MOV  @SBUFFER,R5	; START OF CURRENT BUFFER
	MOV  R4,@SBUFFER	; UPDATE POINTER
	MOV  @BASEAD,R3
	MOV  @RETUAD,R11
	MOV  R5,R5
	B    *R11
*
*  ARGUMENTS
*
BASEAD  BSS   2			; BASE ADDRESS
RETUAD  BSS   2			; RETURN ADDRESS
ARG1    BSS   2			; 4 ARGUMENTS
ARG2    BSS   2
ARG3    BSS   2
*
SBUFFER	DATA  BUFFER		; START OF BUFFER
BUFFER	BSS   500		; UP TO 250 ENTRIES
        END
