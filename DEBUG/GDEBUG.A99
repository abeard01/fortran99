	TITL 'MDOS VERSION NON-SYMBOLIC DEBUGGER'
	IDT 'DEBUG'
*
*  THIS PROGRAM IS A SIMPLE DEBUGGER FOR MDOS
*
*  To setup for this debugger:
*
*   1. Include the following code in the startup sequence of your
*      program:
*
*                     REF  DEBUG$
*
*                     LWPI >F000
*                     LI   R0,DEBUG$
*                     JEQ  NOTHER
*                     BL   *R0
*             NOTHER  EQU  $
*
*   2. The only area you cannot use for your program is from >F074 to
*      >F07E (my workspace).  This routine saves and restores any other
*      memory areas it uses.   Also, the user workspace must be at >F000
*      on initial entry in this routine (can move afterward).
*
*   Other Notes:
*
*   The code for this debugger is entirely original.  The format of the
*   commands is patterned after the TI Debugger released with the E/A
*   package.
*
*   The debugger does not allocate any memory for you, you must allocate
*   your own according to normal MDOS rules.
*
*   The debugger is distributed as a single relocatable object file.
*
*   The debugger commands are:
*
*		B       Breakpoint List/Add/Remove
*               R       Register Display/Alter
*		W       Workspace Display/Alter
*		H       Hexadecimal Arithmetic
*		Q       Execute into program (quit debugger)
*		X       Provide X Bias
*		Y       Provide Y Bias
*		Z       Provide Z Bias
*
*   Operation of each command is similar to the operation of the
*   TI-99 debugger, with the following exceptions:
*
*      1. Any value may be supplied as a decimal value, instead of
*	  a hexadecimal value by preceding the value with the letter
*         'I'.
*
*      2. The workspace register number is in hexadecimal unless it
*         is preceded by an 'I'.
*
*      3. The debugger does not "space" for you, you must do it your-
*         self after typing a command letter.
*		
*   Examples of command usage are:
*
*		B                  List all breakpoints
*		B-                 Remove all breakpoints
*		B 0480-            Remove breakpoint at loc 480
*               B 0480             Add breakpoint at loc 480
*               R                  Modify Registers
*               W                  Display Workspace Registers
*               W I10              Modify Workspace Register 10
*               M 0480             Display/Modify starting at loc 0480
*               M 0480 04F0        Display locs 480 to 4f0
*               M 1000V 1010       Display VDP Memory, locs 1000 to 1010
*               M 5CX              Modify Memory at loc 5C with X Bias
*               H I100 2AC         Hex Arithmetic with decimal 100 & hex 2ac
*               Q                  Quit (execute task)
*               X I100             X bias of decimal 100
*               Y 2AC              Y bias of hexadecimal 2ac
*               Z                  Z bias of zero (reset)
*
*   Update History:
*
*    V1.0   30-NOVEMBER-1987     INITIAL RELEASE BY ALAN L. BEARD
*
*    V1.1   12-DECEMBER-1987     Changed my workspace address to end >f0c0.
*				 Added SAVE/RESTORE memory areas since
*				 this is required for breakpoints.  Redid
*				 the memory inspect/alter and workspace
*				 inspect/alter to retrieve out of save
*				 area instead of real memory if appropriate.
*				 Removed INITFL as no longer needed.  Update
*				 version # on initial display.  Added logic
*				 to screen output to hold on keypress, and
*				 release when done.  Also, abort via cntrl/c
*				 if pressed during output.
*
*    v1.2   20-December-1987     Changed to NOT allocate memory space,
*				 leave that to the user.  Also, start
*				 address of user task in second word.
*
*    v1.3   27-December-1987	 Moved my registers from >F0C0 to >F060,
*				 in accordance with the MDOS user's guide,
*				 which says memory in area >F080 to >F13F
*				 are used by the operating system.  Now
*				 the program clobbers only F074 to F07E.
*
*    v1.4   02-January-1988      Fixed bug with removing all breakpoints
*				 (B-).  Was clobbering 1st breakpoint word,
*				 and not clearing second.
*
*    v1.5   19-January-1988	 Reduced breakpoints to 6 (from 10).
*
*    v1.6   13-March-1988 	 Display/Modify VDP memory added.
*
*    V1.7   15-July-1988         Changed entrance so that R11 is saved
*				 and used to return after initialization.
*				 This now fits in with FORTRAN execution
*				 time needs.
*
*    V1.8   19-SEP-1988          Put in auto-version
*
*    V1.9   14-OCT-1988          Corrected VDP Access.  Code was added
*				 to correctly access bank switch, so that
*				 first 64k of VDP RAM could be accessed.
*
*    V1.10  09-JAN-1989          Changed to XOP breakpoint instead of BLWP
*				 breakpoint.   Added X,Y,Z bias.   Added
*				 comments.
*
*    V1.11  19-Feb-1989          Fixed a bug with putting on breakpoints
*				 caused by the previous modification.
*
*				 Handle correctly case where a breakpoint
*				 is placed or removed within my save area
*				 (>ef80 to >efff).
*
*				 Removed "breakpoints per listed line"
*				 logic, not needed in 80 column mode.
*
*  Copyright 1989 by LGMA Products
*
	DEF  DEBUG$		MY ENTRY POINT
*
*  EQUATE FILES:
*
	UNL
	COPY  "equates:key.eq9"
	COPY  "equates:vid.eq9"
	LIST
*
	RORG 0
DEBUG$	EQU  $
	B    @ENTRY
FSTART	DATA 0			USER PROGRAM ENTRY SAVE (HIS R11)
*
	TITL 'DEBUGGER DATA AREA'
*
FREGS	EQU  >F000		USER PROGRAM WORKSPACE START
WREGS	EQU  >F020		MY UTILITIES WORKSPACE START
IOBUF	EQU  >EF80		MY I/O BUFFER
SAVEND	EQU  >F074		SAVE END ADDRESS
REG14C	EQU  >8E00		REGISTER 14 ACCESS CODE
VDPOR0	EQU  >F100		VDP PORT 0
VDPOR1	EQU  >F102		VDP PORT 1
XOPNUM	EQU  4			XOP NUMBER USED FOR BREAKPOINT
XOPLOC	EQU  XOPNUM*4+>40	XOP LOCATION FOR WP, PC
*
*  OTHER MISC. EQUATES:
*
NOBPS  EQU  6			NUMBER OF BREAKPOINTS, MAXIMUM
MREGS  EQU  >F060		MY REGISTERS START (WAS F020)
*
*  ZERO CLEARED DATA AREA:
*
BPBUFF	EQU $
	BSS  NOBPS*4		SAVE AREA FOR BREAKPOINTS
STASYM	BSS  2			STARTING SYMBOL ADDRESS (MAIN PROGRAM)
SELSYM	BSS  2			SELECTED SYMBOL ADDRESS (THIS MODULE)
XBIAS	BSS  2			X - BIAS VALUE
YBIAS	BSS  2			Y - BIAS VALUE
ZBIAS	BSS  2			Z - BIAS VALUE
TOCLEA	EQU  $-BPBUFF
*
*  NON-CLEARED DATA AREA:
*
HEXDIG	BSS  6			HEXADECIMAL DIGITS (UP TO 3)
VDPFLG	BSS  2			'V' SPECIFIED IN HEX NUMBER
INTSAV	BSS  2			INTERRUPT LEVEL SAVE
SYMFLG	BSS  2			SYMBOL ENCOUNTERED FLAG
SYMIMG	BSS  20	   		SYMBOL IMAGE
SYMTYP	BSS  2			SYMBOL TYPE (-1=IDT,0=NAME,1=LABEL,2=LINE)
FORTYP	BSS  2			FORMAT TYPE (0=NORM, 1=HEX, 2=ALPHA)
SYMSAV	BSS  2			SAVE CELL FOR SYMBOL LOOKUP
SYMRET	BSS  2			SAVE CELL FOR SYMBOL LOOKUP
SYMTMP	BSS  2			SYMBOL TEMP FOR WRITES
SYMTMR	BSS  2			SYMBOL TEMP FOR READS
PROCTB	BSS  2			PROCESS TABLE BRANCH ADDRESS
BIAS	BSS  2			DYNAMICALLY SUPPLIED BIAS
*
*  THE FOLLOWING HOLDS THE MEMORY REQUIRED WHEN SAVED/RESTORED
*
SAVARE	EQU  $
	BSS  SAVEND-IOBUF	SAVE AREA
*
*  TABLE OF COMMANDS
*
TABLE1	EQU $
	TEXT 'M'		  MEMORY INSPECT/MODIFY
	BYTE 2
	DATA M
*
	TEXT 'W'		  WORKSPACE INSPECT/MODIFY
	BYTE 1
	DATA W
*
	TEXT 'B'		  BREAKPOINTS
	BYTE 1
	DATA B
*
	TEXT 'H'		  HEX ARITHMETIC
	BYTE 2
	DATA H
*
	TEXT 'R'	 	 REGISTER INSPECT/ALTER
	BYTE 0
	DATA R
*
	TEXT 'X'		 X-BIAS
	BYTE 1
	DATA X
*
	TEXT 'Y'		 Y-BIAS
	BYTE 1
	DATA Y
*
	TEXT 'Z'		 Z-BIAS
	BYTE 1
	DATA Z
*
	TEXT 'Q'		  QUIT
	BYTE 0
	DATA Q
*
	DATA 0
*
*  OTHER MISC. DATA CELLS
*
XOPINS	XOP  R0,XOPNUM		XOP VALUE
*
DVIDXP	DATA VIDXOP		VIDEO XOP NUMBER
DKEYXP	DATA KEYXOP		KEYBOARD XOP NUMBER
*
*  CONSTANTS:
*
K0	DATA 0			CONSTANT 0
*				TABLE OF DIVISORS (FOR I FORMAT OUT)
	DATA 10000
	DATA 1000
	DATA 100
	DATA 10
	DATA 1
TENTBL	EQU  $
*
*  SCREEN MESSAGES:
*
BANNER	EQU $
	BYTE >0D,>0A,>0D,>0A
	TEXT 'Debugger MDOS '
	COPY "version.a99"
	BYTE >0D,>0A
	TEXT 'Copyright 1989 by LGMA Products'
	BYTE >0D,>0A
	BYTE >FF
*
PROMPT	EQU $
	TEXT ':'
KFF	BYTE >FF
*
INVINS	EQU  $
	TEXT 'Bad Instruction'
	BYTE >0D,>0A,>FF
*
INVNUM	EQU  $
	TEXT 'Bad Number'
	BYTE >0D,>0A,>FF
*
BUFFUL	EQU  $
	TEXT 'Too Many Breakpoints'
	BYTE >0D,>0A,>FF
*
BNOTFN	EQU  $
	TEXT 'Breakpoint Not Found'
	BYTE >0D,>0A,>FF
*
BALEXI	EQU  $
	TEXT 'Breakpoint Exists'
	BYTE >0D,>0A,>FF
*
SCRINB	EQU  $			SCREEN INPUT BUFFER
	BYTE 0,0,0,0,0,0,0,0,0,0
	BYTE 0,0,0,0,0,0,0,0,0,0
	BYTE 0,0,0,0,0,0
SIXBBE	BYTE 0,0,0,0,0,0
SIXBEN	EQU  $
CR	EQU  $			CARRIAGE RETURN & TERMINATOR
	BYTE >0D,>0A,>FF
*
HEXSTA	EQU  $
	BYTE 0,0,0,0
	TEXT '='
HEXSDD	EQU  $
	BYTE 0,0,0,0
	BYTE >20,>FF
*
*  WORKSPACE REGISTER DISPLAY
*
REGDIS	EQU  $			REGISTER DISPLAY
	TEXT ' R =    '
	BYTE >FF
*
*  REGISTER DISPLAY
*
WP	EQU  $
	TEXT 'WP = '
	BYTE >FF
PC	EQU  $
	TEXT 'PC = '
	BYTE >FF
ST	EQU  $
	TEXT 'SR = '
	BYTE >FF
*
*  BREAKPOINTS DISPLAY
*
BPEQAL	EQU  $
	TEXT 'BPS= '
	BYTE >FF
*
BPDISP	EQU  $
	BYTE >0D,>0A
	TEXT '!Break @'
BPDIS1	EQU  $
	BYTE 0,0,0,0
	TEXT ', WP='
BPDIS2	EQU  $
	BYTE 0,0,0,0
	TEXT ', SR='
BPDIS3	EQU  $
	BYTE 0,0,0,0
	BYTE >0D,>0A,>FF
*
*  HEX ARITHMETIC
*
HEXARI	EQU  $
	TEXT 'H1= '
AHEX1	EQU  $
	BYTE 0,0,0,0
	TEXT ' H2= '
AHEX2	EQU  $
	BYTE 0,0,0,0
	TEXT ' H1+H2= '
ASUM	EQU  $
	BYTE 0,0,0,0
	BYTE >0D,>0A
	TEXT 'H1-H2= '
ADIFF	EQU  $
	BYTE 0,0,0,0
	TEXT '  H1*H2= '
APROD1	EQU  $
	BYTE 0,0,0,0
	TEXT ' '
APROD2	EQU  $
	BYTE 0,0,0,0
	BYTE >0D,>0A
	TEXT 'H1/H2= '
AQUOT	EQU  $
	BYTE 0,0,0,0
	TEXT ' R '
AREMA	EQU  $
	BYTE 0,0,0,0
	BYTE >0D,>0A
	TEXT 'H1(I)= '
AINT1	EQU  $
	BYTE 0,0,0,0,0,0
	TEXT ' H2(I)= '
AINT2	EQU  $
	BYTE 0,0,0,0,0,0
	BYTE >0D,>0A,>FF
*
*  ASCII CHARACTER TABLE FOR RHEX
*
BLANK	TEXT '  '	 	2 BLANKS
HEXTBL	EQU  $
TERMIN	BYTE >FF
BLANKS	TEXT ' '
MINUS	TEXT '-'
	TEXT 'V'	 	 DISPLAY VDP RAM
	TEXT 'X'
	TEXT 'Y'
	TEXT 'Z'
	TEXT 'I'		  INTEGER VALUE
ASC0	TEXT '0'
	TEXT '9'
	TEXT 'A'
	TEXT 'F'
	EVEN
	TITL 'INITIAL ENTRY & MONITOR'
*
*  THIS MODULE CONTAINS THE INITIAL ENTRY FOR THE DEBUGGER (FROM MENU),
*  AND THE MONITOR.
*
ENTRY	EQU  $
*
*  Set up my registers as if I was called from the initial entry
*  point of the user task (location >1000).
*
	MOV  R11,@FSTART	; SAVE RETURN
	LWPI MREGS		; GET MY REGISTERS
	STST R15	   	; SR
	LI   R13,FREGS		; FORTRAN's Registers (user task)
	MOV  @FSTART,R14	; FORTRAN's Entry
*				SAVE DATA AREA I AM GOING TO USE
	LI   R11,IOBUF		SAVE START
	NEG  R11
	AI   R11,SAVEND		TOTAL BYTES TO MOVE (END-START)
	LI   R9,IOBUF		MOVE FROM ADDRESS
	LI   R10,SAVARE		MOVE TO ADDRESS
SAVGP0	EQU  $
	MOVB *R9+,*R10+
	DEC  R11
	JNE  SAVGP0		DO UNTIL ALL MOVED
*
	LI   R0,BPBUFF		CLEAR BREAKPOINT BUFFER AND
	LI   R1,TOCLEA		OTHER ASSORTED FLAGS
BPCLER	EQU $
	CLR  *R0+	 	CLEAR A CELL
	DECT R1
	JNE  BPCLER		BRIF MORE
*
	LI   R5,MREGS		SET XOP VECTOR IN LOW RAM
	MOV  R5,@XOPLOC
*
	LI   R5,INITBX		ENTRY POINT FOR BREAKPOINTS
	MOV  R5,@XOPLOC+2
*
	LI   R4,BANNER		TELL USER I AM HERE
	BLWP @SCROUT
*
*  MONTOP - MONITOR OPERATION, READ A COMMAND FROM SCREEN.
*
MONTOP	EQU $
	LI   R4,PROMPT		PUT OUT : PROMPT
	BLWP @SCROUT
	LI   R3,30		READ COMMAND
	BL   @SETTER	 	SET TERMINATOR IN FIELD
	JEQ  MONTOP		BRIF NOTHING SPECIFIED
	LI   R5,TABLE1		SEARCH TABLE FOR COMMAND
CMDLOP	EQU $
	C    *R5,@K0	 	END OF TABLE?
	JEQ  CMDERR		BRIF YES, ERROR
	CB   *R5,*R8	 	IS THIS THE COMMAND
	JEQ  CMDJMP		BRIF YES
	AI   R5,4	 	ELSE, SKIP TO NEXT
	JMP  CMDLOP
CMDJMP	EQU  $			COMMAND RECOGNIZED, JUMP TO COMMAND
	INC  R8	   		INC TO NEXT BUFFER CHAR
	INC  R5	   		INC TO # ENTRIES, THIS COMMAND
	CLR  R9
	MOVB *R5+,R9	 	GET # HEX ENTRIES
	SWPB R9
	LI   R6,HEXDIG		STORE IN HEXDIG ARRAY
	CLR  @VDPFLG	 	CLEAR VDP SPECIFIED FLAG
RHEXLO	EQU  $
	MOV  R9,R9		DONE?
	JEQ  RHEXDO		BRIF YES
	BL   @RHEX		READ A HEX NUMBER
	JMP  NERROR		ERROR RETURN
	SETO R1	   		NULL RETURN
	MOV  R0,*R6+	 	SAVE HEX NUMBER IN R4, R5 OR R6
	DEC  R9
	JMP  RHEXLO
RHEXDO	EQU  $
	MOV  *R5,R5		GO DO PROCESS
	B    *R5
CMDERR	EQU  $		UNRECOGNIZED COMMAND
	LI   R4,INVINS
	JMP  NERRO1
NERROR	EQU  $		NUMBER ERROR (UNRECOGNIZED NUMBER)
	LI   R4,INVNUM
NERRO1	EQU  $
	BLWP @SCROUT
	JMP  MONTOP
*
*  Q - QUIT
*
Q	EQU  $
	LI   R11,IOBUF		SAVE START
	NEG  R11
	AI   R11,SAVEND
	LI   R9,SAVARE		MOVE FROM ADDRESS
	LI   R10,IOBUF		MOVE TO ADDRESS
RESGP1	EQU  $
	MOVB *R9+,*R10+
	DEC  R11
	JNE  RESGP1
	RTWP			RETURN TO USER
*
*  M - MEMORY INSPECT/ALTER
*
M	EQU  $
	LI   R6,HEXDIG
	MOV  *R6+,R7	 	GET STARTING ADDRESS
	ANDI R7,>FFFE		MAKE EVEN
	MOV  *R6,R6		GET STOP ADDRESS
	JEQ  MALTER		BRIF NOT SPECIFIED, ALTER MODE
MDISPL	EQU  $
	LI   R8,6	 	3 WORDS PER LINE
	MOV  R7,R0		START ADDRESS
	LI   R1,HEXSTA		START HEX DISPLAY
	BL   @OHEX		OUTPUT HEX VALUE
	LI   R4,HEXSDD		TO MOVE TO
	MOV  @VDPFLG,R5   	VDP DISPLAY ?
	JNE  MDISPV		BRIF NO, DISPLAY CPU
	MOVB @BLANKS,*R4+ 	SET BLANKS IN BUFFER
MDISPV	EQU  $
	MOVB @TERMIN,*R4  	SET TERMINATOR IN BUFFER
	LI   R4,HEXSTA		SEND TO SCREEN
	BLWP @SCROUT
	JNE  MEXIT		BRIF BREAK REQUESTED
MLOOP2	EQU  $
	BL   @GETFR		GET VALUE AT START ADDRESS
	LI   R1,HEXSDD		FOR DISPLAY
	MOV  @VDPFLG,R5   	VDP DISPLAY?
	JEQ  MLOOP3
	BL   @OHEX2		PUT 2 HEX DIGITS IN BUFFER
	LI   R5,>20FF		& BLANK & TERMINATOR
	MOVB R5,*R1+
	SWPB R5
	MOVB R5,*R1
	INC  R7	   		INCR TO NEXT ADDRESS
	DEC  R8
	JMP  MLOOP4
MLOOP3	EQU  $			CPU RAM DISPLAY
	BL   @OHEX		IN OUTPUT BUFFER
	INCT R7
	DECT R8
MLOOP4	EQU  $
	LI   R4,HEXSDD
	BLWP @SCROUT	 	SEND TO SCREEN
	JNE  MEXIT		BRIF BREAK REQUESTED
MSKIP2	EQU  $
	MOV  R8,R8		DONE WITH COUNT?
	JNE  MLOOP2		BRIF NO
	LI   R8,-6		BACK UP TO START
	A    R8,R7		BACK UP TO START
MSKIP3	EQU $
	BL   @GETFR		GET DATA
	INC  R7	   		INCR START ADDRESS
	ANDI R0,>7F00		STRIP OFF MSB
	CI   R0,>2000		IS IT A CONTROL CHARACTER?
	JHE  MSKIP5		BRIF NO
MSKIP4	EQU $
	LI   R0,>2A00		CHANGE TO AN '*'
MSKIP5	EQU $
	CI   R0,>7F00		DON'T ALLOW >7F
	JEQ  MSKIP4
	MOVB R0,@SIXBEN(R8)
	INC  R8
	JNE  MSKIP3		BRIF MORE DIGITS
	LI   R4,SIXBBE		OUTPUT SIX ASCII CHARACTERS
	BLWP @SCROUT
	JNE  MEXIT		BRIF BREAK REQUESTED
	C    R7,R6		DONE ?
	JLE  MDISPL		BRIF NO
MEXIT	B     @MONTOP	 	WHEN DONE, JUST RETURN
*
MALTER	EQU $
	MOV  R7,R0		START ADDRESS
	LI   R1,HEXSTA		START HEX DISPLAY
	BL   @OHEX		OUTPUT HEX VALUE
	BL   @GETFR		GET VALUE AT SPECIFIED LOCATION (INTO R0)
	LI   R1,HEXSDD
	MOV  @VDPFLG,R5   	VDP OR CPU?
	JEQ  MALTCP		BRIF CPU
	BL   @OHEX2		ELSE, 2 HEX DUMP
	LI   R5,>20FF
	MOVB R5,*R1+	 	& SET TERMINATOR AS LAST CHAR
	SWPB R5
	MOVB R5,*R1
	JMP  MALTCO
MALTCP	EQU $
	BL   @OHEX		PUT HEX NUMBER IN OUTPUT BUFFER
MALTCO	EQU $
	LI   R4,HEXSTA		SEND TO SCREEN
	BLWP @SCROUT
	JNE  MEXIT		BRIF BREAK REQUESTED
	LI   R3,4	 	MAXIMUM # OF BYTES
	BL   @SETTER	 	SET BUFFER TERMINATOR
	JEQ  MALTIN		BRIF NOTHING SPECIFIED
	BL   @RHEX		READ A HEX DIGIT
	JMP  MEXIT		ERROR RETURN
	JMP  MALTIN		INCREMENT & RETURN
	BL   @PUTFR		PUT VALUE INTO REGISTER
	JMP  MALTER		AND TRY NEXT
MALTIN	EQU $
	MOV  @VDPFLG,R5   	WAS THIS A VDP ACCESS
	JEQ  TWOINC		BRIF NO, INCR BY 2
	INC  R7
	JMP  MALTER
TWOINC	EQU $
	INCT R7
	JMP  MALTER
*
*  GETFR - GET A WORD INTO R0 FROM STARTA (R7), HONORING THE VDP FLAG,
*	   and CHECKING THE SAVE AREA to see if here.
*
GETFR	EQU  $
	ABS  @VDPFLG		FROM VDP MEMORY?
	JNE  GETFR1		BRIF YES
	CI   R7,SAVEND		IS THE MEMORY AREA NEEDED IN SAVE AREA?
	JHE  NOTGFS		BRIF NO
	CI   R7,IOBUF
	JL   NOTGFS
	LI   R12,IOBUF		GET DATA FROM SAVE AREA
	NEG  R12
	A    R7,R12		DETERMINE OFFSET INTO SAVE AREA
	AI   R12,SAVARE		 + SAVE AREA LOCAL START
	MOVB *R12+,R0
	SWPB R0
	MOVB *R12,R0
	SWPB R0
	B    *R11
NOTGFS  EQU  $			GET DATA FROM REAL MEMORY
	MOVB *R7+,R0	 	MOVE TWO BYTES IN R0
	SWPB R0
	MOVB *R7,R0
	DEC  R7
	SWPB R0
	B    *R11	 	AND RETURN
GETFR1	EQU $
	MOV  R7,R0		GET FROM VDP MEMORY
	BLWP @VSBR		WITH TWO READS
	SWPB R1
	INC  R0
	BLWP @VSBR
	SWPB R1
	MOV  R1,R0		RETURN REQUESTED WORD
	B    *R11
*
*  PUTFR - PUT A VALUE FROM R1 INTO STARTA(R7), HONORING THE VDP FLAG
*
PUTFR	EQU  $
	ABS  @VDPFLG		TO VDP RAM?
	JNE  PUTFR1		BRIF YES
	CI   R7,SAVEND		IS IT IN SAVE AREA?
	JHE  PUTFR0		BRIF NO
	CI   R7,IOBUF
	JL   PUTFR0
	LI   R12,IOBUF
	NEG  R12
	A    R7,R12		OFFSET INTO SAVE AREA
	AI   R12,SAVARE		 + AREA START LOCAL
	MOV  R0,*R12
	INCT R7
	B    *R11
PUTFR0	EQU  $			PUT INTO REAL MEMORY
	MOV  R0,*R7+
	B    *R11
PUTFR1	EQU $
	MOV  R0,R1		WRITE A SINGLE BYTE INTO OUTPUT
	SWPB R1
	MOV  R7,R0
	BLWP @VSBW		WRITE IT
	INC  R7	   		INCREMENT TO NEXT ADDRESS
	B    *R11
*
*  SETTER - SET TERMINATOR (>FF) IN INPUT BUFFER
*
SETTER	EQU $
	LI   R4,SCRINB		MY INPUT BUFFER
	BLWP @SCRIN		GET INPUT
	JNE  SETCRR		BRIF REDO OR BACK
	MOV  R4,R8		GET INPUT TERMINATOR
	CLR  R5
	MOVB *R8,R5		GET BYTE COUNT
	SWPB R5
	INC  R5
	A    R5,R4		SET END OF BUFFER ADDRESS
	LI   R5,>FF00
	MOVB R5,*R4		SET TERMINATOR IN BUFFER
	CLR  R5	   		LOAD BYTE COUNT AGAIN
	MOVB *R8+,R5	 	FOR COMPARE ON RETURN
	B    *R11
SETCRR	EQU $			REDO OR BACK, QUIT FUNCTION
	B    @MONTOP	 	& GO TO MONITOR
*
*  W - DISPLAY/ALTER WORKSPACE REGISTERS
*
W	EQU $
	CLR  @VDPFLG		NOT VDP MEMORY
	MOV  @HEXDIG,R6
	CI   R1,>FFFF		WAS THIS A NULL ENTRY
	JNE  WALTER		NO, ENTER ALTER MODE
	MOV  R13,R7		GET WORKSPACE POINTER START
WEGLO1	EQU $
	LI   R8,3	 	3 REGISTERS/LINE
WEGLO2	EQU $
	MOV  R6,R0		REGISTER NUMBER
	SRC  R0,4	 	IN TOP 4 BITS
	LI   R1,REGDIS+2  	PUT REGISTER # IN OUTPUT BUFFER
	BL   @OHEX1
	INC  R1
	BL   @GETFR		GET MEMORY LOCATION
	INCT R7
	BL   @OHEX		INTO BUFFER
	LI   R4,REGDIS
	BLWP @SCROUT		DISPLAY THE REGISTER
	JNE  WEXIT		BRIF BREAK REQUESTED
	INC  R6
	CI   R6,16		LAST REGISTER?
	JEQ  WEGOUT		BRIF YES
	DEC  R8
	JNE  WEGLO2		BRIF NOT A MULTIPLE OF 3
	LI   R4,CR		ELSE, ISSUE CR
	BLWP @SCROUT
	JNE  WEXIT
	JMP  WEGLO1		GO DO ANOTHER
WEGOUT	EQU $
	LI   R4,CR		SET CR ON LAST
	BLWP @SCROUT
WEXIT	EQU  $
	B    @MONTOP		RETURN TO MONITOR
*
WINCRE	EQU $
	INC  R6
WALTER	EQU $			REGISTER ALTER
	MOV  R6,R0		REGISTER # TO ALTER
	JLT  WEGOUT		BRIF REGISTER #<0
	CI   R6,15		MUST BE < 16
	JGT  WEGOUT		BRIF MORE
	SRC  R0,4		 REGISTER # IN TOP 4 BITS
	LI   R1,REGDIS+2
	BL   @OHEX1		REGISTER #
	MOV  R6,R7		DETERMINE START ADDRESS
	SLA  R7,1
	A    R13,R7		GOT IT
	BL   @GETFR
	INC  R1
	BL   @OHEX		OUTPUT NUMBER
	LI   R4,REGDIS		DISPLAY REGISTER # & VALUE
	BLWP @SCROUT
	JNE  WEXIT		BRIF BREAK REQUESTED
	LI   R3,4		GET HEX VALUE
	BL   @SETTER		INTO SCRINB
	JEQ  WINCRE
	BL   @RHEX		READ HEX DIGIT
	JMP  WEGOUT		BRIF ERROR
	JMP  WINCRE		NULL
	MOV  R0,R1
	BL   @PUTFR		OR SET REGISTER
	JMP  WINCRE
	TITL 'CONTINUE COMMAND HANDLERS'
*
*  R - REGISTER INSPECT/ALTER
*
R	EQU $
	LI   R6,MREGS+24	R13 START (WP)
	LI   R7,WP-6		WORKSPACE POINTER MESSAGE START
	LI   R8,3		3 REGISTERS TO INSPECT/ALTER
REGLOP	EQU $
	INCT R6
	CI   R6,MREGS+32	END OF REGISTERS?
	JEQ  REXIT		BRIF YES
	AI   R7,6		SKIP TO NEXT MESSAGE
	MOV  R7,R4		MOVE TO NEXT REGISTER
	BLWP @SCROUT		DISPLAY THE TYPE OF REGISTER
	JNE  REXIT		BRIF BREAK REQUESTED
	MOV  *R6,R0		DISPLAY THE VALUE OF THE REGISTER
	LI   R1,HEXSDD		SINGLE HEX DISPLAY
	BL   @OHEX		CONVERT AND MOVE IT
	LI   R4,HEXSDD
	BLWP @SCROUT		NOW DISPLAY IT
	JNE  REXIT		BRIF BREAK REQUESTED
	LI   R3,4		GET UP TO 4 HEX DIGITS
	BL   @SETTER		GO GET BUFFER
	JEQ  REGLOP
	BL   @RHEX		CONVERT THE HEX NUMBER
	JMP  REXIT		BRIF ERROR
	JMP  REGLOP		BRIF NULL (NOTHING HERE)
	MOV  R0,*R6
	JMP  REGLOP
*
*  H - HEX ARITHMETIC
*
H	EQU $
	LI   R7,HEXDIG		GET H1, H2
	MOV  *R7+,R6	 	H1
	MOV  *R7,R7		H2
	MOV  R6,R0
	LI   R1,AHEX1		PUT H1 IN BUFFER
	BL   @OHEX
	MOV  R7,R0
	LI   R1,AHEX2		PUT H2 IN BUFFER
	BL   @OHEX
	MOV  R6,R0
	A    R7,R0
	LI   R1,ASUM	 	PUT H1+H2 IN BUFFER
	BL   @OHEX
	MOV  R6,R0
	S    R7,R0
	LI   R1,ADIFF		PUT H1-H2 IN BUFFER
	BL   @OHEX
	MOV  R7,R0
	MPY  R6,R0
	MOV  R1,R5		SAVE 2ND WORD OF PRODUCT
	LI   R1,APROD1		PUT H1*H2 IN BUFFER
	BL   @OHEX
	MOV  R5,R0		OUTPUT 2ND WORD OF PRODUCT
	LI   R1,APROD2
	BL   @OHEX
	MOV  R6,R1
	CLR  R0
	DIV  R7,R0
	MOV  R1,R5		TEMP SAVE REMAINDER
	LI   R1,AQUOT		PUT H1/H2 IN BUFFER
	BL   @OHEX
	MOV  R5,R0
	LI   R1,AREMA		PUT MOD(H1,H2) IN BUFFER
	BL   @OHEX
	MOV  R6,R0		H1 IN INTEGER
	LI   R1,AINT1
	BL   @OINT
	MOV  R7,R0		H2 IN INTEGER
	LI   R1,AINT2
	BL   @OINT
	LI   R4,HEXARI		OUTPUT RESULT OF ARITHMETICS
	BLWP @SCROUT
REXIT	EQU  $
	B    @MONTOP	 	AND RETURN
*
*  B - BREAKPOINT INSPECT/ALTER
*
B	EQU  $
	MOV  @HEXDIG,R7   	SPECIFIED BREAKPOINT ADDRESS
B1	EQU  $
	LI   R6,BPBUFF		BREAKPOINT BUFFER
	ANDI R7,>FFFE		MAKE EVEN
	JEQ  NOADD		BRIF NOTHING SPECIFIED
	LI   R5,NOBPS
BUFSRC	EQU $
	C    R7,*R6+	 	IS THIS THE PACKET?
	JEQ  BUFFND		BRIF YES
	INCT R6			ELSE, SKIP TO NEXT PACKET
	DEC  R5
	JNE  BUFSRC
	CB   R1,@MINUS		WAS TERMINATION BY MINUS SIGN?
	JNE  BUFADD		BRIF NO, ADD BREAKPOINT
	LI   R4,BNOTFN		BREAKPOINT NOT FOUND
	JMP  BPERR1
BUFADD	EQU $			ADD A BREAKPOINT
	LI   R5,NOBPS
	LI   R6,BPBUFF		FIND A BLANK SLOT IN BREAKPOINT TABLE
BUFSR1	EQU $
	MOV  *R6,R1		IS THIS SLOT FREE?
	JEQ  BUFAD1		BRIF YES
	AI   R6,4
	DEC  R5	   		DO UNTIL FOUND OR PACKETS EXHAUSTED
	JNE  BUFSR1
	LI   R4,BUFFUL		TOO MANY BREAKPOINTS
	JMP  BPERR1
BUFAD1	EQU $			FREE PACKET FOUND
	MOV  R7,*R6+	 	SAVE ADDRESS IN BUFFER
	CI   R7,IOBUF		IS THE BP IN MEMORY OF MY I/O BUFFER?
	JL   BUFAD2		BRIF NO
	AI   R7,-IOBUF		GET RELATIVE OFFSET
	AI   R7,SAVARE		 + SAVE AREA START
BUFAD2	EQU  $
	MOV  *R7,*R6		SAVE CONTENTS OF ADDRESS OF BUFFER
	MOV  @XOPINS,*R7	SET BREAKPOINT
	JMP  BRETUR
*
BUFFND	EQU $
	CB   R1,@MINUS		WAS BREAKPOINT TO BE REMOVED?
	JNE  BUFALE		BRIF NO, ADD A BREAKPOINT WHICH ALREADY EXISTS
	DECT R6
	CLR  *R6+
	CI   R7,IOBUF		IS BREAKPOINT IN SAVE AREA?
	JL   BUFAD3		BRIF NO
	AI   R7,-IOBUF
	AI   R7,SAVARE
BUFAD3	EQU  $
	MOV  *R6,*R7		REMOVE BREAKPOINT
BRETUR	EQU $
	B    @MONTOP
BUFALE	EQU $
	LI   R4,BALEXI		BREAKPOINT ALREADY EXISTS
BPERR1	EQU $
	BLWP @SCROUT
	JMP  BRETUR
*
NOADD	EQU  $			NOT AN ADD
	CB   R1,@MINUS		MINUS SIGN TERMINATION?
	JEQ  BPREMO		YES, REMOVE ALL BREAKPOINTS
BPLIST	EQU $			ELSE, BREAK POINT LIST
	LI   R4,BPEQAL
	BLWP @SCROUT
	LI   R5,NOBPS
	LI   R7,BPBUFF
BPLOOP	EQU $
	MOV  *R7,R0		ANY BREAKPOINT HERE?
	JNE  BPFOND		BRIF YES
BPOUTL	EQU $
	AI   R7,4
	DEC  R5
	JNE  BPLOOP		BRIF MORE TO SEARCH
	LI   R4,CR
	BLWP @SCROUT
	B    @MONTOP
BPFOND	EQU $
	LI   R1,HEXSDD		DISPLAY BREAKPOINT ADDRESS
	BL   @OHEX
	LI   R4,HEXSDD
	BLWP @SCROUT
	JMP  BPOUTL
*
BPREMO	EQU $			REMOVE ALL BREAKPOINTS
	LI   R5,BPBUFF		BREAKPOINT BUFFER START
	LI   R6,NOBPS		NUMBER OF BREAKPOINTS
BPRLOP	EQU $
	MOV  *R5,R4		GET BREAKPOINT, THIS LOCATION
	JNE  BPRLO2		BRIF SOMETHING HERE
	AI   R5,4
BPRLO1	EQU $
	DEC  R6
	JNE  BPRLOP		BRIF MORE BREAKPOINTS
	B    @MONTOP
BPRLO2	EQU $
	CLR  *R5+	 	CLEAR THE LOCATION
	CI   R4,IOBUF		IS ADDRESS IN MY SAVE AREA?
	JL   BPRLO3		BRIF NO
	AI   R4,-IOBUF		ELSE, DETERMINE OFFSET INTO SAVE AREA
	AI   R4,SAVARE
BPRLO3	EQU  $
	MOV  *R5+,*R4		RESTORE CODE AT ADDRESS
	JMP  BPRLO1
*
*  BREAKPOINT ENTRIES:
*
*  INITBX  -  SINGLE WORD (XOP 7) ENTRY
*
INITBX	EQU $
	LI   R11,IOBUF		SAVE START
	NEG  R11
	AI   R11,SAVEND		TOTAL BYTES TO MOVE (END-START)
	LI   R12,IOBUF		MOVE FROM ADDRESS
	LI   R10,SAVARE		MOVE TO ADDRESS
SAVGP1	EQU  $
	MOVB *R12+,*R10+
	DEC  R11
	JNE  SAVGP1		DO UNTIL ALL MOVED
*
	DECT 14
	MOV  R14,R0		DISPLAY BREAKPOINT
	LI   R1,BPDIS1
	BL   @OHEX
	MOV  R13,R0		WORKSPACE POINTER
	LI   R1,BPDIS2
	BL   @OHEX
	MOV  R15,R0		STATUS REGISTER
	LI   R1,BPDIS3
	BL   @OHEX
	LI   R4,BPDISP
	BLWP @SCROUT	 	DISPLAY BREAKPOINT MESSAGE
	MOVB @MINUS,R1		PRETEND THAT THIS IS A B - COMMAND
	MOV  R14,R7		BREAK POINT ADDRESS TO REMOVE
	B    @B1	  	AND DO REMOVE LOGIC
*
*  X, Y, AND Z BIAS
*
X	EQU  $
	MOV  @HEXDIG,@XBIAS	SAVE X BIAS
	JMP  BBIAS
*
Y	EQU  $
	MOV  @HEXDIG,@YBIAS	SAVE Y BIAS
	JMP  BBIAS
*
Z	EQU  $
	MOV  @HEXDIG,@ZBIAS	SAVE Z BIAS
BBIAS	EQU  $
	B    @MONTOP
*
	TITL 'DEBUGGER SUBROUTINES'
*
*  THIS MODULE CONTAINS THE FOLLOWING SUBROUTINES:
*
*	RHEX   - READ HEX/INTEGER NUMBERS
*	OHEX   - OUTPUT 4 HEX DIGITS
*	OHEX1  - OUTPUT 1 HEX DIGIT
*	OHEX2  - OUTPUT 2 HEX DIGITS
*	OINT   - OUTPUT INTEGER NUMBER (SIGNED)
*
*	
*  RHEX - HEX INPUT
*
*  THIS ROUTINE SCANS THE NEXT (UP TO 4) DIGITS IN THE INPUT BUFFER
*  AND RETURNS THE HEXADECIMAL VALUE IN THE USER R0.  THE TERMINATION
*  CHARACTER IS RETURNED IN THE MSB OF R1.  THE LSB OF R1 IS CLEARED.
*
*  THERE ARE 2 RETURN SPOTS FOR THIS ROUTINE:
*
*	 BLWP @RHEX
*	 JMP  ERRORE	ERROR RETURN
*	 JMP  NULLRT	NULL RETURN
*	 JMP  NORMAL	NORMAL RETURN
*
*  NOTE:  ON ENTRY, R8 POINTS TO INPUT BUFFER
*
RHEX	EQU  $
	CLR  R0	   		CLEAR HEX VALUE
	CLR  @BIAS		CLEAR ANY BIAS
	LI   R4,16		ASSUME HEX MULTIPLY
RHEX1	EQU  $
	CB   *R8,@HEXTBL  	TERMINATOR CHAR?
	JEQ  NULLRT
	CB   *R8,@HEXTBL+1 	SPACE CHARACTER
	JNE  RHEX2		BRIF NO
	INC  R8
	JMP  RHEX1		TRY ANOTHER CHARACTER
*
RHEX2	EQU  $
	CLR  R1
	MOVB *R8,R1		GET CHAR, THIS LOCATION
	LI   R3,HEXTBL
	CB   *R8,*R3+		IS IT A TERMINATOR?
	JEQ  NORMRT		BRIF YES, NORMAL RETURN
	INC  R8
	CB   R1,*R3+	 	IS IT A SPACE?
	JEQ  NORMRT
	CB   R1,*R3+	 	IS IT A MINUS SIGN?
	JEQ  NORMRT		BRIF YES, TERMINATOR
	CB   R1,*R3+		IS IT VDP FLAG?
	JEQ  SETVDP		BRIF YES, SET VDP MEMORY
	CB   R1,*R3+		IS IT X BIAS?
	JEQ  SETXBI		BRIF YES
	CB   R1,*R3+		IS IT Y BIAS?
	JEQ  SETYBI		BRIF YES
	CB   R1,*R3+		IS IT Z BIAS?
	JNE  CHECKI		BRIF NO, GO CHECK INTEGER
*
SETZBI	EQU  $
	MOV  @ZBIAS,@BIAS	SET Z BIAS
	JMP  RHEX2		GO READ ANOTHER CHAR
*
SETXBI	EQU  $
	MOV  @XBIAS,@BIAS	SET X BIAS
	JMP  RHEX2
*
SETYBI	EQU  $
	MOV  @YBIAS,@BIAS	SET Y BIAS
	JMP  RHEX2
*
SETVDP	EQU  $
	SETO @VDPFLG		ELSE, SET VDP MEMORY FLAG
	JMP  RHEX2		GO READ ANOTHER CHAR
*
CHECKI	EQU $
	CB   R1,*R3+	 	IS IT AN 'I' (FOR INTEGER)
	JNE  CHECKD
	LI   R4,10		CHANGE MULTIPLIER TO INTEGER
	MOV  R0,R0		HAS A NUMBER ALREADY BEEN SPECIFIED?
	JNE  ERRORT		BRIF YES, ERROR
	JMP  RHEX2
CHECKD	EQU $
	CB   R1,*R3+	 	LESS THAN ZERO?
	JLT  ERRORT		BRIF YES
	CB   R1,*R3+		LESS THAN OR = TO 9?
	JGT  CHECKN
	SWPB R1
	AI   R1,->30	 	ADD ZERO OFFSET
	JMP  STORHE
CHECKN	EQU $
	CI   R4,10		DOING INTEGER STUFF?
	JEQ  ERRORT		BRIF YES, ERROR
	CB   R1,*R3+	 	LESS THAN 'A'
	JLT  ERRORT		BRIF ERROR
	CB   R1,*R3+
	JGT  ERRORT		BRIF ERROR
	SWPB R1
	AI   R1,-55		ADD ZERO OFFSET
STORHE	EQU $
	MOV  R1,R3		TEMP SAVE
	MPY  R4,R0		PERFORM 16 OR 10 MULTIPLY
	MOV  R1,R0
	A    R3,R0		ADD IN NEW DIGITS
	JMP  RHEX2
*
NORMRT	EQU  $			NORMAL RETURN
	A    @BIAS,R0		ADD IN ANY BIAS DETECTED
	INCT R11	   	RETURN + 4
*
NULLRT	EQU  $
	INCT R11	   	RETURN + 2
*
ERRORT	EQU  $
	B    *R11	  	RETURN + 0
*
*  OHEX  - OUTPUT 4 HEX DIGITS (IN R0) TO BUFFER
*  OHEX1 - OUTPUT 1 HEX DIGIT  (IN R0) TO BUFFER
*  OHEX2 - OUTPUT 2 HEX DIGITS (IN R0) TO BUFFER
*
OHEX	EQU  $
	LI   R2,4	 	4 DIGITS TO DISPLAY
	JMP  OHEXCO
OHEX2	EQU  $
	LI   R2,2	 	2 DIGITS TO DISPLAY
	JMP  OHEXCO
OHEX1	EQU  $
	LI   R2,1	 	1 DIGIT
OHEXCO	EQU $
	MOV  R0,R3		SAVE CHARACTERS
	SRC  R0,16-4	 	LEFT 4
	ANDI R3,>F000		MASK OFF DIGIT
	SRC  R3,4	 	IN LOW PORTION OF BYTE
	CI   R3,>0900		IS IT >10?
	JGT  ITSLET		BRIF YES, LETTER
	AI   R3,>3000		ELSE, ADD ZERO IN ASCII
	JMP  OHEXMO		AND MOVE IT
ITSLET	EQU $
	AI   R3,>4100->0A00
OHEXMO	EQU $
	MOVB R3,*R1+	 	SAVE IN BUFFER
	DEC  R2	   		ANY MORE?
	JNE  OHEXCO		BRIF YES
	B    *R11	 	ELSE, RETURN
*
*  OINT - OUTPUT INTEGER IN 6 BYTE FIELD (SIGNED)
*
*	 R0 CONTAINS VALUE
*	 R1 CONTAINS OUTPUT BUFFER ADDRESS
*
OINT	EQU  $
	LI   R2,-6		FIRST, CLEAR FIELD
	MOV  R1,R3
OINT1	EQU  $
	MOVB @BLANKS,*R3+
	INC  R2
	JNE  OINT1
*
	MOV  R1,R2		MOVE FOR DIVIDE
	CLR  R3	   		RESET SIGN FLAG
	CLR  R5	   		RESET ZERO FILL FLAG
	MOV  R0,R0
	JEQ  SETZER		BRIF 0, JUST PUT ZERO IN OUTPUT BUFFER
	JLT  CHGSIG		BRIF <0, CHANGE SIGN
	INC  R2	   		ELSE, SKIP PAST SIGN
	JMP  SIGNOK
CHGSIG	EQU $
	NEG  R0	   		ELSE, NEGATE VALUE
	SETO R3	   		AND SET SIGN FLAG
SIGNOK	EQU $
	LI   R4,-10		INDEX INTO TENTBL
	MOV  R0,R1
OINT2	EQU  $
	CLR  R0
	DIV  @TENTBL(R4),R0
	MOV  R0,R0		ZERO QUOTIENT?
	JEQ  ISZERO		YES
	INC  R5	   		DON'T ZERO FILL ANY MORE DIGITS
ISZERO	EQU $
	MOV  R5,R5		ZERO FILLING?
	JNE  OINT3		BRIF NOT ZERO, STORE DIGIT
	INC  R2	   		ELSE, JUST INCR DIGIT
	JMP  OINT5		& INCREMENT COUNT
OINT3	EQU  $
	MOV  R3,R3		CHECK SIGN FLAG
	JEQ  OINT4		BRIF 0
	MOVB @MINUS,*R2+
	CLR  R3
OINT4	EQU  $
	SWPB R0	   		STORE DIGIT IN OUTPUT BUFFER
	AB   @ASC0,R0
	MOVB R0,*R2+
OINT5	EQU  $
	INCT R4	   		INCR TEN TABLE ADDRESS
	JNE  OINT2
	B    *R11	 	DONE
*
SETZER	EQU $
	AI   R1,5	 	PUT ZERO IN OUTPUT BUFFER
	MOVB @ASC0,*R1
	B    *R11
*
*  A set of utilities under MDOS which operate the same as the utilities
*  under TI-99/4A
*
*  Equates
*
IOBUF	EQU  >EF80		I/O BUFFER START
*
SCROUT	EQU  $
	DATA WREGS		MY REGISTERS
	DATA ESCROU
*
SCRIN	EQU  $
	DATA WREGS		MY REGISTERS
	DATA ESCRIN
*
VSBR	EQU  $			VDP SINGLE BYTE READ
	DATA WREGS
	DATA EVSBR
*
VSBW	EQU  $			VDP SINGLE BYTE WRITE
	DATA WREGS
	DATA EVSBW
*
*  SCROUT - Screen Output.  Write to the screen.  Terminator is an 'FF'
*
ESCROU	EQU  $
	MOV  @8(R13),R4		GET USER R4
	LI   R5,IOBUF
MOVLOP  EQU  $
        CB   *R4,@KFF		IS THIS THE TERMINATOR?
	JEQ  MOVEND
	MOVB *R4+,*R5+		MOVE A BYTE
	JNE  MOVLOP
MOVEND	EQU  $
	CLR  R6
	MOVB R6,*R5+		MAKE SURE ITS TERMINATED WITH A ZERO
	LI   R0,WRITET		WRITETTY
	LI   R1,IOBUF		WRITE ADDRESS BUFFER
	CLR  R2			WRITE UNTIL 0
	XOP  @DVIDXP,0		DO IT
KEYIN1	EQU  $
	LI   R0,0		KEYBOARD MODE
	XOP  @DKEYXP,0		GET A KEY
	JNE  KEYEND		BRIF NO KEY DEPRESSED
	CB   R1,@KFF		WAS IT A CTL/C (BREAK)?
	JNE  KEYIN2		BRIF NO
	SETO R1
	JMP  KEYEN1		YES, INFORM CALLER BREAK REQUESTED
KEYIN2	EQU  $
	LI   R0,0		WAIT FOR KEY REMOVAL
	XOP  @DKEYXP,0
	JEQ  KEYIN2		BRIF A KEY IS STILL DEPRESSED
KEYIN3	EQU  $
	LI   R0,0		FINALLY, WAIT FOR SECOND KEY DEPRESS
	XOP  @DKEYXP,0
	JNE  KEYIN3		WAIT UNTIL SOMETHING PRESSED	
KEYEND  EQU  $
	CLR  R1			NO BREAK REQUESTED
KEYEN1	EQU  $
	MOV  R1,R1
	STST R15
	RTWP			RETURN
*
*  SCRIN - SCREEN INPUT
*
*  THIS ROUTINE RECIEVES A MAXIMUM BYTE COUNT IN R3, AND A BUFFER
*  ADDRESS IN R4.  IT READS THE NEXT N BYTES OF CHARACTERS FROM THE
*  INPUT, WHERE N IS DETERMINED BY THE MAXIMUM BYTE COUNT, OR MAY
*  BE TERMINATED BY A CARRAIGE RETURN.
*
*  THE BUFFER RETURN HAS THE BYTE COUNT OF THE ACTUAL NUMBER OF
*  CHARACTERS READ EMBEDDED IN THE FIRST BYTE, FOLLOWED BY THE
*  ACTUAL NUMBER OF BYTES.
*
*  THIS ROUTINE RECOGNIZES CONTROL/C (TERMINATE TO MDOS), CONTROL/H
*  (BACKSPACE).   RIGHT NOW ALWAYS RETURNS A GOOD (NON-FNCTN/BACK)
*  STATUS.
*
ESCRIN	EQU  $
	CLR  R6			CLEAR REDO OR BACK CHECK
	MOV  @8(R13),R4		GET I/O BUFFER ADDRESS
	INC  R4			INCR I/O BUFFER ADDRESS	
	CLR  R3
KEYIN	EQU  $			KEYBOARD INPUT ROUTINE
	C    @6(R13),R3		READ MAXIMUM BYTES?
	JEQ  KEYDON		BRIF YES
	BL   @MOVESR		MOVE STRING
	DATA CURSOR
	LI   R0,0		KEYBOARD MODE
	XOP  @DKEYXP,0		GET A KEY
	JNE  KEYIN		BRIF NO KEY DEPRESSED
	CB   R1,@KFF		NO KEY?
	JEQ  KEYIN
	ANDI R1,>7F00
	CI   R1,>0300
*			     CONTROL C:
	JNE  NOCTLC       	IF ^C NOT PRESSED
	BLWP @0           	ABORT
NOCTLC	EQU  $
	CI   R1,>0D00		WAS THIS ENTER?
	JEQ  KEYDON		BRIF YES, DONE
	CI   R1,>0800		WAS THIS A BACKSPACE?
	JNE  NOCTL8		BRIF NO
*			     BACKSPACE:
	MOV  R3,R3		ANY CHARACTERS IN BUFFER
	JEQ  KEYIN		BRIF NO, IGNORE
	DEC  R3			REMOVE DISCARDED CHARACTER
	DEC  R4			FROM I/O BUFFER TOO!
	BL   @MOVESR		BLANK THIS AND LAST CHARACTERS
	DATA BLANKI
	JMP  KEYIN
*                            STANDARD CHARACTER:
NOCTL8	EQU  $
	CI   R1,>2000		MAKE SURE A PRINTABLE
	JLT  KEYIN		BRIF NOT, JUST SKIP IT
	MOVB R1,*R4+
	MOVB R1,@IOBUF		PUT IN I/O BUFFER
	LI   R0,WRITET		WRITE IT TO SCREEN
	LI   R1,IOBUF
	LI   R2,1		1 CHARACTER
	XOP  @DVIDXP,0		DISPLAY IT
	INC  R3			BUMP # CHARACTERS READ
	JMP  KEYIN
*
KEYDON	EQU  $			DONE INPUT (EITHER RAN OUT OF BYTES, OR ENTER)
	MOV  @8(R13),R4		GET USER I/O BUFFER ADDRESS AGAIN
	SWPB R3
	MOVB R3,*R4		SAVE IT
	BL   @MOVESR		WRITE CARRAIGE RETURN/LINE FEED PAIR
	DATA CRLFP
	MOV  R6,R6		REDO OR BACK (CTL/X)
	STST R15
	RTWP			RETURN
*
*  MOVESR - MOVE THE GIVEN STRING TO THE I/O BUFFER, AND WRITE IT TO
*	    THE SCREEN.
*
MOVESR	EQU  $
	MOV  *R11+,R0		INPUT STRING ADDRESS
	LI   R1,IOBUF		OUTPUT STRING ADDRESS
*
MOVELP	EQU  $
	MOVB *R0+,*R1+		MOVE A BYTE
	JNE  MOVELP
*
	LI   R0,WRITET		WRITE TTY
	LI   R1,IOBUF
	CLR  R2
	XOP  @DVIDXP,0		WRITE TO SCREEN
	B    *R11		RETURN
*
*  VSBR - VDP SINGLE BYTE READ
*  VSBW	- VDP SINGLE BYTE WRITE
*
EVSBR	EQU  $
	CLR  R1
	BL   @VSETUC		SETUP FOR READ/WRITE
	MOVB @VDPOR0,@2(R13)	GET VDP MEMORY BYTE
	JMP  VCOMRT
*
EVSBW	EQU  $
	LI   R1,>4000		WRITE BIT
	BL   @VSETUC
	MOVB @2(R13),@VDPOR0	SET VDP MEMORY BYTE
VCOMRT	EQU  $
	LIMI 2
	RTWP			RETURN
*
VSETUC	EQU  $
	LIMI 0
	MOV  *R13,R2		GET USER R0
	SRA  R2,6		GET BANK CODE NUMBER
	ANDI R2,>0300
	MOVB R2,@VDPOR1		SELECT BANK TO ACCESS
	LI   R2,REG14C		REGISTER 14 SELECT BITS
	MOVB R2,@VDPOR1
*
	MOV  *R13,R2		GET USER R0 (AGAIN)
	SWPB R2
	MOVB R2,@VDPOR1		PUT R2.L IN
	SWPB R2
	ANDI R2,>3F00
	SOC  R1,R2
	MOVB R2,@VDPOR1		PUT R2.H IN
	B    *R11
*
BLANKI	EQU  $
	BYTE >08,>20,>20,>08,>08,>00
CRLFP	EQU  $
	BYTE >20,>0D,>0A,>00
CURSOR	EQU  $
	BYTE >5F,>08,>00
	EVEN
DEBUE	EQU  $
	END
