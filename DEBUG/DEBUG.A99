	TITL 'NON-SYMBOLIC DEBUGGER'
	IDT 'DEBUG'
*
*  TI-99 GPL MODE:
*
*  THIS PROGRAM IS THE DEBUGGER FOR THE FORTRAN SYSTEM.
*
*  Update History:
*
*    3-Mar-1989    Version 4.3     GPL Version
*    15-APR=1989                   Fixed amount saved in VDP ram
*
	DEF  DEBUG
	DEF  DEBUE
*
GENEVE	EQU  0			TI-99 GPL ONLY
*
	RORG 0
DEBUG	EQU  $
	SETO @INITFL		SAY I ENTERED VIA INITIAL
	B    @ENTRY
	TITL 'DEBUGGER DATA AREA'
*
*  MENU EQUATES:
*
	UNL
	COPY "equates:fortex.eq9"
	LIST
*
*  RAM PAD EQUATES:
*
FREGS	EQU  WSP		FORTRAN'S WORKSPACE START
*
*  RUNTIME EQUATES:
*
CRTOP	EQU  6			CRT OP LABEL
*
*  OTHER MISC. EQUATES:
*
XOPVEC	EQU  >0044		XOP'S ALLOWED OR NOT
RAMEND	EQU  >FFF8		VECTOR START IN CPU RAM
NOBPS	EQU  5			NUMBER OF BREAKPOINTS, MAX
NOBPSL	EQU  5			NUMBER OF BPS PER LISTED LINE
MREGS	EQU  >FFD8		MY REGISTERS START
*MREGS  BSS  32
IOTAMO	EQU  >0402		AMOUNT OF VDP RAM USED BY I/O PACKAGE
VDPLO	EQU  >1000		VDP LOW ADDRESS START
*
*  TABLE OF COMMANDS
*
TABLE1	EQU $
	TEXT 'M'	  	MEMORY INSPECT/MODIFY
	BYTE 2
	DATA M
*
	TEXT 'W'	  	WORKSPACE INSPECT/MODIFY
	BYTE 1
	DATA W
*
	TEXT 'B'	  	BREAKPOINTS
	BYTE 1
	DATA B
*
	TEXT 'H'	  	HEX ARITHMETIC
	BYTE 2
	DATA H
*
	TEXT 'R'	  	REGISTER INSPECT/ALTER
	BYTE 0
	DATA R
*
	TEXT 'X'		 X-BIAS
	BYTE 1
	DATA X
*
	TEXT 'Y'		 Y-BIAS
	BYTE 1
	DATA Y
*
	TEXT 'Z'		 Z-BIAS
	BYTE 1
	DATA Z
*
	TEXT 'Q'	  	QUIT
	BYTE 0
	DATA Q
*
	TEXT 'T'	  	TRADE SCREEN
	BYTE 0
	DATA T
	DATA 0
*
*  BLWP VECTORS
*
BPINST	EQU  $			2 WORD BREAKPOINTS
	BLWP @B2WORD		DATA TO BE LOADED OVER CODE
BINTBX	EQU  $			XOP ENTRY INTO DEBUGGER
	B    @INITBX
LOADV	EQU  $			LOAD VECTOR
	DATA MREGS,ENTRY
B2WORD	EQU  $			2 WORD BREAKPOINT ENTRY
	DATA MREGS,BPX
*
*  TABLE OF ITEMS TO SAVE/RESTORE ON ENTRY/EXIT
*
*  total amount to save is  menu needs, + all of
*  the other little requirements+40 slop.
*
TOTSAV  EQU  IOTAMO+32+2+2+2+40
*
SAVTBL	EQU  $
	DATA GPLWS,32		GPL WORKSPACE
	DATA PRINTF,2		PRINT FLAG
	DATA CRTXY,2		X-Y CURSOR
	DATA KEYUNT,2		KEYBOARD UNIT #
	DATA -1	   		TERMINATOR
*
*  OTHER MISC. DATA CELLS
*
XOPVAL	DATA >FFD8		XOP 1 WS
XOP1	DATA >2C40		XOP 1 INSTRUCTION
*
*  CONSTANTS:
*
K0	DATA 0			CONSTANT 0
*				TABLE OF DIVISORS (FOR I FORMAT OUT)
	DATA 10000
	DATA 1000
	DATA 100
	DATA 10
	DATA 1
TENTBL	EQU  $
*
*  SCREEN MESSAGES:
*
BANNER	EQU $
	BYTE >0D,>0D
	TEXT 'Debugger V4.4'
	BYTE >0D,>FF
*
PROMPT	EQU $
	TEXT ':'
	BYTE >FF
*
INVINS	EQU  $
	TEXT 'Bad Instruction'
	BYTE >0D,>FF
*
INVNUM	EQU  $
	TEXT 'Bad Number'
	BYTE >0D,>FF
*
BUFFUL	EQU  $
	TEXT 'Too Many Breakpoints'
	BYTE >0D,>FF
*
BNOTFN	EQU  $
	TEXT 'Breakpoint Not Found'
	BYTE >0D,>FF
*
WARNBP	EQU  $
	TEXT 'Breakpoint Uses 2 Words'
	BYTE >0D,>FF
*
BALEXI	EQU  $
	TEXT 'Breakpoint Exists'
	BYTE >0D,>FF
*
CSCRI$B	EQU  $			SCREEN INPUT BUFFER
	BSS  26
SIXBBE	BSS  6			6 CHARACTER START
SIXBEN	EQU  $
CR	EQU  $			CARRIAGE RETURN & TERMINATOR
	BYTE >0D,>FF
*
HEXSTA	EQU  $
	BSS  4
	TEXT '='
HEXSDD	EQU  $
	BSS  4
	BYTE >20,>FF	
*
*  WORKSPACE REGISTER DISPLAY
*
REGDIS	EQU  $			REGISTER DISPLAY
	TEXT ' R =    '
	BYTE >FF
*
*  REGISTER DISPLAY
*
WP	EQU  $
	TEXT 'WP = '
	BYTE >FF
PC	EQU  $
	TEXT 'PC = '
	BYTE >FF
ST	EQU  $
	TEXT 'SR = '
	BYTE >FF
*
*  BREAKPOINTS DISPLAY
*
BPEQAL	EQU  $
	TEXT 'BPS= '
	BYTE >FF
*
BPDISP	EQU  $
	BYTE >0D
	TEXT '!Break @'
BPDIS1	EQU  $
	BSS  4
	TEXT ', WP='
BPDIS2	BSS  4
	TEXT ', SR='
BPDIS3	BSS  4
	BYTE >0D,>FF
*
*  HEX ARITHMETIC
*
HEXARI	EQU  $
	TEXT 'H1= '
AHEX1	BSS  4
	TEXT ' H2= '
AHEX2	BSS  4
	TEXT ' H1+H2= '
ASUM	BSS  4
	BYTE >0D
	TEXT 'H1-H2= '
ADIFF	BSS  4
	TEXT '  H1*H2= '
APROD1	BSS  4
	TEXT ' '
APROD2	BSS  4
	BYTE >0D
	TEXT 'H1/H2= '
AQUOT	BSS  4
	TEXT ' R '
AREMA	BSS  4
	BYTE >0D
	TEXT 'H1(I)= '
AINT1	BSS  6
	TEXT ' H2(I)= '
AINT2	BSS  6
	BYTE >0D,>FF
*
*  ASCII CHARACTER TABLE FOR RHEX
*
BLANK	TEXT '  '	 	2 BLANKS
HEXTBL	EQU  $
TERMIN	BYTE >FF
BLANKS	TEXT ' '
MINUS	TEXT '-'
	TEXT 'V'	 	 DISPLAY VDP RAM
	TEXT 'X'
	TEXT 'Y'
	TEXT 'Z'
	TEXT 'I'		  INTEGER VALUE
ASC0	TEXT '0'
	TEXT '9'
	TEXT 'A'
	TEXT 'F'
	EVEN
	TITL 'INITIAL ENTRY & MONITOR'
*
*  THIS MODULE CONTAINS THE INITIAL ENTRY FOR THE DEBUGGER (FROM MENU),
*  AND THE MONITOR.
*
ENTRY	EQU  $
	LIMI 0			DISABLE INTERRUPTS
	LWPI MREGS		GET MY REGISTERS
	STST R15	   	SR
	MOV  @FREGS+22,R14 	PC
	LI   R13,FREGS		WP
	BL   @SAVGPL	 	SAVE WORKSPACE, SCREEN, ETC.
	LI   R0,BINTBX		SETUP INITIAL VECTORS
	LI   R1,>FFF8
	MOV  *R0+,*R1+		INTO HIGH RAM
	MOV  *R0+,*R1+
	MOV  *R0+,*R1+
	MOV  *R0,*R1
AROUND	EQU $
	LI   R0,BPBUFF		CLEAR BREAKPOINT BUFFER AND
	LI   R1,TOCLEA		OTHER ASSORTED FLAGS
BPCLER	EQU $
	CLR  *R0+	 	CLEAR A CELL
	DECT R1
	JNE  BPCLER		BRIF MORE
*
	C    @XOPVEC,@XOPVAL
	JEQ  XOPOK		BRIF 1 WORD BREAKPOINTS
	SETO @BPXOP		ELSE, 2 WORD BREAKPOINTS
XOPOK	EQU  $
	LI   R4,BANNER		TELL USER I AM HERE
	BLWP @CSCRO$
*
*  MONTOP - MONITOR OPERATION, READ A COMMAND FROM SCREEN.
*
MONTOP	EQU $
	LI   R4,PROMPT		PUT OUT : PROMPT
	BLWP @CSCRO$
	LI   R3,30		READ COMMAND
	BL   @SETTER	 	SET TERMINATOR IN FIELD
	JEQ  MONTOP		BRIF NOTHING SPECIFIED
	LI   R5,TABLE1		SEARCH TABLE FOR COMMAND
CMDLOP	EQU $
	C    *R5,@K0	 	END OF TABLE?
	JEQ  CMDERR		BRIF YES, ERROR
	CB   *R5,*R8	 	IS THIS THE COMMAND
	JEQ  CMDJMP		BRIF YES
	AI   R5,4	 	ELSE, SKIP TO NEXT
	JMP  CMDLOP
CMDJMP	EQU  $			COMMAND RECOGNIZED, JUMP TO COMMAND
	INC  R8	   		INC TO NEXT BUFFER CHAR
	INC  R5	   		INC TO # ENTRIES, THIS COMMAND
	CLR  R9
	MOVB *R5+,R9	 	GET # HEX ENTRIES
	SWPB R9
	LI   R6,HEXDIG		STORE IN HEXDIG ARRAY
	CLR  @VDPFLG	 	CLEAR VDP SPECIFIED FLAG
RHEXLO	EQU  $
	MOV  R9,R9		DONE?
	JEQ  RHEXDO		BRIF YES
	BL   @RHEX		READ A HEX NUMBER
	JMP  NERROR		ERROR RETURN
	SETO R1	   		NULL RETURN
	MOV  R0,*R6+	 	SAVE HEX NUMBER IN R4, R5 OR R6
	DEC  R9
	JMP  RHEXLO
RHEXDO	EQU  $
	MOV  *R5,R5		GO DO PROCESS
	B    *R5
CMDERR	EQU  $		UNRECOGNIZED COMMAND
	LI   R4,INVINS
	JMP  NERRO1
NERROR	EQU  $		NUMBER ERROR (UNRECOGNIZED NUMBER)
	LI   R4,INVNUM
NERRO1	EQU  $
	BLWP @CSCRO$
	JMP  MONTOP
*
*  Q - QUIT
*
*  RETURN TO CALLER.  INITFL DETERMINES WHETHER:
*
Q	EQU  $
	BL   @RESGPL	 	RESTORE GPL WORKSPACE
	MOV  @INITFL,R5		GET INITIAL FLAG
	JEQ  BPQ
	B    @CMENU$
BPQ	EQU  $
	RTWP		 	RETURN VIA BLWP INTERFACE
*
*  M - MEMORY INSPECT/ALTER
*
M	EQU  $
	LI   R6,HEXDIG
	MOV  *R6+,R7	 	GET STARTING ADDRESS
	ANDI R7,>FFFE		MAKE EVEN
	MOV  *R6,R6		GET STOP ADDRESS
	JEQ  MALTER		BRIF NOT SPECIFIED, ALTER MODE
MDISPL	EQU  $
	LI   R8,6	 	3 WORDS PER LINE
	MOV  R7,R0		START ADDRESS
	LI   R1,HEXSTA		START HEX DISPLAY
	BL   @OHEX		OUTPUT HEX VALUE
	LI   R4,HEXSDD		TO MOVE TO
	MOV  @VDPFLG,R5   	VDP DISPLAY ?
	JNE  MDISPV		BRIF NO, DISPLAY CPU
	MOVB @BLANKS,*R4+ 	SET BLANKS IN BUFFER
MDISPV	EQU  $
	MOVB @TERMIN,*R4  	SET TERMINATOR IN BUFFER
	LI   R4,HEXSTA		SEND TO SCREEN
	BLWP @CSCRO$
MLOOP2	EQU  $
	BL   @GETFR		GET VALUE AT START ADDRESS
	LI   R1,HEXSDD		FOR DISPLAY
	MOV  @VDPFLG,R5   	VDP DISPLAY?
	JEQ  MLOOP3
	BL   @OHEX2		PUT 2 HEX DIGITS IN BUFFER
	LI   R5,>20FF		& BLANK & TERMINATOR
	MOVB R5,*R1+
	SWPB R5
	MOVB R5,*R1
	INC  R7	   		INCR TO NEXT ADDRESS
	DEC  R8
	JMP  MLOOP4
MLOOP3	EQU  $			CPU RAM DISPLAY
	BL   @OHEX		IN OUTPUT BUFFER
	INCT R7
	DECT R8
MLOOP4	EQU  $
	LI   R4,HEXSDD
	BLWP @CSCRO$	 	SEND TO SCREEN
MSKIP2	EQU  $
	MOV  R8,R8		DONE WITH COUNT?
	JNE  MLOOP2		BRIF NO
	LI   R8,-6		BACK UP TO START
	A    R8,R7		BACK UP TO START
MSKIP3	EQU $
	BL   @GETFR		GET DATA
	INC  R7	   		INCR START ADDRESS
	ANDI R0,>7F00		STRIP OFF MSB
	CI   R0,>2000		IS IT A CONTROL CHARACTER?
	JHE  MSKIP5		BRIF NO
MSKIP4	EQU $
	LI   R0,>2A00		CHANGE TO AN '*'
MSKIP5	EQU $
	CI   R0,>7F00		DON'T ALLOW >7F
	JEQ  MSKIP4
	MOVB R0,@SIXBEN(R8)
	INC  R8
	JNE  MSKIP3		BRIF MORE DIGITS
	LI   R4,SIXBBE		OUTPUT SIX ASCII CHARACTERS
	BLWP @CSCRO$
	C    R7,R6		DONE ?
	JLE  MDISPL		BRIF NO
MEXIT	B     @MONTOP	 	WHEN DONE, JUST RETURN
*
MALTER	EQU $
	MOV  R7,R0		START ADDRESS
	LI   R1,HEXSTA		START HEX DISPLAY
	BL   @OHEX		OUTPUT HEX VALUE
	BL   @GETFR		GET VALUE AT SPECIFIED LOCATION (INTO R0)
	LI   R1,HEXSDD
	MOV  @VDPFLG,R5   	VDP OR CPU?
	JEQ  MALTCP		BRIF CPU
	BL   @OHEX2		ELSE, 2 HEX DUMP
	LI   R5,>20FF
	MOVB R5,*R1+	 	& SET TERMINATOR AS LAST CHAR
	SWPB R5
	MOVB R5,*R1
	JMP  MALTCO
MALTCP	EQU $
	BL   @OHEX		PUT HEX NUMBER IN OUTPUT BUFFER
MALTCO	EQU $
	LI   R4,HEXSTA		SEND TO SCREEN
	BLWP @CSCRO$
	LI   R3,4	 	MAXIMUM # OF BYTES
	BL   @SETTER	 	SET BUFFER TERMINATOR
	JEQ  MALTIN		BRIF NOTHING SPECIFIED
	BL   @RHEX		READ A HEX DIGIT
	JMP  MEXIT		ERROR RETURN
	JMP  MALTIN		INCREMENT & RETURN
	BL   @PUTFR		PUT VALUE INTO REGISTER
	JMP  MALTER		AND TRY NEXT
MALTIN	EQU $
	MOV  @VDPFLG,R5   	WAS THIS A VDP ACCESS
	JEQ  TWOINC		BRIF NO, INCR BY 2
	INC  R7
	JMP  MALTER
TWOINC	EQU $
	INCT R7
	JMP  MALTER
*
*  GETFR - GET A WORD INTO R0 FROM STARTA (R7), HONORING THE VDP FLAG
*
GETFR	EQU  $
	MOV  @VDPFLG,R5   	FROM VDP MEMORY?
	JNE  GETFR1		BRIF YES
	MOVB *R7+,R0	 	MOVE TWO BYTES IN R0
	SWPB R0
	MOVB *R7,R0
	DEC  R7
	SWPB R0
	B    *R11	 	AND RETURN
GETFR1	EQU $
	MOV  R7,R0		GET FROM VDP MEMORY
	BLWP @CVSBR$		WITH TWO READS
	SWPB R1
	INC  R0
	BLWP @CVSBR$
	SWPB R1
	MOV  R1,R0		RETURN REQUESTED WORD
	B    *R11
*
*  PUTFR - PUT A VALUE FROM R1 INTO STARTA(R7), HONORING THE VDP FLAG
*
PUTFR	EQU  $
	MOV  @VDPFLG,R5  	TO VDP RAM?
	JNE  PUTFR1		BRIF YES
	MOV  R0,*R7+
	B    *R11
PUTFR1	EQU $
	MOV  R0,R1		WRITE A SINGLE BYTE INTO OUTPUT
	SWPB R1
	MOV  R7,R0
	BLWP @CVSBW$		WRITE IT
	INC  R7	   		INCREMENT TO NEXT ADDRESS
	B    *R11
*
*  SETTER - SET TERMINATOR (>FF) IN INPUT BUFFER
*
SETTER	EQU $
	LI   R4,CSCRI$B		MY INPUT BUFFER
	BLWP @CSCRI$		GET INPUT
	JNE  SETCRR		BRIF REDO OR BACK
	MOV  R4,R8		GET INPUT TERMINATOR
	CLR  R5
	MOVB *R8,R5		GET BYTE COUNT
	SWPB R5
	INC  R5
	A    R5,R4		SET END OF BUFFER ADDRESS
	LI   R5,>FF00
	MOVB R5,*R4		SET TERMINATOR IN BUFFER
	CLR  R5	   		LOAD BYTE COUNT AGAIN
	MOVB *R8+,R5	 	FOR COMPARE ON RETURN
	B    *R11
SETCRR	EQU $
	LI   R4,CR		REDO OR BACK, SET CR
	BLWP @CSCRO$
	B    @MONTOP	 	& GO TO MONITOR
*
*  W - DISPLAY/ALTER WORKSPACE REGISTERS
*
W	EQU $
	MOV  @HEXDIG,R7
	CI   R1,>FFFF		WAS THIS A NULL ENTRY
	JNE  WALTER		NO, ENTER ALTER MODE
	MOV  R13,R6		GET WORKSPACE POINTER
WEGLO1	EQU $
	LI   R8,3	 	3 REGISTERS/LINE
WEGLO2	EQU $
	MOV  R7,R0
	SRC  R0,4	 	IN TOP 4 BITS
	LI   R1,REGDIS+2  	PUT REGISTER # IN OUTPUT BUFFER
	BL   @OHEX1
	INC  R1
	MOV  *R6+,R0	 	GET REGISTER CONTENTS
	BL   @OHEX		INTO BUFFER
	LI   R4,REGDIS
	BLWP @CSCRO$		 DISPLAY THE REGISTER
	INC  R7
	CI   R7,16		LAST REGISTER?
	JEQ  WEGOUT		BRIF YES
	DEC  R8
	JNE  WEGLO2		BRIF NOT A MULTIPLE OF 3
	LI   R4,CR		ELSE, ISSUE CR
	BLWP @CSCRO$
	JMP  WEGLO1		GO DO ANOTHER
WEGOUT	EQU $
	LI   R4,CR		SET CR ON LAST
	BLWP @CSCRO$
	B    @MONTOP		 RETURN TO MONITOR
*
WINCRE	EQU $
	INC  R7
WALTER	EQU $			REGISTER ALTER
	MOV  R7,R0		REGISTER # TO ALTER
	JLT  WEGOUT		BRIF REGISTER #<0
	CI   R7,15		MUST BE < 16
	JGT  WEGOUT		BRIF MORE
	SRC  R0,4		 REGISTER # IN TOP 4 BITS
	LI   R1,REGDIS+2
	BL   @OHEX1		REGISTER #
	MOV  R7,R6		DETERMINE START ADDRESS
	SLA  R6,1
	A    R13,R6		GOT IT
	MOV  *R6,R0		GET VALUE
	INC  R1
	BL   @OHEX		OUTPUT NUMBER
	LI   R4,REGDIS		DISPLAY REGISTER # & VALUE
	BLWP @CSCRO$
	LI   R3,4		 GET HEX VALUE
	BL   @SETTER		 INTO CSCRI$B
	JEQ  WINCRE
	BL   @RHEX		READ HEX DIGIT
	JMP  WEGOUT		BRIF ERROR
	JMP  WINCRE		NULL
	MOV  R0,*R6		OR SET REGISTER
	JMP  WINCRE
*
*  T - TRADE SCREEN
*
T	EQU $
	CLR  R0			START OF VDP IMAGE
	LI   R1,DEBSAV		START OF CPU SAVE AREA
	LI   R2,24*80		# OF BYTES TO RESTORE
	BLWP @CVMBW$		RESTORE IT
T1	EQU  $
	BLWP @CKSCAN		DO UNIT KEY DEPRESSED
	MOVB @GPLSTA,R1
	ANDI R1,>2000		MASK KEY DEPRESSED BIT
	JEQ  T1			BRIF NOTHING HAPPENED
	JMP  WEGOUT		WHEN KEY DEPRESSED, RESTORE SCREEN
*
	TITL 'CONTINUE COMMAND HANDLERS'
*
*  R - REGISTER INSPECT/ALTER
*
R	EQU $
	LI   R6,MREGS+24	R13 START (WP)
	LI   R7,WP-6		WORKSPACE POINTER MESSAGE START
	LI   R8,3		3 REGISTERS TO INSPECT/ALTER
REGLOP	EQU $
	INCT R6
	CI   R6,MREGS+32	END OF REGISTERS?
	JEQ  REGEND		BRIF YES
	AI   R7,6		SKIP TO NEXT MESSAGE
	MOV  R7,R4		MOVE TO NEXT REGISTER
	BLWP @CSCRO$		DISPLAY THE TYPE OF REGISTER
	MOV  *R6,R0		DISPLAY THE VALUE OF THE REGISTER
	LI   R1,HEXSDD		SINGLE HEX DISPLAY
	BL   @OHEX		CONVERT AND MOVE IT
	LI   R4,HEXSDD
	BLWP @CSCRO$		NOW DISPLAY IT
	LI   R3,4		GET UP TO 4 HEX DIGITS
	BL   @SETTER		GO GET BUFFER
	JEQ  REGLOP
	BL   @RHEX		CONVERT THE HEX NUMBER
	JMP  REGEND		BRIF ERROR
	JMP  REGLOP		BRIF NULL (NOTHING HERE)
	MOV  R0,*R6
	JMP  REGLOP
*
*  H - HEX ARITHMETIC
*
H	EQU $
	LI   R7,HEXDIG		GET H1, H2
	MOV  *R7+,R6	 	H1
	MOV  *R7,R7		H2
	MOV  R6,R0
	LI   R1,AHEX1		PUT H1 IN BUFFER
	BL   @OHEX
	MOV  R7,R0
	LI   R1,AHEX2		PUT H2 IN BUFFER
	BL   @OHEX
	MOV  R6,R0
	A    R7,R0
	LI   R1,ASUM	 	PUT H1+H2 IN BUFFER
	BL   @OHEX
	MOV  R6,R0
	S    R7,R0
	LI   R1,ADIFF		PUT H1-H2 IN BUFFER
	BL   @OHEX
	MOV  R7,R0
	MPY  R6,R0
	MOV  R1,R5		SAVE 2ND WORD OF PRODUCT
	LI   R1,APROD1		PUT H1*H2 IN BUFFER
	BL   @OHEX
	MOV  R5,R0		OUTPUT 2ND WORD OF PRODUCT
	LI   R1,APROD2
	BL   @OHEX
	MOV  R6,R1
	CLR  R0
	DIV  R7,R0
	MOV  R1,R5		TEMP SAVE REMAINDER
	LI   R1,AQUOT		PUT H1/H2 IN BUFFER
	BL   @OHEX
	MOV  R5,R0
	LI   R1,AREMA		PUT MOD(H1,H2) IN BUFFER
	BL   @OHEX
	MOV  R6,R0		H1 IN INTEGER
	LI   R1,AINT1
	BL   @OINT
	MOV  R7,R0		H2 IN INTEGER
	LI   R1,AINT2
	BL   @OINT
	LI   R4,HEXARI		OUTPUT RESULT OF ARITHMETICS
	BLWP @CSCRO$
REGEND	EQU  $
	B    @MONTOP	 	AND RETURN
*
*  B - BREAKPOINT INSPECT/ALTER
*
B	EQU  $
	MOV  @HEXDIG,R7   	SPECIFIED BREAKPOINT ADDRESS
B1	EQU  $
	LI   R6,BPBUFF		BREAKPOINT BUFFER
	ANDI R7,>FFFE		MAKE EVEN
	JEQ  NOADD		BRIF NOTHING SPECIFIED
	LI   R5,NOBPS
BUFSRC	EQU $
	C	R7,*R6+	 	IS THIS THE PACKET?
	JEQ  BUFFND		BRIF YES
	AI   R6,4	 	ELSE, SKIP TO NEXT PACKET
	DEC  R5
	JNE  BUFSRC
	CB   R1,@MINUS		WAS TERMINATION BY MINUS SIGN?
	JNE  BUFADD		BRIF NO, ADD BREAKPOINT
	LI   R4,BNOTFN		BREAKPOINT NOT FOUND
	JMP  BPERR1
BUFADD	EQU $			ADD A BREAKPOINT
	LI   R5,NOBPS
	LI   R6,BPBUFF		FIND A BLANK SLOT IN BREAKPOINT TABLE
BUFSR1	EQU $
	MOV  *R6,R1		IS THIS SLOT FREE?
	JEQ  BUFAD1		BRIF YES
	AI   R6,6
	DEC  R5	   		DO UNTIL FOUND OR PACKETS EXHAUSTED
	JNE  BUFSR1
	LI   R4,BUFFUL		TOO MANY BREAKPOINTS
	JMP  BPERR1
BUFAD1	EQU $			FREE PACKET FOUND
	MOV  R7,*R6+	 	SAVE ADDRESS IN BUFFER
	MOV  *R7+,*R6+		SAVE 1ST WORD
	MOV  *R7,*R6		SAVE 2ND WORD (IF 2 WORD BREAKPOINT)
	DECT R7
	ABS  @BPXOP		2 WORD BREAKPOINTS
	JNE  BUFTWW		BRIF YES
	MOV  @XOP1,*R7		SET BREAKPOINT
	JMP  BRETUR
BUFTWW	EQU $			2 WORD BREAKPOINT
	MOV  @BPINST,*R7+ 	SET WORD 1 BREAKPOINT
	MOV  @BPINST+2,*R7
	LI   R4,WARNBP		BREAKPOINT USES 2 WORDS WARNING
	BLWP @CSCRO$
	JMP  BRETUR
*
BUFFND	EQU $
	CB   R1,@MINUS		WAS BREAKPOINT TO BE REMOVED?
	JNE  BUFALE		BRIF NO, ADD A BREAKPOINT WHICH ALREADY EXISTS
	DECT R6
	CLR  *R6+
	MOV  *R6+,*R7+		REMOVE BREAKPOINT
	ABS  @BPXOP		DOES BREAKPOINT USE 2 WORDS?
	JEQ  BRETUR		BRIF NO, JUST RETURN
	MOV  *R6+,*R7+		RESTORE 2ND WORD
BRETUR	EQU $
	B	@MONTOP
BUFALE	EQU $
	LI   R4,BALEXI		BREAKPOINT ALREADY EXISTS
BPERR1	EQU $
	BLWP @CSCRO$
	JMP  BRETUR
*
NOADD	EQU  $			NOT AN ADD
	CB   R1,@MINUS		MINUS SIGN TERMINATION?
	JEQ  BPREMO		YES, REMOVE ALL BREAKPOINTS
BPLIST	EQU $			ELSE, BREAK POINT LIST
	LI   R4,BPEQAL
	BLWP @CSCRO$
	LI   R5,NOBPS
	LI   R6,NOBPSL		# OF BPS PER LINE
	LI   R7,BPBUFF
BPLOOP	EQU $
	MOV  *R7,R0		ANY BREAKPOINT HERE?
	JNE  BPFOND		BRIF YES
BPOUTL	EQU $
	AI   R7,6
	DEC  R5
	JNE  BPLOOP		BRIF MORE TO SEARCH
	LI   R4,CR
	BLWP @CSCRO$
	B	@MONTOP
BPFOND	EQU $
	LI   R1,HEXSDD		DISPLAY BREAKPOINT ADDRESS
	BL   @OHEX
	LI   R4,HEXSDD
	BLWP @CSCRO$
	DEC  R6	   		DECR # BPS PER LINE
	JNE  BPOUTL
	LI   R4,CR
	BLWP @CSCRO$
	LI   R6,NOBPSL
	JMP  BPOUTL
*
BPREMO	EQU $			REMOVE ALL BREAKPOINTS
	LI   R5,BPBUFF		BREAKPOINT BUFFER START
	LI   R6,NOBPS		NUMBER OF BREAKPOINTS
BPRLOP	EQU $
	MOV  *R5,R4		GET BREAKPOINT, THIS LOCATION
	JNE  BPRLO2		BRIF SOMETHING HERE
	AI   R5,6
BPRLO1	EQU $
	DEC  R6
	JNE  BPRLOP		BRIF MORE BREAKPOINTS
	B    @MONTOP
BPRLO2	EQU $
	CLR  *R5+	 	CLEAR THE LOCATION
	MOV  *R5+,*R4		RESTORE CODE AT ADDRESS
	ABS  @BPXOP		BREAKPOINT USES 2 WORDS?
	JEQ  BPRLO3		BRIF NO
	MOV  *R5+,*R4		ELSE, RESTORE 2ND WORD
	JMP  BPRLO1
BPRLO3	EQU $
	INCT R5
	JMP  BPRLO1
*
*  BREAKPOINT ENTRIES:
*
*  INITBX  -  SINGLE WORD (XOP 1) ENTRY
*  BPX	   -  DOUBLE WORD (BLWP) ENTRY
*
INITBX	EQU $
	BL   @SAVGPL	 	SAVE WORKSPACES, OTHER MISC CELLS
	JMP  BPXONT
BPX	EQU  $
	BL   @SAVGPL	 	SAVE WORKSPACES, OTHER MISC CELLS
	DECT R14
BPXONT	EQU $
	DECT 14
	MOV  R14,R0		DISPLAY BREAKPOINT
	LI   R1,BPDIS1
	BL   @OHEX
	MOV  R13,R0		WORKSPACE POINTER
	LI   R1,BPDIS2
	BL   @OHEX
	MOV  R15,R0		STATUS REGISTER
	LI   R1,BPDIS3
	BL   @OHEX
	LI   R4,BPDISP
	BLWP @CSCRO$	 	DISPLAY BREAKPOINT MESSAGE
	CLR  @INITFL	 	SET FLAG SAYING I ENTERED VIA BP
	MOVB @MINUS,R1		PRETEND THAT THIS IS A B - COMMAND
	MOV  R14,R7		BREAK POINT ADDRESS TO REMOVE
	B    @B1	  	AND DO REMOVE LOGIC
*
	TITL 'DEBUGGER SUBROUTINES'
*
*  THIS MODULE CONTAINS THE FOLLOWING SUBROUTINES:
*
*	SAVGPL - SAVE GPL WORKSPACE & OTHER
*	RESGPL - RESTORE GPL WORKSPACE & OTHER
*	RHEX   - READ HEX/INTEGER NUMBERS
*	OHEX   - OUTPUT 4 HEX DIGITS
*	OHEX1  - OUTPUT 1 HEX DIGIT
*	OHEX2  - OUTPUT 2 HEX DIGITS
*	OINT   - OUTPUT INTEGER NUMBER (SIGNED)
*
SAVGPL	EQU $
	LIMI 0
	LI   R3,DEBSAV		MY SAVE AREA
	LI   R4,SAVTBL		SAVE TABLE CELLS
*
SAVOUT	EQU $	
	MOV  *R4+,R5	 	GET START ADDRESS TO SAVE
	CI   R5,-1		TERMINATOR?
	JEQ  SAVEND		BRIF YES
	MOV  *R4+,R2		 # BYTES TO SAVE
	MOV  R5,R5		START ADDRESS TO SAVE
	JLT  SAVCPU		IF <0, IN RAM PAD
	CI   R5,>2000		ELSE, IF <2000, IN VDP RAM
	JGT  SAVCPU
*
* SAVE SOME VDP RAM AREA
*
	MOV  R5,R0		FROM ADDRESS
	MOV  R3,R1		TO   ADDRESS
	BLWP @CVMBR$		READ IT
	A    R2,R3		UPDATE POINTER TO SAVE AREA
	JMP  SAVOUT		PROCESS NEXT ENTRY
*
SAVCPU	EQU $
	MOV  *R5+,*R3+		SAVE A WORD
	DECT R2			DECR # OF BYTES TO SAVE
	JNE  SAVCPU
	JMP  SAVOUT		PROCESS NEXT ENTRY
*
SAVEND	EQU $
	SETO @PRINTF	 	ENABLE HOLD ON PRINT FUNCTION
	CLR  @KEYUNT	 	KEYBOARD UNIT NUMBER
	B    *R11	 	RETURN
*
RESGPL	EQU $
	LI   R3,DEBSAV		GET END VDP RAM
	LI   R4,SAVTBL		SAVE TABLE CELLS
*
RESOUT	EQU $
	MOV  *R4+,R5	 	GET START ADDRESS TO SAVE
	CI   R5,-1		TERMINATOR?
	JEQ  RESEND		BRIF YES
	MOV  *R4+,R2	 	# BYTES TO SAVE
	MOV  R5,R5		START ADDRESS TO SAVE
	JLT  RESCPU		IF <0, IN RAM PAD
	CI   R5,>2000		ELSE, IF <2000, IN VPD RAM
	JGT  RESCPU
RESVDP	EQU $
	MOV  R3,R0		FROM ADDRESS
	MOV  R5,R1		TO   ADDRESS
	BLWP @CVMBW$		WRITE IT
	A    R2,R3
	JMP  RESOUT		PROCESS NEXT ENTRY
*
RESCPU	EQU $
	MOV  *R5+,*R3+		SAVE A WORD
	DECT R2
	JNE  RESCPU
	JMP  RESOUT		PROCESS NEXT ENTRY
*
RESEND	EQU $
	LIMI 2			ELSE, TURN THEM ON
	B    *R11
*	
*  RHEX - HEX INPUT
*
*  THIS ROUTINE SCANS THE NEXT (UP TO 4) DIGITS IN THE INPUT BUFFER
*  AND RETURNS THE HEXADECIMAL VALUE IN THE USER R0.  THE TERMINATION
*  CHARACTER IS RETURNED IN THE MSB OF R1.  THE LSB OF R1 IS CLEARED.
*
*  THERE ARE 2 RETURN SPOTS FOR THIS ROUTINE:
*
*	 BLWP @RHEX
*	 JMP  ERRORE	ERROR RETURN
*	 JMP  NULLRT	NULL RETURN
*	 JMP  NORMAL	NORMAL RETURN
*
*  NOTE:  ON ENTRY, R8 POINTS TO INPUT BUFFER
*
RHEX	EQU  $
	CLR  R0	   		CLEAR HEX VALUE
	CLR  @BIAS		CLEAR ANY X,Y,OR Z BIAS
	LI   R4,16		ASSUME HEX MULTIPLY
RHEX1	EQU  $
	CB   *R8,@HEXTBL  	TERMINATOR CHAR?
	JEQ  NULLRT
	CB   *R8,@HEXTBL+1 	SPACE CHARACTER
	JNE  RHEX2		BRIF NO
	INC  R8
	JMP  RHEX1		TRY ANOTHER CHARACTER
*
RHEX2	EQU  $
	CLR  R1
	MOVB *R8,R1		GET CHAR, THIS LOCATION
	LI   R3,HEXTBL
	CB   *R8,*R3+		IS IT A TERMINATOR?
	JEQ  NORMRT		BRIF YES, NORMAL RETURN
	INC  R8
	CB   R1,*R3+	 	IS IT A SPACE?
	JEQ  NORMRT
	CB   R1,*R3+	 	IS IT A MINUS SIGN?
	JEQ  NORMRT		BRIF YES, TERMINATOR
	CB   R1,*R3+		IS IT VDP FLAG?
	JEQ  SETVDP		BRIF YES, SET VDP MEMORY FLAG
	CB   R1,*R3+		IS IT X BIAS?
	JEQ  SETXBI
	CB   R1,*R3+		IS IT Y BIAS?
	JEQ  SETYBI
	CB   R1,*R3+		IS IT Z BIAS?
	JNE  CHECKI		BRIF NO, CHECK DIGITS
*
SETZBI	EQU  $
	MOV  @ZBIAS,@BIAS	SET Z BIAS
	JMP  RHEX2		GO READ ANOTHER CHAR
*
SETXBI	EQU  $
	MOV  @XBIAS,@BIAS	SET X BIAS
	JMP  RHEX2
*
SETYBI	EQU  $
	MOV  @YBIAS,@BIAS	SET Y BIAS
	JMP  RHEX2
*
SETVDP	EQU  $
	SETO @VDPFLG		ELSE, SET VDP MEMORY FLAG
	JMP  RHEX2		GO READ ANOTHER CHAR
*
CHECKI	EQU $
	CB   R1,*R3+	 	IS IT AN 'I' (FOR INTEGER)
	JNE  CHECKD
	LI   R4,10		CHANGE MULTIPLIER TO INTEGER
	MOV  R0,R0		HAS A NUMBER ALREADY BEEN SPECIFIED?
	JNE  ERRORT		BRIF YES, ERROR
	JMP  RHEX2
CHECKD	EQU $
	CB   R1,*R3+	 	LESS THAN ZERO?
	JLT  ERRORT		BRIF YES
	CB   R1,*R3+		LESS THAN OR = TO 9?
	JGT  CHECKN
	SWPB R1
	AI   R1,->30	 	ADD ZERO OFFSET
	JMP  STORHE
CHECKN	EQU $
	CI   R4,10		DOING INTEGER STUFF?
	JEQ  ERRORT		BRIF YES, ERROR
	CB   R1,*R3+	 	LESS THAN 'A'
	JLT  ERRORT		BRIF ERROR
	CB   R1,*R3+
	JGT  ERRORT		BRIF ERROR
	SWPB R1
	AI   R1,-55		ADD ZERO OFFSET
STORHE	EQU $
	MOV  R1,R3		TEMP SAVE
	MPY  R4,R0		PERFORM 16 OR 10 MULTIPLY
	MOV  R1,R0
	A    R3,R0		ADD IN NEW DIGITS
	JMP  RHEX2
*
NORMRT	EQU  $			NORMAL RETURN
	A    @BIAS,R0		ADD X,Y OR Z BIAS
	INCT R11	   	RETURN + 4
*
NULLRT	EQU $
	INCT R11	   	RETURN + 2
*
ERRORT	EQU $
	B   *R11	  	RETURN + 0
*
*  OHEX  - OUTPUT 4 HEX DIGITS (IN R0) TO BUFFER
*  OHEX1 - OUTPUT 1 HEX DIGIT  (IN R0) TO BUFFER
*  OHEX2 - OUTPUT 2 HEX DIGITS (IN R0) TO BUFFER
*
OHEX	EQU  $
	LI   R2,4	 	4 DIGITS TO DISPLAY
	JMP  OHEXCO
OHEX2	EQU  $
	LI   R2,2	 	2 DIGITS TO DISPLAY
	JMP  OHEXCO
OHEX1	EQU  $
	LI   R2,1	 	1 DIGIT
OHEXCO	EQU $
	MOV  R0,R3		SAVE CHARACTERS
	SRC  R0,16-4	 	LEFT 4
	ANDI R3,>F000		MASK OFF DIGIT
	SRC  R3,4	 	IN LOW PORTION OF BYTE
	CI   R3,>0900		IS IT >10?
	JGT  ITSLET		BRIF YES, LETTER
	AI   R3,>3000		ELSE, ADD ZERO IN ASCII
	JMP  OHEXMO		AND MOVE IT
ITSLET	EQU $
	AI   R3,>4100->0A00
OHEXMO	EQU $
	MOVB R3,*R1+	 	SAVE IN BUFFER
	DEC  R2	   		ANY MORE?
	JNE  OHEXCO		BRIF YES
	B	*R11	 	ELSE, RETURN
*
*  OINT - OUTPUT INTEGER IN 6 BYTE FIELD (SIGNED)
*
*	 R0 CONTAINS VALUE
*	 R1 CONTAINS OUTPUT BUFFER ADDRESS
*
OINT	EQU  $
	LI   R2,-6		FIRST, CLEAR FIELD
	MOV  R1,R3
OINT1	EQU  $
	MOVB @BLANKS,*R3+
	INC  R2
	JNE  OINT1
*
	MOV  R1,R2		MOVE FOR DIVIDE
	CLR  R3	   		RESET SIGN FLAG
	CLR  R5	   		RESET ZERO FILL FLAG
	MOV  R0,R0
	JEQ  SETZER		BRIF 0, JUST PUT ZERO IN OUTPUT BUFFER
	JLT  CHGSIG		BRIF <0, CHANGE SIGN
	INC  R2	   		ELSE, SKIP PAST SIGN
	JMP  SIGNOK
CHGSIG	EQU $
	NEG  R0	   		ELSE, NEGATE VALUE
	SETO R3	   		AND SET SIGN FLAG
SIGNOK	EQU $
	LI   R4,-10		INDEX INTO TENTBL
	MOV  R0,R1
OINT2	EQU  $
	CLR  R0
	DIV  @TENTBL(R4),R0
	MOV  R0,R0		ZERO QUOTIENT?
	JEQ  ISZERO		YES
	INC  R5	   		DON'T ZERO FILL ANY MORE DIGITS
ISZERO	EQU $
	MOV  R5,R5		ZERO FILLING?
	JNE  OINT3		BRIF NOT ZERO, STORE DIGIT
	INC  R2	   		ELSE, JUST INCR DIGIT
	JMP  OINT5		& INCREMENT COUNT
OINT3	EQU  $
	MOV  R3,R3		CHECK SIGN FLAG
	JEQ  OINT4		BRIF 0
	MOVB @MINUS,*R2+
	CLR  R3
OINT4	EQU  $
	SWPB R0	   		STORE DIGIT IN OUTPUT BUFFER
	AB   @ASC0,R0
	MOVB R0,*R2+
OINT5	EQU  $
	INCT R4	   		INCR TEN TABLE ADDRESS
	JNE  OINT2
	B    *R11	 	DONE
*
SETZER	EQU $
	AI   R1,5	 	PUT ZERO IN OUTPUT BUFFER
	MOVB @ASC0,*R1
	B    *R11
*
*  X, Y, AND Z BIAS
*
X	EQU  $
	MOV  @HEXDIG,@XBIAS	SAVE X BIAS
	JMP  BBIAS
*
Y	EQU  $
	MOV  @HEXDIG,@YBIAS	SAVE Y BIAS
	JMP  BBIAS
*
Z	EQU  $
	MOV  @HEXDIG,@ZBIAS	SAVE Z BIAS
BBIAS	EQU  $
	B    @MONTOP
DEBUE	EQU  $
*
*  DEBUGGER SCREEN, ETC. SAVE AREA
*
*
*  ZERO CLEARED DATA AREA:
*
BPBUFF	EQU $
	BSS  NOBPS*6		SAVE AREA FOR BREAKPOINTS
BPXOP	BSS  2			BREAKPOINT USES XOP(0) OR NOT(-1)
STASYM	BSS  2			STARTING SYMBOL ADDRESS (MAIN PROGRAM)
SELSYM	BSS  2			SELECTED SYMBOL ADDRESS (THIS MODULE)
XBIAS	BSS  2			X BIAS
YBIAS	BSS  2			Y BIAS
ZBIAS	BSS  2			Z BIAS
TOCLEA	EQU  $-BPBUFF
*
*  NON-CLEARED DATA AREA:
*
INITFL	BSS  2			INIT ENTRY (MENU,-1; FORTRAN,1; OR BP,0)
HEXDIG	BSS  6			HEXADECIMAL DIGITS (UP TO 3)
VDPFLG	BSS  2			'V' SPECIFIED IN HEX NUMBER
SYMFLG	BSS  2			SYMBOL ENCOUNTERED FLAG
SYMIMG	BSS  20	   		SYMBOL IMAGE
SYMTYP	BSS  2			SYMBOL TYPE (-1=IDT,0=NAME,1=LABEL,2=LINE)
FORTYP	BSS  2			FORMAT TYPE (0=NORM, 1=HEX, 2=ALPHA)
SYMSAV	BSS  2			SAVE CELL FOR SYMBOL LOOKUP
SYMRET	BSS  2			SAVE CELL FOR SYMBOL LOOKUP
SYMTMP	BSS  2			SYMBOL TEMP FOR WRITES
SYMTMR	BSS  2			SYMBOL TEMP FOR READS
PROCTB	BSS  2			PROCESS TABLE BRANCH ADDRESS
BIAS	BSS  2			X, Y, OR Z BIAS
*
DEBSAV	BSS  TOTSAV
	END
