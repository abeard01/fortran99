	TITL 'FORTRAN DEBUGGER'
	IDT  'FDEBUG'
*
**************************
*			 *
*	FDEBUG		 *
*			 *
**************************
*
*  This program is the debugger for the GPL/MDOS FORTRAN system.
*
*  The debugger is entered via one of the following:
*
*  1. Initial call from FORTRAN execution support:
*
*   Upon initial call, the breakpoint buffer is initialized, all
*   data areas are initialized, a header line is displayed on the
*   CRT, and user commands are solicited.
*
*  2. Error call from FORTRAN execution support
*
*   Error calls come here if the debugger was loaded.  The error
*   address is displayed,  including the translated module name,
*   the FORTRAN line number, and the FORTRAN label (if any) from
*   the symbol file.  The command loop is then entered.
*
*  3. Via a BREAKPOINT call
*
*   User installed breakpoints cause an entrance to the debugger.
*   The breakpoint address is displayed on the screen, including
*   the translated module name, the FORTRAN line number, and the
*   FORTRAN label (if any) from the symbol file.  The command loop
*   is then entered.
*
*  The debugger is assembled as an absolute located module,
*  but is actually runtime relocatable.
*
*  Register Usage:
*
*	R3  - DEBUGGER START
*	R7  - DATA AREA START (FORTRAN RUNTIME)
*	R8  - SYMIMG ADDRESS
*	R9  - HEXDIG ADDRESS
*	R10 - RUNTIME START ADDRESS
*	R13 - OLD WORKSPACE POINTER
*	R14 - CALLED ADDRESS
*	R15 - OLD STATUS
*
*  UPDATE HISTORY:
*
*  V2.1	    26-JUN-86	 ADDED SYMBOLIC MODIFICATIONS
*  V2.2.1   24-JAN-87	 PATCH CLEANUP
*  V3.0	    30-MAY-87	 Changed FORTRAN execution calls to match
*			   new I/O.
*  V4.4     12-DEC-89    INITIAL v4.4 Version
*
*
GENEVE	EQU  0			GPL ONLY
	UNL
	COPY "EQUATES:FORTEX.EQ9"
	LIST
*
	DEF  FDEBUG		DEBUGGER START
	DEF  FDEBUE		DEBUGGER END
*
FDEBUG	EQU  $
	B    @ENTRY(R3)		ENTER DEBUGGER
FERROR	EQU  $
	B    @ENERR(R3)		ENTER VIA DEBUGGER ERROR
*
	TITL 'DEBUGGER DATA AREA'
*
*  Execution Support Package Equates:
*
ISCLRI	EQU  >0000+SCLRIO	INTEGER *2 SCALAR I/O
KSCLRI	EQU  >0100+SCLRIO	INTEGER *1 SCALAR I/O
JSCLRI	EQU  >0200+SCLRIO	INTEGER *4 SCALAR I/O
SSCLRI	EQU  >0300+SCLRIO	REAL    *4 SCALAR I/O
DSCLRI	EQU  >0400+SCLRIO	REAL    *8 SCALAR I/O
CSCLRI	EQU  >0500+SCLRIO	COMPLEX *8 SCALAR I/O
ESCLRI	EQU  >0600+SCLRIO	COMPLEX*16 SCALAR I/O
LSCLRI	EQU  >0700+SCLRIO	LOGICAL *2 SCALAR I/O
*
IARRYI	EQU  >0000+ARRYIO	INTEGER *2 ARRAY I/O
KARRYI	EQU  >0100+ARRYIO	INTEGER *1 ARRAY I/O
*
*  OTHER MISC. EQUATES:
*
NOBPS	EQU  7			NUMBER OF BREAKPOINTS, MAX
VDPLO	EQU  >1000		VDP LOW ADDRESS START
*
*  TABLE OF COMMANDS
*
TABLE1	EQU  $
	TEXT 'M'	  	MEMORY INSPECT/MODIFY
	BYTE 2
	DATA M
*
	TEXT 'W'	  	WORKSPACE INSPECT/MODIFY
	BYTE 1
	DATA W
*
	TEXT 'B'	  	BREAKPOINTS
	BYTE 1
	DATA B
*
	TEXT 'H'	  	HEX ARITHMETIC
	BYTE 2
	DATA H
*
	TEXT 'R'	  	REGISTER INSPECT/ALTER
	BYTE 0
	DATA R
*
	TEXT 'Q'	  	QUIT
	BYTE 0
	DATA Q
*
	TEXT 'T'	  	TRADE SCREEN
	BYTE 0
	DATA T
*
	TEXT 'L'	  	LOAD SYMBOL FILE
	BYTE 0
	DATA L
*
	TEXT 'S'	  	SELECT MODULE
	BYTE 0
	DATA S
K0	DATA 0
*
*  VARIABLE LENGTH BY TYPE (0-7)
*
VARLEN	EQU  $
	BYTE 2,1,4,4,8,8,16,2
*
*  FIRST TWO WORDS OF A PROGRAM LOAD PAB
*
LOASHE	EQU  $
	DATA >0500,VDPLO+>30
*
*  THE FOLLOWING TWO TABLES ARE USED BY THE INITIALIZATION PATH
*  TO SETUP REQUIRED ABSOLUTE CELLS.  THE FIRST TABLE CONTAINS
*  TWO VALUES, A VALUE TO COMPUTE AND A LOCATION TO STORE.
*  THE SECOND TABLE CONTAINS A ONE-DIMENSION ARRAY OF LOCATIONS
*  FOR WHICH THE ABSOLUTE LOCATION OF VALRET IS TO BE STORED.
*
INITV1	EQU  $
	DATA B2WORD,BPINST+2	ENTRY VECTOR
	DATA INITBX,BINTBX+2	ENTRY VECTOR
	DATA ENTRY,LOADV+2	ENTRY VECTOR
	DATA BPX,B2WORD+2	ENTRY VECTOR
	DATA -1
*
*  BLWP VECTORS
*
	EVEN
BPINST	EQU  $		
	BLWP @B2WORD		DATA TO BE LOADED OVER CODE
BINTBX	EQU  $			XOP ENTRY INTO DEBUGGER
	B    @INITBX
*
*  ENTRY POINTS FOR ABOVE VECTORS
*
LOADV	EQU  $			LOAD VECTOR
	DATA MREGS,ENTRY
B2WORD	EQU  $			2 WORD BREAKPOINT ENTRY
	DATA MREGS,BPX
*
*  TABLE OF ITEMS TO SAVE/RESTORE ON ENTRY/EXIT
*
TOTSAV	EQU  24*80+32+2+2	SCREEN + WORKSPACE + FLAGS
*
SAVTBL	EQU  $
	DATA 0,24*80		SCREEN IMAGE (80 COL)
	DATA GPLWS,32		GPL WORKSPACE
	DATA CRTXY,2		X-Y CURSOR
	DATA KEYUNT,2		KEYBOARD UNIT #
	DATA -1	   		TERMINATOR
*
BLANKS	EQU  $
	TEXT '  '	 	2 BLANKS
*
*  OTHER MISC. DATA CELLS
*
XOPVAL	EQU  $
	DATA >FFD8		XOP 1 WS
XOP1	EQU  $
	DATA >2C40		XOP 1 INSTRUCTION
*
*  CONSTANTS:
*
K15	EQU  $
	DATA 15
KX6106	EQU  $
	DATA >6106		CONSTANT 6106
KX6204	EQU  $
	DATA >6204		CONSTANT 6204
KX40	EQU  $
	BYTE >40		CONSTANT (FOR NEW MODULE START)
KX60	EQU  $
	BYTE >60		CONSTANT (FOR NEW VARIABLE START)
	EVEN
NUMBPS	EQU  $
	DATA NOBPS		MAX. NUMBER OF BREAKPOINTS
K2	EQU  $
	DATA 2			A CONSTANT
*
*  THE FOLLOWING CONSTANTS MUST BE CONTIGUOUS
*
CHKTBL	EQU  $
KX4000	EQU  $
	BYTE >40		MODULE START PACKET
KM1	EQU  $
	BYTE >FF		TERMINATOR
KX6000	EQU  $
	BYTE >60		VARIABLE NAME PACKET
KX6100	EQU  $
	BYTE >61		LABEL PACKET
KX6200	EQU  $
	BYTE >62		LINE # PACKET
*
*  FORMAT STATEMENTS:
*
BANNER	EQU  $
	TEXT "(' 99 FORTRAN Debugger V4.4')"
LOAMSG	EQU  $
	TEXT "(' File?'/'+')"
PROMPT	EQU  $
	TEXT "('+:')"
INVINS	EQU  $
	TEXT "(' Bad Command')"
INVNUM	EQU  $
	TEXT "(' Bad Number')"
BUFFUL	EQU  $
	TEXT "(' > 7 Breakpoints')"
BNOTFN	EQU  $
	TEXT "(' BP Not Found')"
WARNBP	EQU  $
	TEXT "(' BP Is Two Words')"
BALEXI	EQU  $
	TEXT "(' BP Already Exists')"
SYMBAD	EQU  $
	TEXT "(' No Symbol File')"
IOERR	EQU  $
	TEXT "(' I/O Error ',Z4)"
INVSPE	EQU  $
	TEXT "(' Bad Symbol')"
NOTFND	EQU  $
	TEXT "(' Symbol Not Found')"
BADSYF	EQU  $
	TEXT "(' Not Symbol File')"
NOROOM	EQU  $
	TEXT "(' No Room Symbol File')"
READFR	EQU  $
	TEXT "(Q,40A1)"
*
*  FORMATS FOR MODIFY:
*
REGALL	EQU  $		DISPLAY ALL REGISTERS
	TEXT "(5(3(1X,'R',Z1,'=',Z4)/),' R',Z1,'=',Z4)"
REGONE	EQU  $		DISPLAY 1 REGISTER
	TEXT "('+R',Z1,' = ',Z4,'/')"
CPUFMT	EQU  $		MODIFY (3 VALUES/LINE)
	TEXT "(1X,Z4,'/',3(1X,Z4),1X,3A2)"
CPUALT	EQU  $		MODIFY 1 HEX VALUE
	TEXT "('+',Z4,'/ ',Z4,'/')"
BLALIN	EQU  $
	TEXT "(1X)"
*
*  REGISTER DISPLAYS:
*
WP	EQU  $
	TEXT "('+WP=',Z4,'/')"
PC	EQU  $
	TEXT "('+PC=',Z4,'/')"
ST	EQU  $
	TEXT "('+ST=',Z4,'/')"
*
*  BREAKPOINTS DISPLAY
*
BPEQAL	EQU  $
        TEXT "(' Locn   Module   Line  Label')"
BPINDV	EQU  $
	TEXT "(1X,Z4,1X,5A2,I5,I7)"
BPDISP	EQU  $
        TEXT "('0!Break @',Z4,', WP=',Z4,', SR=',Z4)"
ERDISP	EQU  $
	TEXT "('0!Error @',Z4,', WP=',Z4,', SR=',Z4)"
*
*  HEX ARITHMETIC (FORTRAN FORMAT)
*
HEXARF	EQU  $
	TEXT "(' H1= ',Z4,' H2= ',Z4,' H1+H2= ',Z4/"
	TEXT "' H1-H2= ',Z4,'  H1*H2= ',Z4,1X,Z4/"
	TEXT "' H1/H2= ',Z4,' R ',Z4/"
        TEXT "' H1(I)= ',I6,' H2(I)= ',I6)"
*
*  DISPLAY OF PACKETS FORMATS
*
TYPE4F	EQU  $
	TEXT "(' &',5A2,' @',Z4)"
TYPE61	EQU  $
	TEXT "(' *',I6,' @',Z4)"
TYPE62	EQU  $
	TEXT "(' %',I5,' @',Z4)"
*
*  DISPLAY OF A SYMBOL NAME
*
SYMDIS	EQU  $
	TEXT "('+',5A2,'(',I4,')=')"
	EVEN
*
*  FORMAT STATEMENTS FOR EACH TYPE OF WRITE OPERATION:
*
INTDI1	TEXT "('+',I5,'/')"
INTDI2	TEXT "('+',I8,'/')"
INTDI4	TEXT "('+',I13,'/')"
INTDR4	TEXT "('+',F16.7,'/')"
INTDR8	TEXT "('+',F26.16/)"
INTDC8	TEXT "('+(',F16.7,','/F18.7,')')"
INTD16	TEXT "('+(',F26.7,','/F28.16,')')"
INTDL2	TEXT "('+',L6,'/')"
*
HEXDI1	TEXT "('+',Z2,'/')"
HEXDI2	TEXT "('+',Z4,'/')"
HEXDI4	TEXT "('+',Z8,'/')"
HEXDI8  TEXT "('+',Z16/)"
HEXD16	TEXT "('+',Z16/1X,Z16)"
*
ALPDI1	TEXT "('+',A1,'/')"
ALPDI2	TEXT "('+',A2,'/')"
ALPDI4	TEXT "('+',A4,'/')"
ALPDI8	TEXT "('+',A8,'/')"
ALPD16	TEXT "('+',2A8,'/')"
*
*  FORMAT STATEMENTS FOR EACH TYPE OF READ OPERATION:
*
INTRI1	TEXT "(I13)"
INTRR8	TEXT "(F26.16)"
INTCM8	TEXT "(2F26.16)"
INTRL2	TEXT "(L6)"
*
HEXRI1	TEXT "(Z2)"
HEXRI2	TEXT "(Z4)"
HEXRI4	TEXT "(Z8)"
HEXRI8	TEXT "(Z16)"
HEXC16	TEXT "(2Z16)"
*
ALPRI1	TEXT "(A1)"
ALPRI2	TEXT "(A2)"
ALPRI4	TEXT "(A4)"
ALPRI8	TEXT "(A8)"
ALPC16	TEXT "(2A8)"
*
*  ASCII CHARACTER TABLE FOR RHEX
*
HEXTBL	EQU  $
	BYTE >FF
	TEXT ' '
MINUS	EQU  $
	TEXT '-VI%*&09AF'
*
*  ASCII CHARACTER TABLE FOR SCANSY
*
SYMSLS	EQU  $
	BYTE >FF
	TEXT ' ,ZA'
	EVEN
*
	TITL 'INITIAL ENTRY & MONITOR'
*
*  THIS MODULE CONTAINS THE INITIAL ENTRY FOR THE DEBUGGER (FROM MENU),
*  AND THE MONITOR.
*
ENTRY	EQU  $
	LWPI MREGS	  	SET MY REGISTERS
	STST R15		STATUS REGISTER
	LI   R13,WSP 	 	FORTRAN'S REGISTERS
	MOV  @6(R13),R3		GET STARTING OFFSET TO DEBUGGER
	MOV  @20(R13),R10   	GET RUNTIME ADDRESS
	MOV  @22(R13),R14   	PC (FROM OLD R11)
	LI   R8,SYMIMG	 	SYMIMG PACKET ADDRESS
	LI   R9,HEXDIG	 	HEX DIGIT POINTER
*
*  SETUP VECTORS (COMPUTE RELOCATABLE ADDRESSES)
*
	LI   R5,INITV1	 	INITIAL VECTORS
	A    R3,R5
INIT1L	EQU  $
	MOV  *R5+,R0		LOCATION START
	JLT  INIT4L	 	BRIF INTO SECOND TABLE
	A    R3,R0	  	ADD OFFSET
	MOV  *R5+,R1		MOVE TO LOCATION
	A    R3,R1
	MOV  R0,*R1	 	SET VALUE
	JMP  INIT1L	 	DO ANOTHER
INIT4L	EQU  $
*
****** PATCH NEXT LOCATION TO A 'JMP AROUND', SO THAT THE DEBUGGER ******
****** CAN BE DEBUGGED USING ANOTHER DEBUGGER!!!!		  ******
*
*	JMP  AROUND
	LI   R0,BINTBX
	A    R3,R0
	LI   R1,>FFF8
	MOV  *R0+,*R1+	 	INTO HIGH RAM
	MOV  *R0+,*R1+
	MOV  *R0+,*R1+
	MOV  *R0,*R1
AROUND	EQU  $
	LI   R0,BPBUFF	 	CLEAR BREAKPOINT BUFFER AND
	LI   R1,TOCLEA		OTHER ASSORTED FLAGS
BPCLER	EQU  $
	CLR  *R0+	   	CLEAR A CELL
	DECT R1
	JNE  BPCLER	 	BRIF MORE
*
	C    @XOPVEC,@XOPVAL(R3)
	JEQ  XOPOK	 	BRIF 1 WORD BREAKPOINTS
	SETO @BPXOP		ELSE, 2 WORD BREAKPOINTS
XOPOK	EQU  $
	BL   @SAVGPL(R3)	SAVE GPL WORKSPACE & MISC FLAGS
	BL   @PRINTI(R3)
	DATA BANNER
*
MONTER	EQU  $
	BL   @PRINTI(R3)
	DATA BLALIN
*
*  MONTOP - MONITOR OPERATION, READ A COMMAND FROM SCREEN.
*
MONTOP	EQU  $
	BL   @PRINTI(R3)
	DATA PROMPT
	BL   @SETTER(R3)
	JEQ  MONTOP	 	BRIF NOTHING SPECIFIED
	LI   R5,TABLE1	 	SEARCH TABLE FOR COMMAND
	A    R3,R5
CMDLOP	EQU  $
	C    *R5,@K0(R3)	END OF TABLE?
	JEQ  CMDERR	 	BRIF YES, ERROR
	CB   *R5,*R6		IS THIS THE COMMAND
	JEQ  CMDJMP	 	BRIF YES
	AI   R5,4	   	ELSE, SKIP TO NEXT
	JMP  CMDLOP
CMDJMP	EQU  $		 	COMMAND RECOGNIZED, JUMP TO COMMAND
	INC  R6			INC TO NEXT BUFFER CHAR
	INC  R5			INC TO # ENTRIES, THIS COMMAND
	CLR  R1
	MOVB *R5+,R1		GET # HEX ENTRIES
	SWPB R1
	MOV  R9,@HEXPTR 	SET HEX POINTER
	CLR  @VDPFLG		CLEAR VDP SPECIFIED FLAG
	CLR  *R8
	MOV  *R5,@PROCTB 	SAVE PROCESS ADDRESS
	MOV  R1,@NOENTR 	NUMBER OF ENTRIES, THIS COMMAND
RHEXLO	EQU  $
	JEQ  RHEXDO	 	BRIF DONE ALL ARGUMENTS
	BL   @RHEX(R3)	 	READ A HEX NUMBER
	JMP  NERROR	 	ERROR RETURN
	SETO R1			NULL RETURN
	MOV  @HEXPTR,R2
	MOV  R0,*R2	 	SAVE HEX NUMBER
	INCT @HEXPTR
	DEC  @NOENTR
	JMP  RHEXLO
RHEXDO	EQU  $
	MOV  @PROCTB,R5 	RESTORE PROCESS ADDRESS
	A    R3,R5	   	+ BASE
	B    *R5		EXECUTE PROCESS
CMDERR	EQU  $		 	UNRECOGNIZED COMMAND
	BL   @PRINTE(R3)
	DATA INVINS
NERROR	EQU  $		 	NUMBER ERROR
	BL   @PRINTE(R3)
	DATA INVNUM
*
*  Q - QUIT
*
*  RETURN TO CALLER.
*
Q	EQU  $
	BL   @RESGPL(R3)	RESTORE GPL WORKSPACE
	MOV  @ERRFLG,R5 	ERROR ENTRY?
	JEQ  Q1			BRIF NO
	B    @CMENU$	  	MENU RETURN IF ERROR
Q1	EQU  $
	RTWP
*
*  M - MEMORY INSPECT/ALTER
*
M	EQU  $
	CB   *R8,@KX6000(R3) 	IS IT A VARIABLE NAME DISPLAY?
	JNE  NOTASY	 	BRIF NO, USE NORMAL DISPLAY
	BL   @MODSYM(R3)	MODIFY SYMBOL NAME (NO RETURN)
NOTASY	EQU  $
	MOV  R9,R6	  	HEX DIGIT POINTER
	MOV  *R6,R5
	ANDI R5,>FFFE		MAKE SURE ITS EVEN
	MOV  R5,*R6+
	MOV  *R6,R5
	JEQ  MALTER	 	BRIF ALTER MODE
*
NEWLIN	EQU  $		 	GET 6 BYTES OF DATA
	DECT R6			POINT TO HEXDIG
	BL   @MSTART(R3)
	DATA CPUFMT
*
	MOV  R8,R1	  	MOVE ALL ITEMS INTO SYMIMG ARRAY
	MOV  *R9,*R1+		MOVE HEX DIGIT TO SYMIMG ARRAY
*
*  GET 3 WORDS INTO SYMIMG ARRAY
*
	MOV  *R6,R0	 	MOVE FROM ADDRESS
	LI   R2,6	   	# BYTES TO MOVE
	MOV  @VDPFLG,R5 	GET VDP FLAG
	JEQ  NOTVDP
	BLWP @CVMBR$	  	READ 6 BYTES
	A    R2,R0	  	UPDATE POINTER
	A    R2,R1
	JMP  PRICOM
*
NOTVDP	EQU  $
	MOV  *R0+,*R1+	 	MOVE A WORD
	DECT R2
	JNE  NOTVDP	 	BRIF MORE
*
PRICOM	EQU  $
	MOV  R8,R4	  	SYMIMG START
	INCT R4
	CLR  R5
	LI   R2,6
STRILO	EQU  $
	MOVB *R4+,R5		GET A BYTE
	JLT  SUBBLA	 	SUBSTITUTE IF NEG
	CI   R5,>1F00
	JGT  NOSUB
SUBBLA	EQU  $
	LI   R5,>2A00		USE AN ASTERICK FOR A NON-PRINTABLE
NOSUB	EQU  $
	MOVB R5,*R1+
	DEC  R2
	JNE  STRILO	 	BR TO DO NEXT CHAR
*
	BL   @MIARRS(R3)
	DATA 14
*
	MOV  *R6,R5	 	INCREMENT HEX DIGIT
	AI   R5,6
	MOV  R5,*R6+
	S    *R6,R5
	JLT  NEWLIN
MEXIT	EQU  $
	B    @MONTOP(R3)
*
MALTER	EQU  $
	BL   @MSTART(R3)	START I/O
	DATA CPUALT
*
	MOV  R8,R1	  	MOVE VALUE TO SYMIMG ARRAY
	MOV  *R9,*R1+		GET ADDRESS
	MOV  *R9,R0
	LI   R2,2	   	# BYTES TO MOVE
	MOV  @VDPFLG,R5 	GET VDP ON/OFF
	JNE  MALTVD
	MOV  *R0,*R1		GET VALUE INTO SYMIMG
	JMP  MALTCO
MALTVD	EQU  $
	BLWP @CVMBR$	  	READ THE VALUES
MALTCO	EQU  $
	BL   @MIARRS(R3)	OUTPUT 2 VALUES
	DATA 4
*
	BL   @SETTER(R3)
	JEQ  MALTIN	 	BRIF NOTHING SPECIFIED
*
	BL   @RHEX(R3)	 	READ A HEX NUMBER
	JMP  MEXIT	  	ERROR RETURN
	JMP  MALTIN	 	INCREMENT AND RETURN
*
	MOV  R0,*R8	 	VALUE TO PUT
	MOV  *R9,R0	 	MOVE TO ADDRESS
	MOV  R8,R1	  	MOVE FROM ADDRESS
	LI   R2,2	   	# BYTES TO MOVE
	MOV  @VDPFLG,R5
	JNE  MOVVDP
	MOV  *R1,*R0		MOVE IT
	JMP  MALTIN
MOVVDP	EQU  $
	BLWP @CVMBW$	  	WRITE IT TO VDP
MALTIN	EQU  $
	INCT *R9		INCREMENT TO NEXT LOCATION
	JMP  MALTER
*
*  W - DISPLAY/ALTER WORKSPACE REGISTERS
*
W	EQU  $
	MOV  *R9,*R8		GET STARTING REGISTER #
*			 	 WAS THIS A NULL ENTRY
	CI   R1,-1	 	 NO, ENTER ALTER MODE
	JNE  WALTER
	MOV  R13,R0	 	MOVE FROM ADDRESS
	MOV  R8,R1	  	MOVE TO ADDRESS
	CLR  R2			COUNTER
WPMOVE	EQU  $
	MOV  R2,*R1+		SAVE REGISTER #
	MOV  *R0+,*R1+	 	MOVE REGISTER VALUE
	INC  R2
	CI   R2,16	  	DONE?
	JNE  WPMOVE	 	BRIF MORE
*
*  WRITE 32 VALUES (16 REGISTER NUMBERS, 16 REGISTER
*		   VALUES )
*
	BL   @MSTART(R3)
	DATA REGALL
*
	BL   @MIARRS(R3)
	DATA 64
*
WEND	EQU  $
	B    @MONTOP(R3)
*
WINCRE	EQU  $
	INC  *R8		INCREMENT REGISTER #
*
WALTER	EQU  $		 	REGISTER ALTER
	MOV  *R8,R6	 	GET REGISTER #
	JLT  WEND
	CI   R6,15	  	AT END?
	JGT  WEND
	SLA  R6,1	  	 * 2
	A    R13,R6
	MOV  *R6,@2(R8)
*
	BL   @MSTART(R3)
	DATA REGONE
*
	BL   @MIARRS(R3)
	DATA 4
*
	BL   @SETTER(R3)
	JEQ  WINCRE
*
	BL   @RHEX(R3)
	JMP  WEND	   	BRIF ERROR
	JMP  WINCRE	 	NULL
	MOV  *R8,R6	 	RECOMPUTE WORKSPACE ADDRESS
	SLA  R6,1	   	( LOST BY RHEX )
	A    R13,R6
	MOV  R0,*R6	 	SET VALUE IN WORKSPACE
	JMP  WINCRE
*
*  T - TRADE SCREEN
*
T	EQU  $
	BL   @RESGPL(R3)	RESTORE GPL WORKSPACE & SCREEN IMAGE
*
TLOOP1	EQU  $
	BLWP @CKSCAN	 	DO UNTIL KEY DEPRESSED
	MOVB @GPLSTA,R1
	ANDI R1,>2000		MASK KEY DEPRESSED BIT
	JEQ  TLOOP1	 	BRIF NOTHING HAPPENED
*
	BL   @SAVGPL(R3)	SAVE GPL WORKSPACE
	JMP  WEND
	TITL 'CONTINUE COMMAND HANDLERS'
*
*  R - REGISTER INSPECT/ALTER
*
R	EQU  $
	STWP R0			MY WORKSPACE ADDRESS
	AI   R0,26	  	+ 26 FOR R13 START
	MOV  R0,*R9
	LI   R5,WP
	MOV  R5,@REGFMT
	LI   R2,3
	MOV  R2,@REGCNT
REGLOP	EQU  $
	MOV  @REGFMT,R5
	BL   @MSTARC(R3)	START I/O (FORMAT ADDRESS IN R5)
*
	MOV  *R9,R5
	MOV  *R5,*R8		MOVE VALUE TO SYMIMG
*
	BL   @MIARRS(R3)	OUTPUT 1 WORD ARRAY
	DATA 2
*
	BL   @SETTER(R3)	PERFORM INPUT FROM SCREEN
	JEQ  NOTHIS		 BRIF NOTHING SPECIFIED
	BL   @RHEX(R3)
	JMP  REGEND	 	BRIF ERROR
	JMP  NOTHIS	 	BRIF NULL
	MOV  *R9,R5
	MOV  R0,*R5	 	SAVE VALUE SPECIFIED
NOTHIS	EQU  $
	INCT *R9
	A    @K15(R3),@REGFMT
	DEC  @REGCNT		DECREMENT REGISTER COUNT
	JNE  REGLOP
REGEND	EQU  $
	B    @MONTOP(R3)	RETURN
*
*  H - HEX ARITHMETIC
*
H	EQU  $
	MOV  R9,R2	  	GET H1, H2
	MOV  *R2+,R1		H1
	MOV  *R2,R6	 	H2
	MOV  R8,R0	  	PUT ALL VALUES IN SYMIMG STACK
	MOV  R1,*R0+	 	H1
	MOV  R6,*R0+	 	H2
	MOV  R1,*R0
	A    R6,*R0+	 	H1+H2
	MOV  R1,*R0
	S    R6,*R0+	 	H1-H2
	MOV  R1,R4
	MPY  R6,R4
	MOV  R4,*R0+	 	H1*H2
	MOV  R5,*R0+
	MOV  R1,R5
	CLR  R4
	DIV  R6,R4
	MOV  R4,*R0+	 	H1/H2
	MOV  R5,*R0+
	MOV  R1,*R0+	 	H1(I)
	MOV  R6,*R0+	 	H2(I)
*
	BL   @MSTART(R3)
	DATA HEXARF
	BL   @MIARRS(R3)	OUTPUT 10 WORDS
	DATA 20
	JMP  REGEND	  	AND RETURN
*
*  BREAKPOINT ENTRIES:
*
*  ENERR   -  ERROR ENTRAANCE (FORTRAN RETURN IN R8)
*  INITBX  -  SINGLE WORD (XOP 1) ENTRY
*  BPX	   -  DOUBLE WORD (BLWP) ENTRY
*
ENERR	EQU  $
	STWP R0			SAVE EXECUTION TIME'S WORKSPACE
	MOV  R0,@ERRWPC  	SAVE OLD WORKSPACE
	MOV  R11,@ERRFLG 	SAVE RETURN
	LWPI MREGS
	STST R15
	LI   R13,WSP 	 	SETUP REGISTERS AS IF BLWP ENTRANCE
	MOV  @ERRWPC,R5 	GET EXECUTION TIME'S POINTER
	MOV  @28(R5),R14	GET OLD R14
	INCT R14		FOR ERROR ENTRANCE
	BL   @SAVGPL(R3)
	JMP  BPXON1
*
INITBX	EQU  $
	BL   @SAVGPL(R3)
	JMP  BPXONT
BPX	EQU  $
	BL   @SAVGPL(R3)
	DECT R14
BPXONT	EQU  $
	CLR  @ERRFLG		SET BREAKPOINT ENTRY
BPXON1	EQU  $
	DECT R14
	MOV  R8,R1
	MOV  R14,*R1+		SAVE BREAKPOINT ADDRESS,
	MOV  R13,*R1+		WORKSPACE POINTER
	MOV  R15,*R1+		& STATUS REGISTER
*
	LI   R5,-10	 	DON'T TRACEBACK MORE THAN 5
	MOV  R5,@BPCNTR
*
	MOV  @ERRFLG,R5 	GET ERROR ENTRANCE
	JEQ  BPXON2	 	BRIF YES, RETURN
	BL   @MSTART(R3)
	DATA ERDISP
	JMP  BPXON3
BPXON2	EQU  $
	BL   @MSTART(R3)
	DATA BPDISP
*
BPXON3	EQU  $
	BL   @MIARRS(R3)	OUTPUT 3 ITEMS
	DATA 6
*
	CLR  @HDRPRT		SET HEADER NOT PRINTED
	MOV  R14,R5	 	GET BREAKPOINT ADDRESS
BPXON4	EQU  $
	BL   @SRCHBP(R3)	SEARCH & PRINT BREAKPOINT ADDRESS
	MOV  @ERRFLG,R5 	GET ERROR ENTRANCE
	JEQ  BPXON5
	MOV  @STASYM,R5 	ANY SYMBOL FILE?
	JEQ  REGEND	 	BRIF NO, NO TRACEBACK
	C    @VALLOC,R5 	FIRST MODULE (MAIN)?
	JEQ  REGEND	 	BRIF YES
	MOV  @HEXPTR,R5 	MODULE START
	MOV  @2(R5),R5	 	GET TEMPS ADDRESS
	MOV  @2(R5),R5	 	GET OLD BASE ADDRESS
	DECT R5			TO ENSURE LINE # FOUND
	INC  @BPCNTR
	JNE  BPXON4	 	BRIF 6 TRACEBACKS NOT PRINTED
	JMP  REGEND
*
BPXON5	EQU  $
	MOVB @MINUS(R3),R1  	PRETEND THIS IS A B- COMMAND
	MOV  R14,R2	 	BREAK POINT ADDRESS TO REMOVE
	JMP  B1			AND DO REMOVE LOGIC
*
*  B - BREAKPOINT INSPECT/ALTER
*
B	EQU  $
	MOV  *R9,R2	 	SPECIFIED BREAKPOINT ADDRESS
B1	EQU  $
	LI   R6,BPBUFF	 	BREAKPOINT BUFFER
	ANDI R2,>FFFE		MAKE EVEN
	JEQ  NOADD	  	BRIF NOTHING SPECIFIED
	MOV  @NUMBPS(R3),R5
BUFSRC	EQU  $
	C    R2,*R6+		IS THIS THE PACKET?
	JEQ  BUFFND	 	BRIF YES
	AI   R6,4	   	ELSE, SKIP TO NEXT PACKET
	DEC  R5
	JNE  BUFSRC
	CB   R1,@MINUS(R3)  	WAS TERMINATION BY MINUS SIGN?
	JNE  BUFADD	 	BRIF NO, ADD BREAKPOINT
	BL   @PRINTE(R3)
	DATA BNOTFN
*
BUFADD	EQU  $		 	ADD A BREAKPOINT
	MOV  @NUMBPS(R3),R5
	LI   R6,BPBUFF	 	FIND A BLANK SLOT IN BREAKPOINT TABLE
BUFSR1	EQU  $
	MOV  *R6,R1	 	IS THIS SLOT FREE?
	JEQ  BUFAD1	 	BRIF YES
	AI   R6,6
	DEC  R5			DO UNTIL FOUND OR PACKETS EXHAUSTED
	JNE  BUFSR1
	BL   @PRINTE(R3)
	DATA BUFFUL
BUFAD1	EQU  $		 	FREE PACKET FOUND
	MOV  R2,*R6+		SAVE ADDRESS IN BUFFER
	MOV  *R2+,*R6+		SAVE 1ST WORD
	MOV  *R2,*R6	 	SAVE 2ND WORD (IF 2 WORD BREAKPOINT)
	DECT R2
	ABS  @BPXOP		2 WORD BREAKPOINTS
	JNE  BUFTWW	 	BRIF YES
	MOV  @XOP1(R3),*R2  	SET BREAKPOINT
BRETUR	EQU  $
	B    @MONTOP(R3)
BUFTWW	EQU  $		 	2 WORD BREAKPOINT
	MOV  @BPINST(R3),*R2+  	SET WORD 1 BREAKPOINT
	MOV  @BPINST+2(R3),*R2
	BL   @PRINTE(R3)
	DATA WARNBP
*
BUFFND	EQU  $
	CB   R1,@MINUS(R3)  	WAS BREAKPOINT TO BE REMOVED?
	JNE  BUFALE	 	BRIF NO, ADD A BREAKPOINT WHICH ALREADY EXISTS
	DECT R6
	CLR  *R6+
	MOV  *R6+,*R2+	 	REMOVE BREAKPOINT
	ABS  @BPXOP		DOES BREAKPOINT USE 2 WORDS?
	JEQ  BRETUR	 	BRIF NO, JUST RETURN
	MOV  *R6+,*R2+	 	RESTORE 2ND WORD
	JMP  BRETUR
BUFALE	EQU  $		 	BREAKPOINT ALREADY EXISTS
	BL   @PRINTE(R3)
	DATA BALEXI
*
NOADD	EQU  $		 	NOT AN ADD
	CB   R1,@MINUS(R3)  	MINUS SIGN TERMINATION?
	JEQ  BPREMO	 	YES, REMOVE ALL BREAKPOINTS
*
*  BPLIST - LIST ACTIVE BREAKPOINTS:
*
BPLIST	EQU  $		 	ELSE, BREAK POINT LIST
	MOV  @NUMBPS(R3),@BPCNTR
	LI   R6,BPBUFF	 	SEARCH BREAKPOINTS
	CLR  @HDRPRT		SET HEADER NOT PRINTED
BPLOOP	EQU  $
	MOV  *R6,R5	 	GET LOCATION
	JEQ  BPOUTL	 	NO, SKIP IT
*			  	SEARCH FOR A LINE # & LABEL PACKET
	BL   @SRCHBP(R3)
*
BPOUTL	EQU  $
	AI   R6,6	   	INCREMENT TO NEXT PACKET
	DEC  @BPCNTR		ANY MORE LEFT?
	JNE  BPLOOP
	JMP  BRETUR
*
BPREMO	EQU  $		 	REMOVE ALL BREAKPOINTS
	LI   R5,BPBUFF
	MOV  @NUMBPS(R3),R6
BPRLOP	EQU  $
	MOV  *R5,R4	 	ANYTHING HERE?
	JNE  BPRLO2	 	BRIF YES
	AI   R5,6
BPRLO1	EQU  $
	DEC  R6
	JNE  BPRLOP	 	BRIF MORE TO DO
	JMP  BRETUR
BPRLO2	EQU  $
	CLR  *R5+	   	CLEAR THE BREAKPOINT BUFFER
	MOV  *R5+,*R4		RESTORE CODE AT ADDRESS
	ABS  @BPXOP		TWO WORD BREAKPOINTS?
	JEQ  BPRLO3	 	BRIF NO
	MOV  *R5+,*R4		ELSE, RESTORE 2ND WORD
	JMP  BPRLO1
BPRLO3	EQU  $
	INCT R5
	JMP  BPRLO1
*
* SRCHBP - SEARCH SYMBOL FILE FOR SPECIFIED BREAKPOINT LOCATION
*
*  THIS SUBROUTINE IS CALLED TO SEARCH THE SYMBOL FILE FOR A SPECIFIED
*  BREAKPOINT LOCATION.  IT PRINTS THE LOCATION, THE MODULE, THE LINE
*  NUMBER, AND THE LABEL OF THE BREAKPOINT.
*
SRCHBP	EQU  $
	MOV  R11,@SYMRET  	SAVE RETURN
	CLR  @STARTA
	MOV  R8,R4	  	BLANK OUTPUT BUFFER
	CLR  *R4+	   	CLEAR LOCATION
	LI   R2,-10
BPBLA1	EQU  $		 	BLANK MODULE NAME
	MOV  @BLANKS(R3),*R4+
	INCT R2
	JNE  BPBLA1
	CLR  *R4+	   	BLANK LINE #
	CLR  *R4+	   	BLANK LABEL #
	CLR  *R4+
	MOV  @STASYM,R0 	ANY SYMBOL FILE?
	JEQ  BPPRIN	 	BRIF NO
BPSRCH	EQU  $
	MOV  R9,R1
	LI   R2,12
VABLAN	EQU  $
	MOV  @BLANKS(R3),*R1+
	DECT R2
	JNE  VABLAN
*
	MOV  R0,@HEXPTR		SAVE SYMBOL VDP RAM LOC
	MOV  R9,R1	  	MOVE SYMBOL TO LOCN
	LI   R2,2
	BLWP @CVMBR$	  	GET SYMBOL
	MOV  *R1,R2	 	GET LENGTH
	JLT  BPPRIN	 	BRIF TERMINATOR (FF)
	ANDI R2,>FF	 	MASK LENGTH
	MOVB *R1,R12		SAVE TYPE
	INCT R0			SKIP PAST SYMBOL HEADER
	BLWP @CVMBR$	 	GET SYMBOL
	A    R2,R0	  	INCREMENT TO NEXT PACKET
	LI   R4,CHKTBL
	A    R3,R4
	CB   R12,*R4+
	JEQ  MODSAV	 	TYPE 40 (MODULE START)
	INCT R4
	CB   R12,*R4+
	JEQ  BPLABE	 	TYPE 61 (LABEL)
	CB   R12,*R4+
	JNE  BPSRCH	 	TYPE 62 (LINE #)
BPLINE	EQU  $
	C    *R1,R5	 	LOCN <
	JGT  LASLIN	 	BRIF YES
	MOV  *R1+,@LINEOF
	MOV  *R1+,@12(R8)   	SAVE LINE #
	JMP  BPSRCH
LASLIN	EQU  $
	SETO @STARTA
	JMP  BPSRCH
BPLABE	EQU  $
	C    R5,*R1+
	JNE  BPSRCH
	MOV  *R1+,@14(R8)
	MOV  *R1+,@16(R8)
	JMP  BPSRCH
MODSAV	EQU  $
	ABS  @STARTA		WAS SYMBOL FOUND
	JNE  BPPRIN	 	BRIF YES
	C    *R1,*R8		PACK LOCN > PREV PACK LOCN?
	JL   BPSRCH
	C    *R1,R5	 	PACK LOCN > WANTED LOCN
	JH   BPSRCH
	MOV  @HEXPTR,@VALLOC
	MOV  R8,R4
	LI   R12,12	 	MOVE PACKET TO SYMIMG
BPMODL	EQU  $
	MOV  *R1+,*R4+
	DECT R12
	JNE  BPMODL
	CLR  *R4+	   	CLEAR LINE # PACKET
	JMP  BPSRCH
*
BPPRIN	EQU  $
	MOV  *R8,@HEXPTR 	SAVE MODULE START ADDRESS
	MOV  R5,*R8	 	SET TRUE LOCATION
	ABS  @HDRPRT		HEADER BEEN PRINTED?
	JNE  BPPRI2	 	BRIF YES
	SETO @HDRPRT
	BL   @PRINTI(R3)
	DATA BPEQAL
*
BPPRI2	EQU  $
	BL   @MSTART(R3)	START I/O
	DATA BPINDV
*
	BLWP *R10		ARRAY I/O
	DATA IARRYI
	DATA SYMIMG
	DATA 14
*
	BLWP *R10		DISPLAY THE FORTRAN LABEL IN I*4
	DATA JSCLRI
	DATA SYMIMG+14
*
	BLWP *R10
	DATA STOPIO
	MOV  @SYMRET,R11
	B    *R11
	TITL 'DEBUGGER SUBROUTINES'
*
*  THIS MODULE CONTAINS THE FOLLOWING SUBROUTINES:
*
*	SAVGPL - SAVE GPL WORKSPACE & OTHER
*	RESGPL - RESTORE GPL WORKSPACE & OTHER
*	RHEX   - READ HEX/INTEGER NUMBERS
*
SAVGPL	EQU  $
	LIMI 0
	MOV  @MENVDP,R6		GET END VDP RAM (FROM MENU)
	AI   R6,-TOTSAV		SAVE START
	LI   R4,SAVTBL	 	SAVE TABLE CELLS
	A    R3,R4
*
SAVOUT	EQU  $
	MOV  *R4+,R5		GET START ADDRESS TO SAVE
	CI   R5,-1	  	TERMINATOR?
	JEQ  SAVEND	 	BRIF YES
	MOV  *R4+,R2		# BYTES TO SAVE
	MOV  R5,R5	  	START ADDRESS TO SAVE
	JLT  SAVCPU	 	IF <0, IN RAM PAD
	CI   R5,>2000		ELSE, IF <2000, IN VPD RAM
	JGT  SAVCPU
SAVVDP	EQU  $
	MOV  R5,R0	  	FROM ADDRESS
	BLWP @CVSBR$	 	 READ A BYTE
	INC  R5
	MOV  R6,R0	 	 TO ADDRESS
	BLWP @CVSBW$
	INC  R6
	DEC  R2
	JNE  SAVVDP	 	BRIF MORE
	JMP  SAVOUT	 	PROCESS NEXT ENTRY
*
SAVCPU	EQU  $
	MOV  R5,R1	  	FROM ADDRESS (CPU RAM)
	MOV  R6,R0	  	TO ADDRESS (VDP RAM)
	BLWP @CVMBW$	  	SAVE IT
	A    R2,R6	 	 UPDATE VDP RAM POINTER
	JMP  SAVOUT	 	PROCESS NEXT ENTRY
*
SAVEND	EQU  $
	CLR  @KEYUNT		KEYBOARD UNIT NUMBER
	B    *R11	   	RETURN
*
RESGPL	EQU  $
	MOV  @MENVDP,R6		GET END VDP RAM
	AI   R6,-TOTSAV		SAVE START
	LI   R4,SAVTBL	 	SAVE TABLE CELLS
	A    R3,R4
*
RESOUT	EQU  $
	MOV  *R4+,R5		GET START ADDRESS TO SAVE
	CI   R5,-1	  	TERMINATOR?
	JEQ  RESEND	 	BRIF YES
	MOV  *R4+,R2		# BYTES TO SAVE
	MOV  R5,R5	  	START ADDRESS TO SAVE
	JLT  RESCPU	 	IF <0, IN RAM PAD
	CI   R5,>2000		ELSE, IF <2000, IN VPD RAM
	JGT  RESCPU
RESVDP	EQU  $
	MOV  R6,R0	  	FROM ADDRESS
	BLWP @CVSBR$	  	READ A BYTE
	INC  R6
	MOV  R5,R0	  	TO ADDRESS
	BLWP @CVSBW$
	INC  R5
	DEC  R2
	JNE  RESVDP	 	BRIF MORE
	JMP  RESOUT	 	PROCESS NEXT ENTRY
*
RESCPU	EQU  $
	MOV  R5,R1	  	FROM ADDRESS (CPU RAM)
	MOV  R6,R0	  	TO ADDRESS (VDP RAM)
	BLWP @CVMBR$	  	RESTORE IT
	A    R2,R6	  	UPDATE VDP RAM POINTER
	JMP  RESOUT	 	PROCESS NEXT ENTRY
*
RESEND	EQU  $
	LIMI 2		 	ELSE, TURN THEM ON
RESEN1	EQU  $
	B    *R11
*
*  RHEX - HEX INPUT
*
*  THIS ROUTINE SCANS THE NEXT (UP TO 4) DIGITS IN THE INPUT
*  BUFFER AND RETURNS THE HEXADECIMAL VALUE IN R0.  UPON
*  TERMINATION THE POINTER TO THE INPUT BUFFER WILL POINT TO
*  THE TERMINATING CHARACTER (IN R6).
*
*  HEXADECIMAL NUMBERS ARE EXPRESSED AS A ONE TO FOUR DIGIT
*  NUMBER.  DECIMAL NUMBERS ARE ALWAYS PRECEDED BY HT LETTER
*  I, AS FOLLOWS:
*
*	ABCD   IS A VALID HEXADECIMAL NUMBER
*	I123   IS A VALID DECIMAL NUMBER
*
*  SYMBOL NAMES CAN BE USED INSTEAD OF THE ACTUAL HEX OR
*  DECIMAL VALUES, AND ARE INDICATED BY A SPECIAL CHARACTER
*  AS FOLLOWS:
*
*	%Line	 - LINE NUMBER
*	*Label	 - STATEMENT LABEL
*	&Name	 - VARIABLE NAME
*
*  IN THESE CASES, THE SYMBOL WILL BE LOOKED UP IN THE CURRENT SYMBOL
*  TABLE, AND THE HEX VALUE FROM THE SYMBOL TABLE WILL BE RETURNED.
*
*  THERE ARE 3 RETURN SPOTS FOR THIS ROUTINE:
*
*	 BLWP @RHEX
*	 JMP  ERRORE	 ERROR RETURN
*	 JMP  NULLRT	 NULL RETURN
*	 JMP  NORMAL	 NORMAL RETURN
*
RHEX	EQU  $
	MOV  R11,@RHEXRT 	SAVE RETURN
	CLR  @SYMFLG		CLEAR SYMBOL FOUND FLAG
	CLR  R0			CLEAR HEX VALUE
	LI   R4,16	  	ASSUME HEX MULTIPLY
RHEX1	EQU  $
	CB   *R6,@HEXTBL(R3) 	TERMINATOR CHAR?
	JEQ  NULLRT
	CB   *R6,@HEXTBL+1(R3) 	SPACE CHARACTER
	JNE  RHEX2	  	BRIF NO
	INC  R6
	JMP  RHEX1	  	TRY ANOTHER CHARACTER
*
RHEX2	EQU  $
	CLR  R1
	MOVB *R6,R1	 	GET CHAR, THIS LOCATION
	LI   R2,HEXTBL
	A    R3,R2
	CB   *R6,*R2+		IS IT A TERMINATOR?
	JEQ  NORMRT	 	BRIF YES, NORMAL RETURN
	INC  R6
	CB   R1,*R2+		IS IT A SPACE?
	JEQ  NORMRT
	CB   R1,*R2+		IS IT A MINUS SIGN?
	JEQ  NORMRT	 	BRIF YES, TERMINATOR
	CB   R1,*R2+		IS IT VDP FLAG?
	JNE  CHECKI	 	BRIF NO, CHECK DIGITS
	SETO @VDPFLG	   	ELSE, SET VDP MEMORY FLAG
	JMP  RHEX2	 	 GO READ ANOTHER CHAR
*
CHECKI	EQU  $
	CB   R1,*R2+		IS IT AN 'I' (FOR INTEGER)
	JNE  CHECKP	 	BRIF NO, CHECK PERCENT SIGN
SETI	EQU  $
	LI   R4,10	  	CHANGE MULTIPLIER TO INTEGER
	MOV  R0,R0	  	HAS A NUMBER ALREADY BEEN SPECIFIED?
	JNE  ERRORT	 	BRIF YES, ERROR
	JMP  RHEX2
CHECKP	EQU  $
	CB   R1,*R2+		IS IT A PERCENT SYMBOL?
	JNE  CHECKT	 	NO, CHECK FOR AN *
	LI   R1,2
	JMP  SETI1
CHECKT	EQU  $
	CB   R1,*R2+		IS IT A LINE NUMBER ?
	JNE  CHECKA	 	NO, CHECK FOR AN &
	LI   R1,1
SETI1	EQU  $
	MOV  R1,@SYMTYP
	INC  @SYMFLG
	JMP  SETI
CHECKA	EQU  $
	CB   R1,*R2+		IS IT AN AMPERSAND?
	JNE  CHECKD
	INC  @SYMFLG
	CLR  @SYMTYP		SET SYMBOL TYPE=0 (NAME)
	BL   @SCANSY(R3)
	JMP  NORMRT
CHECKD	EQU  $
	CB   R1,*R2+		LESS THAN ZERO?
	JLT  ERRORT	 	BRIF YES
	CB   R1,*R2+		LESS THAN OR = TO 9?
	JGT  CHECKN
	SWPB R1
	AI   R1,->30		ADD ZERO OFFSET
	JMP  STORHE
CHECKN	EQU  $
	CI   R4,10	  	DOING INTEGER STUFF?
	JEQ  ERRORT	 	BRIF YES, ERROR
	CB   R1,*R2+		LESS THAN 'A'
	JLT  ERRORT	 	BRIF ERROR
	CB   R1,*R2+
	JGT  ERRORT	 	BRIF ERROR
	SWPB R1
	AI   R1,-55	 	ADD ZERO OFFSET
STORHE	EQU  $
	MOV  R1,R2	  	SAVE RESULT
	MPY  R4,R0	  	PERFORM 16 OR 10 MULTIPLY
	MOV  R0,@OVFFLA 	SET OVERFLOW FLAG
	MOV  R1,R0
	A    R2,R0	  	SAVE NUMBER
	JMP  RHEX2
*
NORMRT	EQU  $		 	NORMAL RETURN
	MOV  R1,@SAVECH 	SAVE CHARACTER
	MOV  @SYMFLG,R5 	SYMBOL TO PROCESS?
	JEQ  NORMR1
	MOV  R8,R4
	MOV  @SYMTYP,R5 	GET SYMBOL TYPE
	CI   R5,1
	JLT  SCANC1
	JGT  SCANLI
SCANLB	EQU  $		 	FORM A LABEL PACKET
	MOV  @KX6106(R3),*R4+
	CLR  *R4+
	MOV  @OVFFLA,*R4+
	MOV  R0,*R4+
	JMP  SCANC1
SCANLI	EQU  $		 	FORM A LINE # PACKET
	MOV  @KX6204(R3),*R4+
	CLR  *R4+
	MOV  R0,*R4+
SCANC1	EQU  $
	BL   @SYMSRC(R3)	SEARCH FOR SYMBOL
	BL   @DISPAC(R3)	DISPLAY PACKET
	MOV  @2(R8),R0	 	GOOD RETURN MEANS FOUND IT
NORMR1	EQU  $
	INCT @RHEXRT		RETURN + 4
*
NULLRT	EQU  $
	INCT @RHEXRT		RETURN + 2
*
ERRORT	EQU  $
	MOV  @SAVECH,R1
	MOV  @RHEXRT,R11
	B    *R11		RETURN + 0
*
*  PRINTI - PRINT A MESSAGE ROUTINE
*  PRINTE - PRINT A MESSAGE, ERROR RETURN
*
PRINTE	EQU  $
	MOV  *R11+,R5
	LI   R11,MONTOP
	A    R3,R11
	JMP  PRINE1
*
PRINTI	EQU  $
	MOV  *R11+,R5		GET MESSAGE ADDRESS
PRINE1	EQU  $
	MOV  R5,@STARFM(R3) 	SAVE FORMAT ADDRESS
*
	BLWP *R10
	DATA BSTARI
	DATA >9800
	DATA CRTOP
STARFM	EQU  $
	DATA 0		 	FORMAT ADDRESS
*
	BLWP *R10
	DATA STOPIO	 	STOP I/O OPERATION
	B    *R11	   	& RETURN
*
*  MSTART - START I/O OPERATION TO CRT GIVEN FORMAT ADDRESS
*
MSTART	EQU  $
	MOV  *R11+,R5		GET MESSAGE ADDRESS
MSTARC	EQU  $			USE FORMAT IN R5 ENTRY
	MOV  R5,@STARF1(R3)
*
	BLWP *R10
	DATA BSTARI
	DATA >9800
	DATA CRTOP
STARF1	EQU  $
	DATA 0		 	FORMAT ADDRESS
	B    *R11	  	RETURN
*
*  MIARRS - DO ARRAY I/O FROM THE SYMIMG ARRAY, AND EXECUTE STOPIO
*	    AT THE END
*
*	    *R11 HAS THE NUMBER OF BYTES TO DISPLAY
*
MIARRS	EQU  $
	MOV  *R11+,@MIBYTE(R3)
	BLWP *R10		EXECUTE ARRAY I/O
	DATA IARRYI		ARRAY I/O
	DATA SYMIMG		FROM SYMIMG ARRAY
MIBYTE	DATA 0			# OF BYTES TO DISPLAY
*
	BLWP *R10		EXECUTE STOP I/O
	DATA STOPIO
	B    *R11		RETURN
*
*  SETTER, PERFORM SCREEN I/O INTO INPUT BUFFER
*
*  ENTRY REGISTERS:     NONE
*  EXIT REGISTERS:      R5 IS # OF BYTES READ
*			R6 IS POINTER TO INPUT BUFFER
*			SR is R5,R5
*
SETTER	EQU  $
*
	BLWP *R10
	DATA BSTARI		BASE START I/O
	DATA >1880		READ
	DATA CRTOP		CRT LABEL
	DATA READFR		FORMAT (READ ASCII)
	DATA MONTER		ERROR ADDRESS
*
	BLWP *R10		READ # OF BYTES READ
	DATA ISCLRI		1 INTEGER *2 SCALAR VARIABLE
	DATA NOCHAR		# OF CHARACTERS
*
	BLWP *R10
	DATA KARRYI		ARRAY I/O
	DATA SCRINB		INPUT BUFFER
	DATA 40			40 BYTES TO READ
*
	BLWP *R10		STOP THE I/O OPERATION
	DATA STOPIO
*
	LI   R5,SCRINB		POINTER TO INPUT BUFFER
	MOV  R5,R6		SAVE FOR EXIT REGISTER
	A    @NOCHAR,R5		 + NUMBER OF CHARACTERS READ
	MOVB @KM1(R3),*R5	TERMINATE STRING
*
	MOV  @NOCHAR,R5		LOAD BYTE COUNT AGAIN
	B    *R11
*
	TITL 'SYMBOL FILE MANIPULATION'
*
*  L - LOAD FILE ROUTINE
*
*	 THIS ROUTINE PROCESSES THE LOAD FILE COMMAND.  IT PROMPTS THE
*	 USER FOR A FILE NAME, READS THE FILE NAME, SETS
*	 UP A PAB, AND READS IN THE FILE.
*
L	EQU  $
	BL   @PRINTI(R3)
	DATA LOAMSG
*
	BL   @SETTER(R3)
	JEQ  BMONTO	 	BRIF NULL ENTRY
*
*  R5 CONTAINS # OF CHARACTERS READ.  FORM USER INPUT BYTE AND
*  SAVE IN PAB.
*
	SWPB R5
	MOVB R5,@SCRINB-1
*
	CLR  @STASYM		RESET SYMBOL FILE POINTERS
	CLR  @SELSYM
*
	LI   R0,VDPLO		LOW END OF VDP RAM
	LI   R1,LOAPAB
	MOV  @LOASHE(R3),*R1+
	MOV  @LOASHE+2(R3),*R1
	DECT R1
	LI   R2,>30
	MOV  @MENVDP,R6		COMPUTE MAXIMUM BYTE COUNT OF
	S    R0,R6	  	- PAB START
	AI   R6,-TOTSAV		- DEBUGGER SAVE AREA
	S    R2,R6	  	- 30 BYTES FOR PAB
	JLT  BERRO2		 NO ROOM FOR PAB
	MOV  R6,@6(R1)	 	SET BYTE COUNT
	BLWP @CVMBW$	 	WRITE PAB TO VDP RAM
	AI   R0,9
	MOV  R0,@DSRPTR		SETUP FOR DSR
	CLR  R0			CLEAR ERROR FLAG RETURNED
	BLWP @CDSRL$		READ IT
	DATA 8
	JNE  ALLOK
	SWPB R0			I/O ERROR, ECHO ERROR #
	INC  R0
	MOV  R0,*R8
*
	BL   @MSTART(R3)	PRINT ERROR W/ERROR #
	DATA IOERR
*
	BL   @MIARRS(R3)	1 ELEMENT
	DATA 2
	JMP  BMONTO
*
ALLOK	EQU  $
	LI   R0,VDPLO+>30
	BLWP @CVSBR$	  	MAKE SURE THIS IS A SYMBOL FILE
	CB   R1,@KX40(R3)
	JNE  BERRO1
	MOV  R0,@STASYM
	MOV  R0,@SELSYM
BMONTO	EQU  $		 	RETURN
	B    @MONTOP(R3)
BERRO1	EQU  $
	BL   @PRINTE(R3)	BAD SYMBOL FILE
	DATA BADSYF
BERRO2	EQU  $		 	NO ROOM FOR SYMBOL FILE
	BL   @PRINTE(R3)
	DATA NOROOM
*
*  S - SELECT SYMBOL ROUTINE
*
*	 THIS ROUTINE IS CALLED TO SELECT A NEW MODULE FOR SYMBOL
*	 FILE PROCESSING.
*
S	EQU  $
	MOV  @STASYM,R5 	ANY SYMBOL TABLE LOADED?
	JNE  S2
S0	EQU  $
	BL   @PRINTE(R3)
	DATA SYMBAD
S2	EQU  $
	SETO @SYMTYP		SET SYMBOL TYPE=SYMBOL NAME
	BL   @SCANSY(R3)	SCAN SYMBOL
	BL   @SYMSRC(R3)	SEARCH FOR SYMBOL'S VALUE
*			  	SET SELECTED MODULE AS START
	MOV  @SYMSAV,@SELSYM
	BL   @DISPAC(R3)
	JMP  BMONTO
*
*  SCANSY -
*
*  THIS ROUTINE SCANS A SYMBOL NAME IN THE INPUT BUFFER, AND RETURNS THE
*  RESULTING SYMBOL IN SYMIMG.  THE STARTING SYMBOL IDENT IS
*  IN R2 ON ENTRY.  R6 POINTS TO THE INPUT BUFFER.
*
SCANSY	EQU  $
	MOV  R8,R2		BLANK SYMBOL NAME
	CLR  *R2+
	CLR  *R2+
	CLR  *R2+
	LI   R1,5		CLEAR 5 WORDS
SCANS1	EQU  $
	MOV  @BLANKS(R3),*R2+	BLANK A WORD
	DEC  R1
	JNE  SCANS1
*
	CLR  R5			MAINTAINS CURRENT CHARACTER
	CLR  @FORTYP		TYPE OF FORMAT TO DISPLAY
	LI   R4,SYMSLS
	A    R3,R4	  	SYMBOL SEARCH LIST ADDRESS
SCANXT	EQU  $
	MOV  R4,R1
	MOVB *R6+,R5		SCAN PAST BLANKS
	CB   R5,*R1+		TERMINATOR ?
	JEQ  BADSYM	 	BRIF YES, ERROR!
	CB   R5,*R1+
	JEQ  SCANXT
	CLR  R0			MAINTAINS BYTE COUNT FOR SYMBOL
*
	MOV  R8,R2	  	R2=SYMIMG+4
	AI   R2,4
	MOV  @SYMTYP,R1 	GET SYMBOL TYPE
	JLT  TYPEC
	INCT R2
TYPEC	EQU  $
	MOVB R5,*R2+		SAVE A CHARACTER
	INC  R0
GETNXT	EQU  $
	MOVB *R6,R5	 	GET LIST ADDRESS
	MOV  R4,R1	  	SYMBOL SEARCH LIST
	CB   R5,*R1+		IS IT TERMINATOR?
	JEQ  SALLOK	 	BRIF YES
	INC  R6
	CB   R5,*R1+		IS IT A BLANK?
	JEQ  SALLOK	 	BRIF YES
	CB   R5,*R1+		IS IT A COMMA?
	JEQ  READTY	 	BRIF YES, READ TYPE
	INC  R0			ELSE, PUT CHARACTER AWAY
	CI   R0,11	  	SYMBOL TOO LONG?
	JEQ  BADSYM
	MOVB R5,*R2+		ELSE, MOVE SYMBOL TO BUFFER
	JMP  GETNXT
READTY	EQU  $
	MOVB *R6+,R5		GET SYMBOL DISPLAY TYPE
	CB   R5,*R1+		IS IT Z (HEX) FORMAT?
	JNE  READR1	 	BRIF NO
	INC  @FORTYP
	JMP  SALLOK
READR1	EQU  $
	CB   R5,*R1	 	IS IT A (ALPHA)?
	JNE  BADSYM
	INCT @FORTYP
*
*  SYMBOL HAS BEEN PLACED INTO SYMIMG ARRAY.  PAD ONE LAST BLANK, AND
*  COMPUTE "EVEN BYTE COUNT" FOR SYMBOL.
*
SALLOK	EQU  $		 	PAD SYMBOL W/BLANKS
	MOVB @BLANKS(R3),*R2+	SET LAST BLANK
	ANDI R2,>FFFE		MAKE ENDING ADDRESS EVEN
	S    R8,R2		START - END
	AI   R2,-2		 -2 2 FOR HEADER WORD
*
	MOV  @SYMTYP,R5 	REGET SYMBOL TYPE
	JEQ  SALLO2
	MOVB @KX40(R3),R2	SET MODULE START
	JMP  SALLO3
*
SALLO2	EQU  $
	MOVB @KX60(R3),R2	SET VARIABLE NAME
*
SALLO3	EQU  $
	MOV  R2,*R8		SET MODULE TYPE & LENGTH
	CLR  @2(R8)		CLEAR START ADDRESS
	B    *R11	   	RETURN (DONE)
*
*  BAD SYMBOL SPECIFICATION ERROR EXIT
*
BADSYM	EQU  $		 	INVALID SYMBOL SPECIFICATION
	BL   @PRINTE(R3)
	DATA INVSPE
*
*  SYMSRC -
*
*  THIS ROUTINE SCANS THE SYMBOL TABLE, GIVEN A UNIQUE SYMBOL NAME
*  IN THE SYMBOL IMAGE "SYMIMG".
*
*  SPECIAL LOGIC IN THIS ROUTINE INCLUDES:
*
*  1. FOR LINE NUMBER SEARCHES, THE PACKET IS CONSIDERED FOUND
*	IF A PACKET WITH A LINE NUMBER GREATER THAN OR EQUAL TO
*	THE REQUESTED LINE NUMBER IS FOUND.
*
*  2. FOR VARIABLE NAME SEARCHES, THE LOCAL SELECTED SYMBOL AREA
*	IS FIRST SEARCHED.  IF THE VARIABLE NAME IS NOT FOUND, THEN
*	THE COMMON AREA VARIABLES LOCATED IN THE MAIN PROGRAM MODULE
*	AREA ARE SEARCHED.
*
*  3. A SEARCH ERROR WILL CAUSE AN AUTOMATIC ABORT (ERROR MSG AND
*	BACK TO COMMAND MODE).
*
SYMSRC	EQU  $
	MOV  R11,@SYMRET 	SAVE RETURN
	MOV  R6,@SCRSAV 	SAVE OLD R6 (INPUT BUFFER POINTER)
	MOV  @STASYM,R5 	ANY SYMBOL TABLE LOADED?
	JEQ  S0			BRIF NO, ERROR
	CLR  @COMSRC		RESET SEARCHED COMMON FLAG
	CB   *R8,@KX4000(R3) 	GET SYMBOL TYPE
	JNE  USEMOD
	MOV  @STASYM,R0 	ELSE, TOTAL SEARCH
	JMP  NXTSYM
USEMOD	EQU  $
	MOV  @SELSYM,R0
USEMO1	EQU  $
	CLR  R1			SKIP PAST FIRST IDENT
	INC  R0			PACKET
	BLWP @CVSBR$
	INC  R0
	SWPB R1
	A    R1,R0
*
*  ATTEMPT TO GET A SYMBOL FROM VDP RAM
*
NXTSYM	EQU  $
	CLR  R1
	MOV  R0,@SYMSAV		SAVE STARTING SYMBOL ADDRESS (VDP RAM)
	BLWP @CVSBR$	  	READ A SYMBOL START
	MOV  R1,R5	  	SET SYMBOL TYPE
	INC  R0
	BLWP @CVSBR$
	INC  R0			SYMBOL LENGTH
	MOV  R1,R2
	SWPB R2
	A    R2,R5		SET LENGTH
*
*  LOOK AT SYMBOL TYPE, IF THE SAME AS I AM LOOKING FOR,
*  LOOK AT SOME MORE.  IF NOT, CHECK IF BUMPED INTO NEXT
*  SYMBOL START.
*
	C    R5,*R8		DOES TYPE & LENGTH MATCH?
	JEQ  LOOKSO		BRIF YES
*
*  FOLLOWING DOES ADDITIONAL CHECKS TO LOOK AT PROPER EXIT SEQUENCE.
*
LOOKS0	EQU  $
	A    R2,R0	  	BUMP TO NEXT PACKET
*
	CB   R5,@KM1(R3)	IS THIS A TERMINATOR?
	JEQ  NOTSFN		BRIF YES, TERMINATE SEARCH
*
	CB   R5,@KX4000(R3)	DID I FIND NEW MODULE START?
	JNE  NXTSYM		BRIF NO, TRY AGAIN
*
*  NEW MODULE START DETECTED.  IF I AM SEARCHING FOR A MODULE NAME
*  (>40), THEN CONTINUE.  ELSE, TERMINATE.
*
	CB   *R8,@KX4000(R3)	AM I SEARCHING FOR A MODULE START?
	JEQ  NXTSYM		BRIF YES, CONTINUE
	JMP  NOTSFN		ELSE, EXIT
*
*  THIS SYMBOL PACKET IS THE SAME LENGTH AND TYPE I AM LOOKING FOR.
*  EXTRACT THE LOCATION AND OPTIONALLY THE LOCATION CODE & TYPE (FOR
*  VARIABLE NAMES), AND MOVE THE INFO TO MY SYMIMG PACKET.
*
*  NOTE:  AT THIS POINT,   R5 HAS 1ST TWO BYTES OF SYMBOL IN SYMBOL TABLE
*			   R8 POINTS TO SYMIMG (AS ALWAYS)
*
LOOKSO	EQU  $
*
	MOV  R8,R4		GET THE SYMIMG START
	INCT R4
	BL   @GET2(R3)
	CB   R5,@KX6000(R3)	FOUND A VARIABLE NAME?
	JNE  LOOKS1		BRIF NO, ONLY LOCATION (NO 2ND WORD)
	BL   @GET2(R3)
LOOKS1	EQU  $		 	DO BYTE FOR BYTE COMPARE
	BLWP @CVSBR$	  	GET NEXT BYTE
	CB   *R4+,R1		ARE THEY THE SAME?
	JNE  LOOKS2	 	DIFFERENT, SKIP TO NEXT PACKET
	INC  R0
	DEC  R2
	JNE  LOOKS1	 	BRIF MORE TO GO
*
*  SYMBOL NAME MATCHED.  IF THIS IS A VARIABLE NAME SEARCH, THEN
*  MAKE SURE THAT THIS VARIABLE IS IN COMMON.   IF NOT, EXIT SEARCH.
*
	ABS  @COMSRC		COMMON SEARCH IN PROGRESS?
	JEQ  FNDSYM		BRIF NO, SYMBOL WAS FOUND
*				ELSE, COMMON SEARCH WAS IN PROGRESS
	MOV  @4(R8),R1
	ANDI R1,>FF00		MASK AREA CODE
	JNE  NOTSFN	 	IF NOT A COMMON VARIABLE, END OF SEARCH
*				 (SINCE COMMON VARIABLES ARE ALWAYS FIRST)
	JMP  FNDSYM		SYMBOL WAS FOUND
*
*  SYMBOL VALUE FAILED.  SKIP TO NEXT PACKET.  IF SEARCHING FOR A LINE
*  NUMBER PACKET, THEN IF THIS PACKET FROM SYMBOL TABLE IS GREATER THEN
*  WHAT I AM SEARCHING FOR, GO BACK TO LAST PACKET.
*
LOOKS2	EQU  $
	A    R2,R0	  	SKIP TO NEXT PACKET
	CB   @KX6200(R3),*R8
	JNE  NXTSYM	 	BRIF NOT A LINE NUMBER PACKET SEEK
	DECT R0
	BLWP @CVSBR$	  	GET THE LINE NUMBER AGAIN
	SWPB R1
	INC  R0
	BLWP @CVSBR$
	SWPB R1
	INC  R0
	C    R1,@4(R8)
	JLT  NXTSYM
	MOV  R1,@4(R8)	 	PRETEND THIS WAS THE SYMBOL WANTED
FNDSYM	EQU  $
	MOV  @SYMRET,R11	RETURN LEVEL SAVE
	MOV  @SCRSAV,R6  	RESTORE OLD R6 (INPUT BUFFER POINTER)
	B    *R11
*
*  THIS CODE IS CALLED WHEN A TERMINATOR IS SEEN OR A NEW MODULE HEADER
*  IS SEEN ON A SYMBOL FILE SEARCH.  IT CHECKS IF COMMON HAS BEEN SEARCHED.
*  IF NOT, THEN IT RESETS THE POINTER TO THE BEGINNING OF THE SYMBOL FILE,
*  AND EXECUTES ONE MORE SEARCH TO SEE IF THE VARIABLE CAN BE FOUND.
*
NOTSFN	EQU  $
	ABS  @COMSRC		SEARCHED COMMON?
	JNE  NOTSF1	 	BRIF YES, FORGET IT
	CB   *R8,@KX6000(R3)
	JNE  NOTSF1	 	BRIF NOT SEARCHING VARIABLE NAME
	SETO @COMSRC		SET SEARCHING COMMON
	MOV  @STASYM,R0 	SET SYMBOL IMAGE START
	JMP  USEMO1	 	RE-SEARCH FIRST MODULE
NOTSF1	EQU  $
	BL   @PRINTE(R3)
	DATA NOTFND
*
*  GET2 - GET 2 BYTES FROM VDP RAM INTO SYMIMG
*
GET2	EQU  $
	BLWP @CVSBR$
	MOVB R1,*R4+
	INC  R0
	BLWP @CVSBR$
	MOVB R1,*R4+
	INC  R0
	DECT R2
	B    *R11
*
*  DISPAC - DISPLAY PACKET IN SYMIMG.  EACH PACKET IS DISPLAYED
*	    ACCORDING TO TYPE.  THE VALUE AND THE LOCATION OF
*	    THE SELECTED PACKET IS DISPLAYED.
*
DISPAC	EQU  $
	MOV  R11,@DISPRT
	LI   R5,CHKTBL+2
	A    R3,R5
	CB   *R8,*R5+		IS IT A TYPE 60?
	JEQ  DISPR0
	CB   *R8,*R5+		IS IT A TYPE 61?
	JEQ  DISPR1
	CB   *R8,*R5+		IS IT A TYPE 62?
	JEQ  DISPR2
*			  	TYPE 40 PACKET (START OF NEW MODULE)
	BL   @MSTART(R3)
	DATA TYPE4F
*
	BLWP *R10		DISPLAY 10 BYTES
	DATA IARRYI
	DATA SYMIMG+4
	DATA 10
*
	JMP  TAIL
*
DISPR0	EQU  $		 	60 - VARIABLE
	BL   @MSTART(R3)
	DATA TYPE4F
*
	BLWP *R10
	DATA IARRYI
	DATA SYMIMG+6
	DATA 10
	JMP  TAIL
*
DISPR1	EQU  $		 	61 - LABEL PACKET
	BL   @MSTART(R3)
	DATA TYPE61
*
	BLWP *R10		DISPLAY THE PROGRAM LABEL *XXXXX
	DATA JSCLRI
	DATA SYMIMG+4
	JMP  TAIL
*
DISPR2	EQU  $		 	62 - LINE NUMBER
	BL   @MSTART(R3)
	DATA TYPE62
*
	BLWP *R10		DISPLAY THE LINE NUMBER %XXXX
	DATA ISCLRI
	DATA SYMIMG+4
*
TAIL	EQU  $			DISPLAY THE LOCATION @XXXX
	BLWP *R10
	DATA ISCLRI
	DATA SYMIMG+2
*
	BLWP *R10
	DATA STOPIO	 	STOP I/O OPERATION
*
	MOV  @DISPRT,R11
	B    *R11
	TITL 'MODIFY VIA SYMBOL NAME'
*
*  MODSYM - MODIFY VIA SYMBOL NAME
*
*  THIS ROUTINE PROCESSES MODIFICATIONS WHICH ARE SPECIFIED BY SYMBOL
*  NAME.  THE SYMBOL IS PROCESSED ACCORDING TO ITS TYPE.
*
MODSYM	EQU  $
*
*  DISPLAY SYMBOL LOCATION, AND NAME
*
	LI   R1,1	   	SUBSCRIPT 1
	MOV  R1,@VALLOC
DISLOP	EQU  $
*
*  THE USER HAS SPECIFIED DISPLAY/MODIFICATION IN Z OR A FORMAT.
*  CALL THE CORRECT FORMAT GIVEN THE VARIABLE LENGTH.
*
	MOV  @4(R8),R2		GET VARIABLE TYPE
	ANDI R2,>7
	MOV  R2,R5		FORM SCALAR I/O TYPE FOR READ/WRITE
	MOV  R2,R7
	SWPB R5
	AI   R5,SCLRIO
	MOV  R5,@FMTSCL(R3)	SAVE IN WRITE REQUEST LIST
	MOV  R5,@FMTFMR(R3)	SAVE IN READ REQUEST LIST
*
	SLA  R2,1		 *2 (0,2,4,6,8...)
*
	MOV  @FORTYP,R6		GET FORMAT TYPE (0=NORMAL,1=HEX,2=ALPHA)
	MOV  R6,R5		SAVE IT
	SLA  R6,4		OFFSET BY TYPE OF DISPLAY
	A    R2,R6		OFFSET INTO FORMAT TABLE ARRAY
	A    R3,R6		 + BASE OFFSET OF PROGRAM
*
	A    R3,R7
	MOVB @VARLEN(R7),R7	GET VARIABLE LENGTH
	SWPB R7
	ANDI R7,>FF
*
*  DISPLAY THE VARIABLE NAME AND INDEX
*
	BL   @MSTART(R3)
	DATA SYMDIS
*
	BLWP *R10
	DATA IARRYI
	DATA SYMIMG+6
	DATA 10
*
	BLWP *R10
	DATA ISCLRI
	DATA VALLOC
*
	BLWP *R10
	DATA STOPIO		STOP THE I/O OPERATION
*
	MOV  @FMTWRI(R6),R5	GET FORMAT STATEMENT ADDRESS
	BL   @MSTARC(R3)
*
*  GET VALUE OF VARIABLE (MOVE 8 WORDS TO BE SAFE)
*
	MOV  @2(R8),R0		MOVE FROM LOCATION
	MOV  R9,R1		MOVE TO LOCATION
	MOV  R7,R2		MOVE # OF BYTES IN VARIABLE
MOVLOP	EQU  $
	MOVB *R0+,R5		GET A BYTE
	C    @FORTYP,@K2(R3)	IS THIS DISPLAY ALPHA?
	JNE  MOVLO1		BRIF NO, MOVE THE BYTE
	MOVB R5,R5
	JLT  MOVLO0		IF <0, SUBSTITUTE BYTE
	CB   R5,@BLANKS(R3)
	JGT  MOVLO1
MOVLO0	EQU  $
	MOVB @BLANKS(R3),R5	SUBSTITUTE A BLANK
MOVLO1	EQU  $
	MOVB R5,*R1+
	DEC  R2
	JNE  MOVLOP
*
	BLWP *R10
FMTSCL	EQU  $
	DATA 0			TYPE OF LOAD
	DATA HEXDIG
*
	BLWP *R10
	DATA STOPIO		STOP I/O OPERATION
*
	MOV  @FMTREA(R6),@REATMR(R3)
	BLWP *R10	 	NOW START AN I/O OPERATION
	DATA BSTARI		START I/O OPERATION
	DATA >1880		READ
	DATA CRTOP		VIA CRT
REATMR	EQU  $
	DATA 0			VIA READ FORMAT
	DATA ERREXI		ERROR EXIT
*
	BLWP *R10
FMTFMR	EQU  $
	DATA 0			TYPE OF VARIABLE TO READ
	DATA HEXDIG		LOCATION TO READ
*
	BLWP *R10	   	STOP THE I/O OPERATION
	DATA STOPIO
*			(NOTE: EXCTIME RETURNS STATUS OF # OF BYTES READ)
	JEQ  FMRSET	 	BRIF NOTHING SPECIFIED
*			  	SAVE VALUE RETURNED
	MOV  @2(R8),R0	 	MOVE TO ADDRESS
	MOV  R9,R1		MOVE FROM ADDRESS
	MOV  R7,R2		# OF BYTES TO MOVE
*
FMRLOP	EQU  $
	MOVB *R1+,*R0+		MOVE A VALUE
	DEC  R2
	JNE  FMRLOP
*
*  THIS VARIABLE IS DONE.  SET UP FOR NEXT VARIABLE
*
FMRSET	EQU  $
	INC  @VALLOC		INCREMENT LOCATION & OFFSET
	A    R7,@2(R8)		BUMP LOCATION ON VARIABLE
*
*  LOOK AT NEXT PACKET IN SYMBOL TABLE.  IF IT MATCHES THIS LOCATION,
*  LOAD THE NEW SYMBOL.
*
	MOV  @SYMSAV,R0 	GET OLD POINTER
	CLR  R1
	INC  R0
	BLWP @CVSBR$	  	GET LENGTH OF PACKET
	SWPB R1
	A    R1,R0	  	ADD TO START OF THIS PACKET (+2)
	INC  R0			R0 NOW POINTS TO NEXT PACKET
	MOV  R9,R1
	LI   R2,4	   	GET 4 BYTES
	BLWP @CVMBR$
	CB   *R1,@KX6000(R3) 	IS THIS A VARIABLE PACKET?
	JNE  DISLOP	 	BRIF NO
	C    @2(R8),@2(R1)
	JNE  DISLOP	 	BRIF LOCATIONS DIFFERENT
	MOV  R0,@SYMSAV
	MOV  *R1,R2	 	MOVE SYMBOL TO LOCAL
	ANDI R2,>00FF
	INCT R2
	MOV  R8,R1
	BLWP @CVMBR$	  	READ IT
	A    R2,R1
MODLOP	EQU  $		 	PAD REMAINDER OF SYMBOL W/BLANKS
	CI   R2,13
	JGT  CALMOD	 	BRIF DONE
	MOVB @BLANKS(R3),*R1+
	INC  R2
	JMP  MODLOP
CALMOD	EQU  $
	BL   @MODSYM(R3)	NEW SYMBOL
*
ERREXI	EQU  $
	BLWP *R10
	DATA STOPIO
	B    @MONTER(R3)
*
*  OFFSETS TO FORMAT STATEMENT FOR EACH VARIABLE TYPE (READ & WRITE;
*  NORMAL DISPLAY, HEX DISPLAY, OR ALPHA DISPLAY)
*
FMTWRI	EQU  $
	DATA INTDI2		I*2
	DATA INTDI1		I*1
	DATA INTDI4		I*4
	DATA INTDR4		R*4
	DATA INTDR8		R*8
	DATA INTDC8		C*8
	DATA INTD16		C*16
	DATA INTDL2		L*2
*
	DATA HEXDI2		I*2
	DATA HEXDI1		I*1
	DATA HEXDI4		I*4
	DATA HEXDI4		R*4
	DATA HEXDI8		R*8
	DATA HEXDI8		C*8
	DATA HEXD16		C*16
	DATA HEXDI2		L*2
*
	DATA ALPDI2		I*2
	DATA ALPDI1		I*1
	DATA ALPDI4		I*4
	DATA ALPDI4		R*4
	DATA ALPDI8		R*8
	DATA ALPDI8		C*8
	DATA ALPD16		C*16
	DATA ALPDI2		L*2
*
FMTREA	EQU  $
	DATA INTRI1		I*2
	DATA INTRI1		I*1
	DATA INTRI1		I*4
	DATA INTRR8		R*4
	DATA INTRR8		R*8
	DATA INTCM8		C*8
	DATA INTCM8		C*16
	DATA INTRL2		L*2
*
	DATA HEXRI2		I*2
	DATA HEXRI1		I*1
	DATA HEXRI4		I*4
	DATA HEXRI4		R*4
	DATA HEXRI8		R*8
	DATA HEXRI8		C*8
	DATA HEXC16		C*16
	DATA HEXRI2		L*2
*
	DATA ALPRI2		I*2
	DATA ALPRI1		I*1
	DATA ALPRI4		I*4
	DATA ALPRI4		R*4
	DATA ALPRI8		R*8
	DATA ALPRI8		C*8
	DATA ALPC16		C*16
	DATA ALPRI2		L*2
*
FDEBUE	EQU  $
*
*  ZERO CLEARED DATA AREA:
*
	EVEN
	DORG >FF00		PLACE IN HIGH RAM
*
BPBUFF	BSS  NOBPS*6		SAVE AREA FOR BREAKPOINTS
BPXOP	BSS  2			BREAKPOINT USES XOP(0) OR NOT(-1)
ERRFLG	BSS  2			ERROR ENTRANCE OR NOT FLAG
ERRWPC	BSS  2			ERROR ENTRANCE WORKSPACE POINTER
STASYM	BSS  2			STARTING SYMBOL ADDRESS (MAIN PROGRAM)
SELSYM	BSS  2			SELECTED SYMBOL ADDRESS (THIS MODULE)
OVFFLA	BSS  2			NUMBER OVERFLOW FLAG
TOCLEA	EQU  OVFFLA-BPBUFF+2	# OF BYTES TO CLEAR
*
*  NON-CLEARED DATA AREA:
*
SYMIMG	BSS  20			SYMBOL IMAGE
HEXDIG	BSS  10			HEX DIGITS (UP TO 3 NUMBERS)
VDPFLG	BSS  2			'V' SPECIFIED OR NOT
SYMFLG	BSS  2			SYMBOL ENCOUNTERED FLAG
SYMTYP	BSS  2			SYMBOL TYPE (-1=IDT,0=NAME,1=LABEL,2=LINE)
FORTYP	BSS  2			FORMAT TYPE (0=NORM, 1=HEX, 2=ALPHA)
SYMRET	BSS  2			RETURN LEVEL SAVE FOR SYMSRC
PROCTB	BSS  2			PROCESS TABLE BRANCH ADDRESS
VALLOC	BSS  2			VARIABLE'S RELATIVE LOCATION
RHEXRT	BSS  2			RHEX RETURN
REGFMT	BSS  2			REGISTER FORMAT ADDRESS
REGCNT	BSS  2			REGISTER COUNT
BPCNTR	BSS  2			BREAKPOINT COUNTER
COMSRC	BSS  2			COMMON SEARCH FLAG
NOENTR	BSS  2			NUMBER ENTRIES IN COMMAND
DISPRT	BSS  2			DISPAC RETURN LEVEL SAVE
HEXPTR	BSS  2			POINTER TO HEXDIG
SCRSAV	BSS  2			SCREEN POINTER SAVE
SYMSAV	BSS  2			SYMBOL POINTER (VDP RAM)
HDRPRT	BSS  2			BREAKPOINT HEADER HAS BEEN PRINTED FLAG
LINEOF	BSS  2			LINE END OF FILE
STARTA	BSS  2			START MODULE ADDRESS
SAVECH	BSS  2			CHARACTER SAVE (NOT OVERWRITTEN BY SYMBOL)
NOCHAR	BSS  2			NUMBER OF CHARS IN INPUT BUFFER
ENDDBD	EQU  $			END OF DATA AREA
*
*  PAB FOR SYMBOL FILE LOAD:
*
LOAPAB	EQU  $
	DATA >0500		FUNCTION = LOAD
	DATA VDPLO+>30		ADDRESS START
	DATA 0
	DATA 0			MAXIMUM BYTE COUNT
	BYTE 0
	BYTE 0			FILE NAME LENGTH BYTE
SCRINB	EQU  $			SCREEN INPUT BUFFER
	BSS  40   		& FILE
*
	EVEN
	DORG >FFD8
MREGS	EQU  $
	BSS  32			MY REGISTERS (MUST BE @FFD8 FOR XOP 1)
ENDDAT	EQU  $
	EVEN
	END
