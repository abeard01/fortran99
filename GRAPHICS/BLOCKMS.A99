	TITL 'DO BLOCK MOVE'
	IDT  'BLOCKM'
*
*  BLOCKM   :    PERFORM BLOCK MOVE, HIGH SPEED AND LOGICAL
*
*  CALLING SEQUENCE:
*
*       CALL HBLKMV ( IROWS, ICOLS, IROWD, ICOLD, NOROW, NOCOL,
*		      ICOLOR )
*	CALL HBLKCP ( IROWS, ICOLS, IROWD, ICOLD, NOROW, NOCOL )
*	CALL LBLKMV ( IROWS, ICOLS, IROWD, ICOLD, NOROW, NOCOL,
*		      ICOLOR,  ILOGIC )
*	CALL LBLKCP ( IROWS, ICOLS, IROWD, ICOLD, NOROW, NOCOL,
*		      ILOGIC )
*
*  WHERE:
*
*	IROWS   :  IS THE ROW NUMBER OF THE UPPER LEFT CORNER OF SOURCE
*	ICOLS   :  IS THE COLUMN NUMBER OF THE UPPER LEFT CORNER OF SOURCE
*	IROWD   :  IS THE ROW NUMBER OF THE UPPER LEFT CORNER OF DESTINATION
*	ICOLD   :  IS THE COLUMN NUMBER OF THE UPPER RIGHT CORNER OF DESTINATION
*	NOROW   :  IS THE NUMBER OF ROWS
*	NOCOL   :  IS THE NUMBER OF COLUMNS
*	ICOLOR  :  IS THE COLOR TO RENDER THE PIXELS BLANKED
*	ILOGIC  :  IS THE LOGIC OPERATION TO PERFORM ON DESTINATION
*
*  COPYRIGHT 1988 BY LGMA PRODUCTS
*
*  UPDATE HISTORY:
*
*    VERSION 4.1   02-OCT-88    MDOS VERSION
*                  18-NOV-88    FIXES APPLIED
*                  06-Jun-89    Added write to register #45 to set delta
*                               x and delta y direction.
*
	DEF  HBLKMV		HORIZANTAL BLOCK MOVE
	DEF  HBLKCP		HORIZANTAL BLOCK COPY
	DEF  LBLKMV		LEFT BLOCK MOVE
	DEF  LBLKCP		LEFT BLOCK COPY
*
	COPY "FORTPAR:"
	UNL
	COPY "EQUATES:VID.EQ9"
	COPY "EQUATES:FORTEX.EQ9"
	LIST
*
HBLKMV	EQU  $
	DATA -7			7 ARGUMENTS
	DATA BASEAD
	LI   R0,>00C0		9938 HMMV OPCODE
	CLR  R1			NO LOGIC OPERATION
	MOV  @COLOR,R2		GET COLOR CODE
	MOV  *R2,R2
	JMP  HCOMMO
*
HBLKCP	EQU  $
	DATA -6			6 ARGUMENTS
	DATA BASEAD
	LI   R0,>00D0		9938 HMMM OPCODE
	CLR  R1			NO LOGIC OPERATION
	CLR  R2			NO COLOR OPERATION
	JMP  HCOMMO
*
LBLKMV	EQU  $
	DATA -8			8 ARGUMENTS
	DATA BASEAD
	LI   R0,>0080		9938 LMMV OPCODE
	MOV  @LOGIC,R1		GET LOGIC OPERATION
	MOV  *R1,R1
	MOV  @COLOR,R2		GET COLOR CODE
	MOV  *R2,R2
	JMP  HCOMMO
*
LBLKCP	EQU  $
	DATA -7			7 ARGUMENTS
	DATA BASEAD
	LI   R0,>0090		9938 LMMM OPCODE
	MOV  @COLOR,R1		FOR THIS OPCODE, LOGIC IS IN COLOR
	MOV  *R1,R1
	CLR  R2			NO COLOR
*
HCOMMO	EQU  $
	ANDI R1,>F		MASK LOGIC OPERATION
	SOC  R1,R0		PUT IN OPCODE
	MOV  R0,@COMMAN		SAVE IT AS COMMAND CODE
*
	MOV  R2,@COLOR		SET COLOR CODE
*
	LI   R12,ARGTBL		ADDRESS OF ARRAY
	LI   R9,BASEAD+4	START OF ARGUMENTS
	LIMI 0			DISABLE INTERRUPTS
*
ARGCHK	EQU  $			CHECK ARGUMENT AND SET REGISTER LOOP
	MOV  *R9+,R5		GET NEXT ARGUMENT ADDRESS
	MOV  *R12+,R3		GET ARGUMENT HIGH END VALUE
	JEQ  ARGDON		BRIF DONE
	MOV  *R12+,R4		GET ERROR VALUE
	MOV  *R12+,R1		GET REGISTER NUMBER
	MOV  R5,R5		IS ARGUMENT SPECIFIED?
	JEQ  BADARG		BRIF NO, GEN ERROR
	MOV  *R5,R5		GET VALUE
	JLT  BADARG		BRIF <0, BAD ARGUMENT
	C    R5,R3		PAST END OF ARGUMENT
	JGT  BADARG		BRIF YES, BAD ARGUMENT
	MOV  R5,R2		SET VALUE FOR REGISTER
	LI   R0,VVWTR		WRITE THE REGISTER
	XOP  @DVIDXP,0		DO IT
	SWPB R2			PUT IN HIGH END VALUE
	INC  R1			INCREMENT TO NEXT REGISTER NUMBER
	XOP  @DVIDXP,0
	JMP  ARGCHK
*
*  BADARG - BAD ARGUMENT WAS DETECTED.  DISPLAY ERROR CODE & EXIT
*
BADARG	EQU  $
	LIMI 2			RESTORE INTERRUPTS
	MOV  R4,@ERRCOD		SET ERROR CODE
	BLWP *R10
	DATA ERROR
ERRCOD	DATA 0
	JMP  ERREXI
*
*  DONE WITH BASIC ARGUMENT TRANSFER LOOP.  NOW HANDLE THE COLOR BYTE
*  IF NEEDED.
*
ARGDON	EQU  $
	MOV  @COLOR,R2		GET COLOR BYTE
	LI   R0,VVWTR
	LI   R1,44		REGISTER 44 IS COLOR REGISTER
	XOP  @DVIDXP,0
*
*  DETERMINE THE DIX AND DIY DIRECTIONS
*
	CLR  R5			Y DIRECTION
	CLR  R6
	MOV  @DY,R2		GET DESTINATION Y CODE
	S    @SY,R2		SUBTRACT SOURCE Y CODE
	JGT  YOKC		BRIF MOVING DOWN
	JEQ  YOKC
	LI   R5,>0008		ELSE, MOVING UP
YOKC	EQU  $
	MOV  @DX,R2
	S    @SX,R2
	JGT  XOKC		BRIF MOVING RIGHT
	JEQ  XOKC
	LI   R6,>0004		ELSE, MOVING LEFT
XOKC	EQU  $
	MOV  R5,R2
	SOC  R6,R2		OR TOGETHER BITS
	LI   R0,VVWTR
	LI   R1,45		REGISTER 45 - ARGUMENT REGISTER
	XOP  @DVIDXP,0		DO IT
*
*  EVERYTHING IS SET.  EXECUTE THE COMMAND BY STUFFING COMMAND CODE
*
	LI   R0,VVWTR
	LI   R1,46		COMMAND REGISTER
	MOV  @COMMAN,R2		GET COMMAND
	XOP  @DVIDXP,0		DO IT
*
ERREXI	EQU  $
	LIMI 2			ENABLE INTERRUPTS
	MOV  @BASEAD,R3		RESTORE BASE ADDRESS
	B    *R11		RETURN
*
*
*  ARGTBL : TABLE OF ALLOWABLE VALUES, ERROR TEXT IF NOT IN RANGE,
*	    AND 9938 REGISTER # ARG GOES TO.
*
*           THERE ARE TWO TABLES, BECAUSE THE 9938 CHIP HAS DIFFERENT
*	    REGISTERS FOR THE SOURCE AND DESTINATION POINTS.
*
ARGTBL	EQU  $
	DATA 1023,'YC',34	34,35 SY - Y-COORDINATE
	DATA 511,'XC',32	32,33 SX - X-COORDINATE
	DATA 1023,'YC',38	38,39 DY - Y COORDINATE
	DATA 511,'XC',36	36,37 DX - X COORDINATE
	DATA 1023,'NY',42	43,43 NY - NUMBER OF Y DOTS
	DATA 511,'NX',40	40,41 NX - NUMBER OF X DOTS
	DATA 0			TABLE TERMINATOR
*
COMMAN	BSS  2			COMMAND CODE
*
BASEAD	EQU  $
	BSS  4
SY	BSS  2			SOURCE Y-X
SX	BSS  2
DY	BSS  2			DESTINATION Y-X
DX	BSS  2
NY	BSS  2			NUMBER OF DOTS Y-X
NX	BSS  2
COLOR	BSS  2			COLOR CODE
LOGIC	BSS  2			LOGIC OPERATION
*
DVIDXP	DATA VIDXOP		VIDEO XOP NUMBER
*
	END
