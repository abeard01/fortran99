	TITL 'SET/GET PIXEL COLOR'
	IDT  'SETPIX'
*
*  SETPIX : SET PIXEL COLOR (MDOS ONLY)
*  GETPIX : GET PIXEL COLOR (MDOS ONLY)
*
*  THIS ROUTINE IS CALLED AS FOLLOWS:
*
*	CALL SETPIX ( IXCORD, IYCORD, IFORE [,IBACK] )
*	CALL GETPIX ( IXCORD, IYCORD, IFORE [,IBACK] )
*
*       in gpl mode (screen mode 4):
*
*       CALL SETPIX ( IXCORD, IYCORD [, IFORE [,IBACK] ] )
*
*  WHERE:
*
*	IXCORD  :  IS THE X COORDINATE
*	IYCORD  :  IS THE Y COORDINATE
*	IFORE   :  IS THE FOREGROUND COLOR
*	IBACK   :  IS THE OPTIONAL BACKGROUND COLOR (GRAPHICS 2&3 ONLY)
*
*  COPYRIGHT 1988 BY LGMA PRODUCTS
*
*  UPDATE HISTORY:
*
*    VERSION 4.1   02-OCT-88    MDOS VERSION
*    VERSION 4.4   23-JAN-90    FIX GPL VERSION, COLORS
*    VERSION 4.41  18-MAR-90    FIX COLOR BYTE LOGIC
*
	DEF  GETPIX
	DEF  SETPIX
*
	COPY "FORTPAR:"
*
	UNL
	COPY "EQUATES:VID.EQ9"
	COPY "EQUATES:FORTEX.EQ9"
	LIST
*
SETPIX	EQU  $
	DATA -4			4 ARGUMENTS
	DATA TEMPS
	MOV  @AXCORD,R1		GET X COORDINATE
	MOV  *R1,R1
	MOV  @AYCORD,R2		GET Y COORDINATE
	MOV  *R2,R2
	UNL
	IF   GENEVE
	LIST
	MOV  @AFORE,R3		GET FOREGROUND COLOR
	MOV  *R3,R3
	SLA  R3,8		IN HIGH BYTE
	MOV  @ABACK,R4		GET BACKGROUND COLOR
	JEQ  SETPI1		BRIF NOTHING HERE
	MOV  *R4,R4
SETPI1	EQU  $
	ANDI R4,>FF
	SOC  R4,R3
	LI   R0,SETPIC		SET PIXEL COLOR
	XOP  @DVIDXP,0
	JMP  GETRET
	UNL
	ELSE
	LIST
	MOV  @SET40F,R5		GET CURRENT SCREEN MODE
	CI   R5,GRAPH2		GRAPHICS 2 MODE? (BITMAP)
	JEQ  SETPT2		BRIF YES
*
	BLWP *R10
	DATA ERROR
	TEXT 'BM'		BAD MODE
	B    @GETRET
*
SETPT2	EQU  $
	MOV  R1,R0		SET X REG
	MOV  R2,R1		SET Y REG
	MOV  R1,R4
	SLA  R4,5
	SOC  R1,R4
	ANDI R4,>FF07
	MOV  R0,R5		R0 IS X VALUE
	ANDI R5,7
	A    R0,R4		R4 IS THE BYTE OFFSET
	S    R5,R4		R5 IS THE BIT OFFSET
*
	MOV  @TABADD,R6		GET TABLE ADDRESS
	MOV  @6(R6),R0		GET PATTERN TABLE START ADDRESS
	A    R4,R0		 + BYTE OFFSET
	LIMI 0			DISABLE INTERRUPTS
	SWPB R0
	MOVB R0,@VDPWA
	SWPB R0
	MOVB R0,@VDPWA
	NOP
	MOVB @VDPRD,R1		GET PATTERN BYTE
*
	SOCB @BYTES(R5),R1	SET THE BIT I NEED
	ORI  R0,>4000		SET WRITE BIT
*
	SWPB R0
	MOVB R0,@VDPWA
	SWPB R0
	MOVB R0,@VDPWA
	NOP
	MOVB R1,@VDPWD
*
	MOV  @AFORE,R5		GET FOREGROUND COLOR ADDRESS
	JEQ  SKIPCO		BRIF NOT SPECIFIED, SKIP IT
*
	MOV  *R5,R5		GET VALUE
	DEC  R5
	SLA  R5,12		IN HIGH NIBBLE
*
	AI   R0,>2000		+ OFFSET TO COLOR TABLE
*	MOV  @4(R6),R0		GET COLOR TABLE START
*	A    R4,R0		 + BYTE OFFSET
*	ORI  R0,>4000
	SWPB R0
	MOVB R0,@VDPWA
	SWPB R0
	MOVB R0,@VDPWA
	NOP
*
	MOV  @ABACK,R6		GET BACKGROUND COLOR
	JEQ  COLDON		BRIF NONE SPECIFIED
*
	MOV  *R6,R6		GET BACKGROUND COLOR
	DEC  R6
	SLA  R6,8
	SOC  R6,R5		FORM COLOR BYTE
	MOVB R5,@VDPWD		AND WRITE IT
	JMP  SKIPCO
*
COLDON	EQU  $
	MOVB @VDPRD,R1		GET OLD COLOR BYTE
*
	ANDI R1,>0F00		EXTRACT OLD COLOR
	SOC  R5,R1		OR IN DESIRED FOREGROUND COLOR
	SWPB R0
	MOVB R0,@VDPWA
	SWPB R0
	MOVB R0,@VDPWA
*
	NOP
	MOVB R1,@VDPWD		WRITE THE BYTE
*
SKIPCO	EQU  $
	JMP  GETRET
BYTES	EQU  $
	BYTE >80,>40,>20,>10,>08,>04,>02,>01
	EVEN
	ENDIF
	LIST
*
GETPIX	EQU  $
	DATA -4			4 ARGUMENTS
	DATA TEMPS
	MOV  @AXCORD,R1		GET X COORDINATE
	MOV  *R1,R1
	MOV  @AYCORD,R2		GET Y COORDINATE
	MOV  *R2,R2
	UNL
	IF   GENEVE
	LIST
	LI   R0,GETPIC		GET PIXEL COLOR
	XOP  @DVIDXP,0		DO IT
	MOV  R0,R1		GET FOREGROUND COLOR
	SRA  R1,8
	ANDI R1,>FF
	MOV  @AFORE,R5
	MOV  R1,*R5
	ANDI R0,>FF
	MOV  @ABACK,R5		GET BACKGROUND COLOR
	JEQ  GETRET
	MOV  R0,*R5
	UNL
	ELSE
	LIST
	MOV  R1,R0
	MOV  R2,R1
	MOV  R1,R4
	SLA  R4,5
	SOC  R1,R4
	ANDI R4,>FF07
	MOV  R0,R5
	ANDI R5,7
	A    R0,R4		R4 IS THE BYTE OFFSET
	S    R5,R4		R5 IS THE BIT OFFSET
	MOV  @TABADD,R6		GET TABLE START ADDRESS
	MOV  @4(R6),R0		GET COLOR TABLE START
	A    R4,R0		 + OFFSET
	BLWP @CVSBR$
	MOV  R1,R2		GET VALUE
	SRA  R1,12		MAKE IT A WORD
	ANDI R1,>000F
	MOV  @AFORE,R5		GET ADDRESS OF PARAMETER
	MOV  R1,*R5
*
	SRA  R1,8
	ANDI R1,>000F
	MOV  @ABACK,R5		GET ADDRESS OF BACK PARAMETER
	JEQ  GETRET
	MOV  R1,*R5
	ENDIF
	LIST
GETRET	EQU  $
	MOV  @TEMPS,R3		RESTORE BASE
	MOV  @TEMPS+2,R11	RESTORE RETURN
	LIMI 2
	B    *R11		AND RETURN
*
	UNL
	IF   GENEVE
	LIST
DVIDXP	DATA VIDXOP		VIDEO XOP NUMBER
	ENDIF
	LIST
*
TEMPS	BSS  4
AXCORD	BSS  2			X COORDINATE
AYCORD	BSS  2			Y COORDINATE
AFORE	BSS  2			FOREGROUND COLOR
ABACK	BSS  2			BACKGROUND COLOR
	END

?????
	TITL 'SET VECTOR COLOR'
	IDT  'SETVEC'
*
*  SETVEC   :	SET VECTOR COLOR
*
*  CALLING SEQUENCE:
*				4	6	8	10	12	14
*	CALL SETVEC ( IX1ST, IY1ST, IX2ND, IY2ND, IFORE [,IBACK] )
*
*  WHERE:
*
*	IX1ST   :  IS THE X-COORDINATE OF THE FIRST PIXEL
*	IY1ST	:  IS THE Y-COORDINATE OF THE FIRST PIXEL
*	IX2ND   :  IS THE X-COORDINATE OF THE SECOND PIXEL
*	IY2ND   :  IS THE Y-COORDINATE OF THE SECOND PIXEL
*	IFORE   :  IS THE FOREGROUND COLOR TO RENDER
*	IBACK   :  IS THE BACKGROUND COLOR TO RENDER (MODES 2-3)
*
*  COPYRIGHT 1990 BY LGMA PRODUCTS
*
*  UPDATE HISTORY:
*
*	VERSION 4.1   02-OCT-88	MDOS VERSION
*	VERSION 4.4   02-FEB-90	UPDATED FOR MDOS COMPATIBLE VERSION
*	VERSION 4.41  08-MAR-90 FIXES FROM ELMER FOR TI-99/4A MODE (COLOR)
*
	DEF  SETVEC		SET VECTOR COLOR
*
	COPY "FORTPAR:"
*
	IFEQ  GENEVE
	DEF   DRAW
	DEF   MOVE
	ENDIF
*
	UNL
	COPY "EQUATES:VID.EQ9"
	COPY "EQUATES:FORTEX.EQ9"
*
	IF   GENEVE
	LIST
SETVEC	EQU  $
	DATA -6			6 ARGUMENTS
	DATA TEMPS
	LI   R8,TEMPS+4		STUFF ALL REGISTERS
	MOV  *R8+,R1
	MOV  *R1,R1		X-COORDINATE, FIRST PIXEL
	MOV  *R8+,R2
	MOV  *R2,R2		Y-COORDINATE, FIRST PIXEL
	MOV  *R8+,R3
	MOV  *R3,R3		X-COORDINATE, SECOND PIXEL
	MOV  *R8+,R4
	MOV  *R4,R4		Y-COORDINATE, SECOND PIXEL
*
*  EXTRACT COLORS, FOREGROUND AND BACKGROUND
*
	MOV  *R8+,R5
	JEQ  NOBACK
	MOV  *R5,R5
	ANDI R5,>FF
	SLA  R5,8		FOREGROUND COLOR FOR PIXEL
	MOV  *R8+,R6
	JEQ  NOBACK
	MOV  *R6,R6		BACKGROUND COLOR FOR PIXEL
	ANDI R6,>FF
	SOC  R6,R5
NOBACK	EQU  $
	LI   R0,SETVTC		SET VECTOR COLOR
	XOP  @DVIDXP,0		DO IT
	MOV  @TEMPS,R3		RESTORE BASE
	UNL
	ELSE
	LIST
*
MOVE	DATA -2	    		2 ARGUMENTS
	DATA BASEAD		TEMP DATA AREA
	MOV  @X1,R0		GET  X1
	MOV  *R0,@SVX1    	SAVE X1
	MOV  @Y1,R0		GET  Y1
	MOV  *R0,@SVY1    	SAVE Y1
	MOV  @BASEAD,R3   	RESTORE BASE R3
	MOV  @RETUAD,R11  	RESTORE RETURN R11
	B    *R11	  	RETURN
*
DRAW	DATA -4	    		4 ARGUMENTS
	DATA BASEAD		DATA AREA ADDRESS
	MOV  R10,@SVR10   	SAVE CONTENTS OF R10
	MOV  @X1,R0
	MOV  *R0,R13      	X2  (1ST ARGUMENT)
	MOV  @Y1,R0
	MOV  *R0,R14      	Y2  (2ND ARGUMENT)
	CLR  R6	     		USE INITIAL
	CLR  R15	   	SCREEN COLORS
	MOV  @X2,R0
	JEQ  DRW1	  	NO COLOR CHANGE
	MOV  *R0,R6		ICF (3RD ARGUMENT)
	MOV  @Y2,R0
	JEQ  DRW1	  	NO BACKGROUND CHANGE
	MOV  *R0,R15      	ICB (4TH ARGUMENT)
DRW1	MOV  @SVX1,R10    	X1  (SAVED VALUE)
	MOV  @SVY1,R12    	X2  (SAVED VALUE)
	MOV  R13,@SVX1    	(  SET NEXT
	MOV  R14,@SVY1    	(  DRAW ORIGIN
	NEG  R12	   	)
	AI   R12,191      	)  Y TO BE PLOTTED
	NEG  R14	   	)    UPWARDS
	AI   R14,191      	)
	JMP  PLOTXY
*
SETVEC 	DATA -6	    		6 ARGUMENTS
	DATA BASEAD		DATA AREA ADDRESS
*PLOT (X,Y):X1=R10,Y1=R12,X2=R13,Y2=R14,USES R2,R3
*0<=X<=255 RT TO LFT, 191<=Y<=0 UPWARDS
*NOTE:PIXEL USES R0,R1,R4,R5,R7,R8,R9
*     R6,R15 CONTAIN THE FOREGROUND/BACKGROUND COLORS
*****************************************************
	MOV  R10,@SVR10   	SAVE CONTENTS OF R10
	MOV  @X1,R0		[
	MOV  *R0,R10     	[
	MOV  @Y1,R0		[
	MOV  *R0,R12      	[
	MOV  @X2,R0		[
	MOV  *R0,R13      	[ ENTER SETVEC
	MOV  @Y2,R0		[  ARGUMENTS
	MOV  *R0,R14      	[
	CLR  R6	      		USE INITIAL
	CLR  R15	    	SCREEN COLORS
	MOV  @ICF,R0      	[
	JEQ  PLOTXY	 	NO COLOR CHANGE
	MOV  *R0,R6		[
	MOV  @ICB,R0      	[
	JEQ  PLOTXY	 	SET NO BACKGROUND CHANGE
	MOV  *R0,R15      	[
PLOTXY	LI   R0,1
	MOV  R0,@SGNX     	SIGN(DX) (NEG)
	MOV  R0,@SGNY     	SIGN(DY) (NEG)
	MOV  R13,@SX2     	SAVE X
	MOV  R13,R2		SX2
	S    R10,R2		DX=SX2-X1
	CI   R2,0
	JLT  PLT7	  	DX<0
	CLR  @SGNX	 	DX>=0
PLT7	ABS  R2
	MOV  R2,R13		ABS(DX)
	SLA  R2,6	  	DELX=64*DX
	MOV  R14,@SY2      	SAVE Y
	MOV  R14,R3		SY2
	S    R12,R3		DY=SY2-Y1
	CI   R3,0
	JLT  PLT8	  	DY<0
	CLR  @SGNY	 	DY>=0
PLT8	ABS  R3
	MOV  R3,R14		ABS(DY)
	SLA  R3,6	  	DELY=64*DY
	C    R13,R14
	JGT  PLT4	  	ABS(DX)>ABS(DY)
	MOV  R14,R13      	MAX DELTA
PLT4	CI   R13,0	 	SINGLE POINT?
	JEQ  PLT3	  	IF YES, NEXT THETA
	CLR  R4
	MOV  R2,R5	 	DELX
	DIV  R13,R4		DELX/DELTA
	MOV  R4,R2	 	DELTX
	CLR  R4
	C    @SGNX,R4
	JEQ  PLT9	  	+DX
	NEG  R2	    		-DX
PLT9	MOV  R3,R5	 	DELY
	DIV  R13,R4		DELY/DELTA
	MOV  R4,R3	 	DELTY
	MOV  @SGNY,@SGNY
	JEQ  PLT10	 	+DY
	NEG  R3	    		-DY
PLT10	SLA  R10,6	 	64*X1
	SLA  R12,6	 	64*Y1
PLT5	A    R2,R10		X+/-DX
	A    R3,R12		Y+/-DY
	MOV  R10,R8
	SRL  R8,6	  	X
	MOV  R12,R9
	SRL  R9,6	  	Y
	BL   @PIXEL		PLOT(X,Y)
	DEC  R13	   	LAST POINT?
	JNE  PLT5	  	IF NO, DO IT AGAIN
PLT3	MOV  @SX2,R10     	NEW X1
	MOV  @SY2,R12     	NEW Y1
	MOV  R10,R8		X
	MOV  R12,R9		Y
	BL   @PIXEL		PLOT(X,Y)
	MOV  @SVR10,R10   	RESTORE R10
	MOV  @BASEAD,R3   	RESTORE BASE R3
	MOV  @RETUAD,R11  	RESTORE RETURN 11
	B    *R11	 	RETURN
PIXEL	CI   R9,0			  ]
	JLT  PX1	   	Y < 0     ]
	CI   R9,191		   	  ]
	JGT  PX1	   	Y > 191   ]  PIXEL OFF
	CI   R8,0		     	  ]  THE SCREEN
	JLT  PX1	   	X < 0     ]
	CI   R8,255		   	  ]
	JGT  PX1	   	X > 255   ]
	MOV  R9,R4	 	PIXEL(COL,ROW)=PIXEL(R8,R9)
	SLA  R4,5	  	USES R0,R1,R4,R5,R7
	SOC  R9,R4
	ANDI R4,>FF07
	MOV  R8,R5
	ANDI R5,7
	A    R8,R4
	S    R5,R4	 	WRITE A PIXEL
	MOV  R4,R0
	BLWP @CVSBR$	 	SEE E/A MANUAL
	LI   R7,TX	  	BITMAP MODE
	A    R5,R7
	SOCB *R7,R1
	BLWP @CVSBW$
*********************************************************
* SET COLOR BYTE ACCORDING TO SETVEC CALL
*   IF NO FOREGROUND ARGUMENT LEAVE COLOR BYTE UNCHANGED
*   IF FOREGROUND BUT NO BACKGROUND ARGUMENT USE OLD
*      BACKGROUND FROM THE CURRENT SCREEN TABLE
*******************************************************************
	CI   R6,0
	JEQ  PX1	   	NO FOREGROUND ARGUMENT (NO SCREEN CHANGE)
	AI   R0,>2000     	COLOR BYTE ADDRESS
	MOV  R6,R5	 	FOREGROUND COLOR
	DEC  R5	    		1-16 TO 0-15 COLORS
	SLA  R5,12	 	FIRST NIBBLE OF COLOR BYTE
	CI   R15,0
	JEQ  NOBACK		NO BACKGROUND ARGUMENT (USE OLD BACKGROUND)
	MOV  R15,R1		BACKGROUND COLOR
	DEC  R1	    		1-16 TO 0-15 COLOR
	SLA  R1,8	  	SECOND NIBBLE OF COLOR BYTE
	JMP  CBYTE
NOBACK	BLWP @CVSBR$	 	GET OLD COLOR BYTE
	SZCB @MASK,R1     	REMOVE FORGROUND NIBBLE
CBYTE	SOC  R5,R1	 	ADD TO FIRST NIBBLE
	BLWP @CVSBW$	 	WRITE NEW COLOR BYTE
PX1	RT
BASEAD	BSS  2	     		CALLER'S R3
RETUAD	BSS  2	     		RETURN ADDRESS
X1	BSS  2	     		1ST ARGUMENT ADDRESS
Y1	BSS  2	     		2ND ARGUMENT ADDRESS
X2	BSS  2	     		3RD ARGUMENT ADDRESS
Y2	BSS  2	     		4TH ARGUMENT ADDRESS
ICF	BSS  2	     		5TH ARGUMENT ADDRESS
ICB	BSS  2	     		6TH ARGUMENT ADDRESS
* ASSEMBLY SOURCE CODE FOR SETVEC(X1,Y1,SX2,SY2,ICF,ICB)
* IN THE BITMAP MODE DRAW A LINE FROM P1(X1,Y1) TO P2(SX2,SY2)
* X1,X2,Y1,Y2,ICF,ICB  INTEGER*2
* ICF,ICB = FORE/BACKGROUND PIXEL COLOR , INTEGER*2
SVR10	DATA 0
SGNX	DATA 0
SGNY	DATA 0
SX2	DATA 0
SY2	DATA 0
TX	DATA >8040,>2010,>0804,>0201
MASK	DATA >F000	 	MASK OUT FIRST NIBBLE
SVX1	DATA >0000
SVY1	DATA >0000
	UNL
	ELSE
	LIST
TEMPS	BSS  4
	BSS  12			6 ARGUMENTS
DVIDXP	DATA VIDXOP		VIDEO XOP NUMBER
	ENDIF
	END

