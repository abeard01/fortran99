	TITL  'CPU MULTI-BYTE READ/WRITE'
	IDT   'CPMBRW'
*
*  CPMBRW :  A routine to transfer memory from high ram (or other ram)
*	     to low user ram.
*
*  CALLING SEQUENCE:
*
*	     CALL CPMBR ( LONG_ADDRESS, BUFFER, LENGTH )
*	     CALL CPMBW ( LONG_ADDRESS, BUFFER, LENGTH )
*
*  WHERE:
*
*	LONG_   :  IS THE INTEGER *4 LONGWORD ADDRESS (E.G. 20140)
*	ADDRESS
*
*	BUFFER  :  IS THE BUFFER IN LOCAL MEMORY TO READ/WRITE
*
*	LENGTH  :  IS THE LENGTH TO READ/WRITE
*
*  COPYRIGHT 1989 BY LGMA PRODUCTS
*
*  Update History:
*
*    v4.0   9-Jan-1989     Initial Version
*
*  Boy, this would sure be easier if the MDOS call worked.
*
	DEF  CPMBR		CPU MULTI BYTE READ
	DEF  CPMBW		CPU MULTI BYTE WRITE
*
	COPY "FORTPAR:"
	UNL
	COPY "EQUATES:MEM.EQ9"
	COPY "EQUATES:FORTEX.EQ9"
	LIST
*
START	EQU  $
CPMBR	EQU  $
	DATA -3			3 ARGUMENTS
	DATA TEMPS
	BL   @GETMMR		GET MEMORY MAP
	CLR  R1			"MOVE TO" LOCAL MEMORY
	MOV  @AVALUE,R2
	MOV  @ALOC,R5
	MOV  *R5+,R3		"MOVE FROM" GIVEN I*4 ADDRESS
	MOV  *R5,R4
	JMP  MOVCOM
*
*  CPMBW  : WRITE TO CPU MEMORY
*
CPMBW	EQU  $
	DATA -3			3 ARGUMENTS
	DATA TEMPS
	BL   @GETMMR
	MOV  @ALOC,R5		"MOVE TO" NON-LOCAL MEMORY
	MOV  *R5+,R1
	MOV  *R5,R2
	CLR  R3
	MOV  @AVALUE,R4		"MOVE FROM" LOCAL MEMORY
MOVCOM	EQU  $
	MOV  @ABYTES,R5
	MOV  *R5,R5
*
*  MOVMEL : EMULATION OF MDOS MOVMML SUBROUTINE
*
*           ON ENTRY:	 R1 HAS DESTINATION MSB
*			 R2 HAS DESTINATION LSW
*			 R3 HAS SOURCE MSB
*			 R4 HAS SOURCE LSW
*			 R5 HAS # OF BYTES TO MOVE
*
*  THIS ROUTINE CLOBBERS R2, R3, R4, R5, AND R6, R7 AND R8
*
MOVMEL	EQU  $
*
*  DETERMINE WHAT PAGES I CAN USE TO MAP IN.  INVALID PAGES INCLUDE:
*
*	1. PAGE 0
*	2. PAGE 7
*	3. PAGE(S) I AM MAPPED ON
*
	LI   R8,>FF00		INVALID CODE
	LI   R9,INVMAP
	MOV  R8,*R9+		SET FIRST PAGE INVALID
	CLR  *R9+		PAGES 2,3 OK
	CLR  *R9+		PAGES 4,5 OK
	LI   R8,>00FF
	MOV  R8,*R9+		LAST PAGES NOT OK
*
	LI   R8,START		START OF SUBROUTINE
	SRA  R8,13
	ANDI R8,7		STARTING PAGE OF SUBROUTINE
	LI   R9,INVMAP
	A    R8,R9
	LI   R8,>FF00		MAKE IT INVALID
	MOVB R8,*R9
*
	LI   R8,ENDSUB
	SRA  R8,13
	ANDI R8,7		ENDING PAGE OF SUBROUTINE
	LI   R9,INVMAP
	A    R8,R9
	LI   R8,>FF00		MAKE IT INVALID
	MOVB R8,*R9
*
	MOV  R3,R6		MAP IN SOURCE PAGE, AND RETURN REL
	MOV  R4,R7
	BL   @MAPIN
	MOV  R6,R8		SET START BASE ADDRESS
*
	MOV  R1,R6		MAP IN DESTINATION PAGE, AND RETURN REL
	MOV  R2,R7
	BL   @MAPIN
	MOV  R6,R9		SET DESTINATION BASE ADDRESS
*
	MOVB *R8+,*R9+		MOVE A BYTE
*
INCADR	EQU  $
	INC  R2			INCREMENT DESTINATION ADDRESS
	JNC  NOTSH1
	INC  R1
*
NOTSH1	EQU  $
	INC  R4			INCREMENT SOURCE ADDRESS
	JNC  NOTSH2
	INC  R3
*
NOTSH2	EQU  $
	DEC  R5
	JEQ  EXTMML		BRIF DONE MOVE
*
*  INCREMENT LOCAL FROM AND TO POINTERS.  IF THEY DID NOT EXTEND
*  PAST THE END OF THIER RESPECTIVE PAGES, THEN I CAN JUST KEEP
*  MOVING FROM HERE.
*
	MOV  R8,R0
	ANDI R0,>1FFF		DID I PASS A NEW PAGE?
	JEQ  MOVMEL		BRIF YES, RECALCULATE
*
	MOV  R9,R0
	ANDI R0,>1FFF		DID I PASS A NEW PAGE?
	JEQ  MOVMEL		BRIF YES, RECALCULATE
*
	MOVB *R8+,*R9+		MOVE BYTE
	JMP  INCADR
*				RESTORE MAPPER REGISTERS
EXTMML	EQU  $
	LI   R0,IOBBUF+1
	LI   R1,MMRREG+1
	LI   R2,6		RESTORE 8 PAGES
EXTMM1	EQU  $
	MOVB *R0+,*R1+
	DEC  R2
	JNE  EXTMM1
	MOV  @TEMPS,R3		RESTORE BASE
	MOV  @TEMPS+2,R11	RESTORE RETURN
	B    *R11
*
*  MAPIN :  MAPS IN THE DESIRED LOCAL PAGE TO AN EXECUTION PAGE.
*	    IT MAKES SURE THE LOCAL PAGE IS A VALID ONE TO USE.
*
MAPIN	EQU  $
	MOV  R7,R0		SAVE START ADDRESS (LOW WORD)
	ANDI R0,>1FFF		RELATIVE TO PAGE
	ANDI R7,>E000		MASK PAGE NUMBER
	ANDI R6,>00FF		MASK HIGH PAGE NUMBER
	SOC  R6,R7		OR IN HIGH PAGE NUMBER
	SRC  R7,13		IN LOW NIBBLE
*
	LI   R6,INVMAP		GET TABLE OF INVALID PAGES
MAPIN1	EQU  $
	CB   *R6+,@KFF		IS THIS PAGE INVALID?
	JEQ  MAPIN1		BRIF NO
*
	DEC  R6
	MOVB @KFF,*R6		SET PAGE INVALID
	LI   R12,INVMAP		DETERMINE PAGE NUMBER
	S    R12,R6
*
	MOVB @IOBBUF(R7),@MMRREG(R6)
	SLA  R6,13		SET BASE ADDRESS
	A    R0,R6
	B    *R11
*
*  GETMMR : GET MEMORY MAP IN I/O BUFFER
*
GETMMR	EQU  $
	LI   R1,IOBBUF		FIRST CLEAR IT OUT
	LI   R2,256
GETMM1	EQU  $
	MOVB @KFF,*R1+
	DEC  R2
	JNE  GETMM1
*
	LI   R0,GETMAP		GET MAX OF 256 PAGES IN IOBBUF
	LI   R1,IOBBUF
	LI   R2,256
	XOP  @DMEMXP,0
	B    *R11
*
*  DATA AREA:
*
TEMPS	EQU  $
	BSS  4			DATA AREA SAVE
ALOC	BSS  2			I*4 LOCATION
AVALUE	BSS  2			BYTE VALUES
ABYTES	BSS  2			# OF BYTES TO MOVE
*
DMEMXP	DATA MEMXOP		MEMORY MANAGER XOP NUMBER
*
*  POSSIBLE MEMORY PAGES TO MAP TO.  0 MEANS OK, FF MEANS CAN'T USE
*  IT.
*
INVMAP	EQU  $
	BSS  8
*
KFF	BYTE >FF
	EVEN
ENDSUB	EQU  $
	END
