	TITL 'FORTRAN COMPILER PART 2'
	IDT  'FORT2'
*
*  This section of the compiler contains the intermediate FORTRAN
*  Psuedo Opcodes.  It is interpreted by the FORTRAN1 module.
*
*  In GPL Mode:
*	FORTRAN2 is mapped by the MENU loader routine into VDP RAM.
*
*  		Assembled into cpu ram location:    >C000
*  		Interpreted in vdp ram location:    >0C20
*
*  In MDOS Mode:
*	This module resides in RAM just as any CPU module.
*
*  Update history:
*
*    Version 2.3,  12-April-1987
*
*      Patch update, and changed some code definitions
*
*    Version 3.0,  10-August-1987   Added "QIO" feature.  Converted to
*				    "MACRO" cross-assembler format.  Added
*				    "wildcard" I/O feature.  Expanded 
*				    inline function tables.
*
*		   16-August-1987   Added 1 to N intrinsic functions.  Added
*				    new VAR cell "VARGSA" for intrinsic.
*				    Added new constant "XFF00".
*
*
*    Version 3.1,  31-August-1987   Added new forms of constant specification,
*				    Z'....', O'....', B'.....'.
*
*    Version 4.0,  09-December-1987 Modifications for MDOS
*				    Added integer *1, logical *1, character,
*				    integer *4 data types.
*
*                  15-APRIL-1989    GPL Version 4.1
*
*                  11-AUG-89        ADDED COMPLEX ARITHMETIC, LIST DIRECTED
*				    FORMATTING.
*
*                  27-Dec-89        Fixed negate in data statement process
*
*                  28-Dec-89        Fix subprogram calls for byte constants.
*
	COPY "FORTPAR:"
*
	DEF  FORT2
	DEF  FORT2E		; END OF FORTRAN MAP
*
PASS1	EQU  0			not pass 1
	COPY "FORTRAN5.A99"
*
*   INTERPRETER INSTRUCTION DEFINITIONS:
*
*   TYPE 1 PSUEDO OPERATIONS:
*				FAIL EXIT POINTER
FEX	MACRO
	DATA %1-POP/2
	ENDM
*                       	JUMP ON ANSWER FALSE
JAF	MACRO
	DATA %1-POP/2+>1000
	ENDM
*				JUMP ON ANSWER TRUE
JAT	MACRO
	DATA %1-POP/2+>2000
	ENDM
*				JUMP IF W0=0
JOW	MACRO
	DATA %1-POP/2+>4000
	ENDM
*				JUMP INTO SUBROUTINE
JSB	MACRO
	DATA %1-POP/2+>5000
	ENDM
*				UNCONDITIONAL JUMP
JUN	MACRO
	DATA %1-POP/2+>6000
	ENDM
*				JUMP TO NON-INTERPRETIVE SUBROUTINE
JML	MACRO
	DATA %1/2+>7000
	ENDM
*
*   TYPE 2 PSUEDO OPERATIONS:
*				ADD TO W0
ADP	MACRO
	DATA %1/2+>8000
	ENDM
*				AND WITH W0
ANP	MACRO
	DATA %1/2+>8200
	ENDM
*				ASSIGN TO STORAGE AND KEEP
ASK	MACRO
	DATA %1/2+>8400
	ENDM
*				ASSIGN TO STORAGE AND PRUNE
ASP	MACRO
	DATA %1/2+>8600
	ENDM
*				CLEAR W0 AND ADD
CLA	MACRO
	DATA %1/2+>8800
	ENDM
*				EXTRACT ADDRESS FIELD
EAD	MACRO
	DATA %1/2+>8A00
	ENDM
*				EXTRACT OPERAND FIELD
EOP	MACRO
	DATA %1/2+>8C00
	ENDM
*				EXTRACT TAG FIELD
ETA	MACRO
	DATA %1/2+>8E00
	ENDM
*				FETCH
FET	MACRO
	DATA %1/2+>9000
	ENDM
*				INSERT ADDRESS FIELD INTO W0
IAD	MACRO
	DATA %1/2+>9200
	ENDM
*				INSERT TAG FIELD INTO W0
ITA	MACRO
	DATA %1/2+>9400
	ENDM
*				MULTIPLY W0 BY
MUL	MACRO
	DATA %1/2+>9600
	ENDM
*				SET NONZERO
NOZ	MACRO
	DATA %1/2+>9800
	ENDM
*				TALLY (SAME AS NOZ)
TLY	MACRO
	DATA %1/2+>9800
        ENDM
*				PRECISION ADD
PAD	MACRO
	DATA %1/2+>9A00
	ENDM
*				PRECISION LOAD
PLD	MACRO
	DATA %1/2+>9C00 
	ENDM
*				PUT ON CODE STACK
POC	MACRO
	DATA %1/2+>9E00
	ENDM
*				EXCLUSIVE OR WITH W0
PSP	MACRO
	DATA %1/2+>A000
	ENDM
*				PRECISION STORE
PST	MACRO
	DATA %1/2+>A200
	ENDM
*				QUOTE SCAN W/ANSWER
QSA	MACRO
	DATA %1/2+>A400
	ENDM
*				QUOTE SCAN OR FAIL
QSF	MACRO
	DATA %1/2+>A600
	ENDM
*				SET IF MATCH ADDRESS FIELDS
SAD	MACRO
	DATA %1/2+>A800
	ENDM
*				SET IF W0 LESS THAN OR EQUAL
SLE	MACRO
	DATA %1/2+>AA00
	ENDM
*				SET IF W0 NON EQUAL
SNE	MACRO
	DATA %1/2+>AC00
	ENDM
*				SET IF NON-ZERO
SNZ	MACRO
	DATA %1/2+>AE00
	ENDM
*				SET IF MATCH P0 TAG FIELDS
SPT	MACRO
	DATA %1/2+>B000
	ENDM
*				SET IF MATCHING TAG FIELDS
STG	MACRO
	DATA %1/2+>B200
	ENDM
*				SUBTRACT FROM W0
SUP	MACRO
	DATA %1/2+>B400
	ENDM
*				SWITCH WITH W0
SWT	MACRO
	DATA %1/2+>B600
	ENDM
*				SET ZERO
ZER	MACRO
	DATA %1/2+>B800
	ENDM
*
*    TYPE 3 PSUEDO OPERATIONS
*
*				ASSIGN RELATIVE TO POINTER
ARP	MACRO
	DATA %1/2+>C000
	ENDM
*				BUILD INSTRUCTION BY MODE (INTERP SUBROUTINE)
BIM	MACRO
	DATA %1/2+>C100
	ENDM
*				BUILD INSTRUCTION
BIN	MACRO
	DATA %1/2+>C200
	ENDM
*				COPY AND RELEASE
CAR	MACRO
	DATA %1/2+>C300
	ENDM
*				COPY AND RELEASE FROM CODE STACK
CFC	MACRO
	DATA %1/2+>C400
	ENDM
*				COPY AND RELEASE TO CODE STACK
CTC	MACRO
	DATA %1/2+>C500
	ENDM
*				CLEAR AND ADD IMMEDIATE
CLI	MACRO
	DATA >C600+%1
	ENDM
*				COUNT NUMBER OF WORDS
CNT	MACRO
	DATA %1/2+>C700
	ENDM
*				COPY PLEX ON
CPO	MACRO
	DATA %1/2+>C800
	ENDM
*				CHARACTER SCAN W/ANSWER
CSA	MACRO
	DATA >C900+%1
	ENDM
*				CHARACTER SCAN OR FAIL
CSF	MACRO
	DATA >CA00+%1
	ENDM
*				EFFECTIVE ADDRESS TO WORK
EAW	MACRO
	DATA >CB00+%1
	ENDM
*				FLIP
FLP	MACRO
	DATA %1/2+>CC00
	ENDM
*				FLIP STACK
FRP	MACRO
	DATA %1/2+>CD00
	ENDM
*				INDIRECT
IND	MACRO
	DATA >CE00+%1
	ENDM
*				LOAD INVERTED GROUP TO CENTRAL WITH ANSWER
LGA	MACRO
	DATA %1/2+>CF00
	ENDM
*				MOVE OFF WITH ANSWER TO WORK STACK
MOA	MACRO
	DATA %1/2+>D000
	ENDM
*				MOVE ON FROM WORK STACK
MON	MACRO
	DATA %1/2+>D100
	ENDM
*				COPY NUMBER OF GROUPS AND STACK TO CODE STACK
NCC	MACRO
	DATA %1/2+>D200
	ENDM
*				COUNT NUMBER OF GROUPS
NOG	MACRO
	DATA %1/2+>D300
	ENDM
*				PUT GROUP ON
PGO	MACRO
	DATA %1/2+>D400
	ENDM
*				POINTER TO NEW GROUP
PNG	MACRO
	DATA %1/2+>D500
	ENDM
*				PRUNE OFF WORK STACK
POW	MACRO
	DATA >D600+%1
	ENDM
*				REGISTER GROUP ON STACK
REG	MACRO
	DATA %1/2+>D700
	ENDM
*				RELEASE
REL	MACRO
	DATA %1/2+>D800
	ENDM
*				RESERVE
RSV	MACRO
	DATA %1/2+>D900
	ENDM
*				SET IF CHARACTER EQUALS
SCE	MACRO
	DATA >DA00+%1
	ENDM
*				SET ON CHARACTER KEY
SCK	MACRO
	DATA >DB00+%1
	ENDM
*				SHIFT W0 CIRCULAR LEFT
SCL	MACRO
	DATA >DC00+%1
	ENDM
*				SET ON OP FIELD
SOP	MACRO
	DATA %1/2+>DD00
	ENDM
*				SEARCH WITH ANSWER
SWA	MACRO
	DATA %1/2+>DE00
	ENDM
*				SET IF REMAINING DATA
SRD	MACRO
	DATA %1/2+>DF00
	ENDM
*				ARG SPECIFIES POP - W0 HOLDS ARG
W0	MACRO
	DATA >E000+%1
	ENDM
*				ARG SPECIFIES POP - W1 HOLDS ARG
W1	MACRO
	DATA >E100+%1 
	ENDM
*				ARG SPECIFIES POP - W2 HOLDS ARG
W2	MACRO
	DATA >E200+%1 
	ENDM
*				ARG SPECIFIES POP - W3 HOLDS ARG
W3	MACRO
	DATA >E300+%1
	ENDM
*				SEARCH FAST W/ANSWER
SFA	MACRO
	DATA %1/2+>E400
	ENDM
*
*  POP DEFINITIONS FOR W0,W1,W2,W3 INSTRUCTIONS
*
*  TYPE 2 POPS
*
ADPX 	EQU  0
ANPX 	EQU  1
ASKX 	EQU  2
ASPX 	EQU  3
CLAX 	EQU  4
EADX 	EQU  5
EOPX 	EQU  6
ETAX 	EQU  7
FETX 	EQU  8
IADX 	EQU  9
ITAX 	EQU  >A
MULX 	EQU  >B
NOZX 	EQU  >C
TLYX	EQU  >C
PADX 	EQU  >D
PLDX 	EQU  >E
POCX 	EQU  >F
PSPX 	EQU  >10
PSTX 	EQU  >11
QSAX 	EQU  >12
QSFX 	EQU  >13
SADX 	EQU  >14
SLEX 	EQU  >15
SNEX 	EQU  >16
SNZX 	EQU  >17
SPTX 	EQU  >18
STGX 	EQU  >19
SUPX 	EQU  >1A
SWTX 	EQU  >1B
ZERX 	EQU  >1C
*
*  TYPE 3 POPS
*
ARPX	EQU   >0
BIMX	EQU   >1
BINX	EQU   >2
CARX	EQU   >3
CFCX	EQU   >4
CTCX	EQU   >5
CLIX	EQU   >6
CNTX	EQU   >7
CPOX	EQU   >8
CSAX	EQU   >9
CSFX	EQU   >A
EAWX	EQU   >B
FLPX	EQU   >C
FRPX	EQU   >D
INDX	EQU   >E
LGAX	EQU   >F
MOAX	EQU   >10
MONX	EQU   >11
NCCX	EQU   >12
NOGX	EQU   >13
PGOX	EQU   >14
PNGX	EQU   >15
POWX	EQU   >16
REGX	EQU   >17
RELX	EQU   >18
RSVX	EQU   >19
SCEX	EQU   >1A
SCKX	EQU   >1B
SCLX	EQU   >1C
SOPX	EQU   >1D
SWAX	EQU   >1E
SRDX	EQU   >1F
W0X 	EQU   >20
W1X 	EQU   >21
W2X 	EQU   >22
W3X 	EQU   >23
*
*
*  CHARACTER STRING EQUATES
*
ECARRT	EQU  >0D	CARRAIGE RETURN
EFAKEQ	EQU  >0D	FAKE QUOTE USED FOR QUOTES IN FORMAT
EBLANK  EQU  >20	ASCII BLANK
ECC	EQU  >23	#
EQUOTE	EQU  >27	(')
ELPARE	EQU  >28	(
ERPARE	EQU  >29	)
EASTRS	EQU  >2A	*
EPLUS	EQU  >2B	(+)
ECOMMA	EQU  >2C	COMMA (,)
EMINUS	EQU  >2D	MINUS
EPERIO	EQU  >2E	PERIOD (.)
ESLASH	EQU  >2F	SLASH (/)
EZERO	EQU  >30	ZERO (0)
EONE	EQU  >31	* ONE (1)
ETWO	EQU  >32	* TWO (2)
EFOUR	EQU  >34	* FOUR (4)
ESIX	EQU  >36	* SIX (6)
EEIGHT	EQU  >38	* EIGHT (8)
ECOLON	EQU  >3A	COLON (:)
EEQUAL	EQU  >3D	=
ECAT	EQU  >40	@
EA	EQU  >41	A
EB	EQU  >42	* v3.0 B
EC   	EQU  >43	C
ED   	EQU  >44	D
EE   	EQU  >45	E
EF   	EQU  >46	F
EH   	EQU  >48	H
EI   	EQU  >49	I
EL   	EQU  >4C	L
EM   	EQU  >4D	M
EN   	EQU  >4E	N
EO	EQU  >4F	* v3.0  O
EP   	EQU  >50	P
EQ	EQU  >51	* v3.0  Q
ER   	EQU  >52	R
ES   	EQU  >53	S
ET   	EQU  >54	T
EW   	EQU  >57	W
EX   	EQU  >58	X
EY   	EQU  >59	Y
EZ   	EQU  >5A	Z
	TITL 'INTERPRETER SUBROUTINES'
	PAGE
*
*  THE START OF THE INTERPRETED BASE.
*
*  Location is always org'd to 0, this module is relocatable.
*
*  MDOS version in CPU RAM resident at the specified location.
*
*  FORTRAN2 is relocated into VDP ram by the MENU loader.
*
*  Define various entries into FORTRAN2 for the interpreter:
*
	RORG 0
*
FORT2	EQU  $
	DATA FORT2E-FORT2 		LENGTH OF ROUTINE
	DATA POP-FORT2   		POP ROUTINE START
	DATA ALLOC-POP/2  		ALLOCATE ROUTINE START
	DATA START-POP/2  		START ROUTINE START
	DATA OPTSCA-POP/2 		OPTION SCAN START
	DATA 0            		FUTURE FAIL EXIT
	DATA ZNUMBE-POP/2 		NUMBER FAIL EXIT
 	DATA ZSYNTA-POP/2 		SYNTAX FAIL EXIT
	DATA BIMXX-POP/2  		BIM INTERPRETIVE SUBROUTINE
*
POP	EQU  $
*
CLR2EX	EQU  $
	POW  1		EXIT WITH ANSWER SET TRUE
CLR1EX	EQU  $
	POW  1
EXIT  	EQU  $
	JML  AEXIT
*
C1EXFA	EQU  $
	POW  1		EXIT WITH ANSWER SET FALSE
EXITFA	EQU  $
	JML  AEXFAL
*
ZPCOVE	EQU  $
	ANP  KOPFLD	POINTER CAPACITY OVERFLOW FAIL
	SCL  6
	ADP  KOVPCQ	ERROR # IS STACK # + PC QT BASE
	JUN  ZCURCH
*
ZSCRIP	EQU  $
	EAW  QSCRIP	SUBSCRIPTS FAIL
	JUN  ZCURCH	ERROR ON CURRENT CHARACTER
*
ZSYNTA	EQU  $
	EAW  QSYNTA	SYNTAX FAIL
ZCURCH	EQU  $
	FET  PCURCH	ERROR ON CURRENT CHARACTER
	JUN  ZFAIL
*
ZALLOC	EQU  $
	EAW  QALLOC	ALLOCATION FAIL
	JUN  ZLSTCH	ERROR ON LAST CHARACTER
*
ZID   	EQU  $
	EAW  QID	ID CONFLICT FAIL
	JUN  ZLSTCH	ERROR ON LAST CHARACTER
*
ZILLOP	EQU  $
	EAW  QILLOP	ILLEGAL OPTION FAIL
	JUN  ZLSTCH
*
ZNOLBL	EQU  $
	EAW  QNOLBL	MISSING LABEL FAIL
	JUN  ZLSTCH
*
ZNUMBE	EQU  $
	EAW  QNUMBE	NUMBER FAIL
	JUN  ZLSTCH
*
ZSBSTM	EQU  $
	EAW  QSBSTM	SUBSTATEMENT FAIL
	JUN  ZLSTCH
*
ZNESTD	EQU  $
	EAW  QNESTD	DO LOOP INCORRECTLY NESTED
	JUN  ZLSTCH
*
ZMISKE	EQU  $
	EAW  QMISKE	MISSING KEYWORD
	JUN  ZLSTCH
*
ZELSE 	EQU  $
	EAW  QINVC1	INVALID CONTROL STRUCTURE: ELSE
	JUN  ZLSTCH
*
ZELSEI	EQU  $
	EAW  QINVC2	INVALID CONTROL STRUCTURE: ELSEIF
	JUN  ZLSTCH
*
ZENDIF	EQU  $
	EAW  QINVC3	INVALID CONTROL STRUCTURE: ENDIF
	JUN  ZLSTCH
*
ZTYPE 	EQU  $
	EAW  QTYPE	TYPE CONFLICT FAIL
ZLSTCH	EQU  $
	FET  PLSTCH	ERROR ON LAST CHARACTER
*
*
ZFAIL 	EQU  $
	ASP  PERRCH	FAIL BACK TO STATUS AS OF LAST
	ASP  PERRMS	 CALL TO 'STATUSSET'
	ZER  FBLANK
	ZER  FLONGN
	JML  AFAIL	WHEN DONE TAKE FAIL EXIT
*
SPECEX	EQU  $
	ZER  VLBLKE	EXIT FOLLOWING SPECIFICATION STATEMENT
	SCE  ECARRT
	JAT  EXIT	SPEC STMT LBL ALLOWS BRANCH ONLY
	JUN  ZSYNTA	ENSURE END OF LINE
*
EXECEX	EQU  $
	ZER  VLBLKE	EXIT FOLLOWING ACTIVE STATEMENT
	NOZ  FJUMP	INVALID EXECUTE TARGET -- ZERO
	JUN  ACTVDO	 VLBLKE & SET FJUMP
*
JUMPEX	EQU  $
	NOZ  FJUMP	JUMP -- SET FJUMP AND FLBLKE
        JUN  $+4	 VLBLKE
*
ACTVEX	EQU  $
	ZER  FJUMP	ELSE -- ZERO FJUMP AND FLBLKE
	FET  TEXEC	 VLBLKE
	ASP  VLBLKE
*
ACTVDO	EQU  $
	JSB  EOLCHE	ENSURE END OF LINE
	JAF  ZSYNTA
*
ACTIVF	EQU  $
	NOZ  FACTIV	SET F:ACTIVE
*
FUNCEX	EQU  $
	SNZ  FNTSPE	EXIT FOLLOWING STMT FUNCTION
	JAT  EXIT
	NOZ  FNTSPE	IF FIRST NON-SPECIFICATION STMT,
	CFC  RPROLO	 PRECEDE GENERATED CODE BY END-
	POC  IENDAT	 DATA MARKER AND ANY SETUP CODE
	CTC  RPROLO
	JUN  EXIT
*
INTSCA	EQU  $
	SCK  DIGITK	SCAN INTEGER NUMBER
	JAF  ZSYNTA
	JSB  DIGITI     TAKE SYNTAX FAIL UNLESS AT
	JSB  DIGITS	 LEAST 1 DIGIT
*
INITCH	EQU  $
	SNZ  VDATA1   CHECK SIZE OF INTEGER NUMBER
	JAT  ZNUMBE    IN VDATA1-VDATA3
	SNZ  VDATA2
	JAT  ZNUMBE	TAKE NUMBER FAIL IF >32,767
	FET  VDATA3
	SLE  KMONE
	JAF  CLR1EX	ELSE, SIMPLY RETURN
	JUN  ZNUMBE
*
DIGITI	EQU  $
	PLD  KZERO	INITIALIZE FOR DATA SCAN
	PST  VDATA1
	PST  VTEMP1	 ZERO DATA CELLS TO BE USED
	ZER  VCSCAN
	ZER  VCUSED	 ZERO DIGIT COUNTS
	JUN  EXIT
*
DIGITS	EQU  $
	SCK  DIGITK	SCAN DIGIT STRING & CONVERT TO 3
	JAF  EXIT	 BINARY WORDS IN VDATA1-VDATA3
	JSB  DIGITC
	JML  ANXTCH	CONVERT SINGLE DIGIT
	JUN  DIGITS	REPEAT FOR NEXT DIGIT
*
DIGITC	EQU  $
	TLY  VCSCAN	CONVERT SINGLE DIGIT
	FET  VDATA1	UPDATE COUNT OF DIGITS SCANNED
	SLE  X7FF
	JAF  CLR1EX	IF # PRECISION > 43 BITS, IGNORE
	TLY  VCUSED	 NEW DIGIT, ELSE UPDATE COUNT
	CLA  VCURCH	 OF DIGITS USED.
	ANP  XF
	ASP  VTEMP3
	PLD  VDATA1
	PAD  VDATA1
	PST  VDATA1	MULTIPLY CURRENT NUMBER BY 10
	PAD  MPAC
	PAD  MPAC
	PAD  VDATA1
	PAD  VTEMP1	ADD NEW DIGIT & STORE RESULT
	PST  VDATA1
	JUN  EXIT
*
REGWKC	EQU  $          REGISTER CONSTANT ON WORK STACK
	ASP  VDATA3	RETURN PTR IN PLACE OF CONSTANT
	REG  RFXCON
	JUN  EXIT
*
IDSCAN	EQU  $
	JML  ASYMSC	SCAN ASCII NAME AND CHECK IF KNOWN
*
IDCHEC	EQU  $
	SWA  RLDUMM
	JAT  TYPESE	LOCAL DUMMY(SCALAR) TAKES PRE-
	SWA  RSCALE	 CEDENCE OVER ANY OTHER DEF'S
	JAT  TYPESE
	SWA  RARRAY	IF NAME IS KNOWN ( AS SCALAR,
	JAT  TYPESE	 ARRAY, OR SUBPROGRAM), RETURN
	SWA  RGSPRO	 POINTER ON WORK STACK WITH
	JAT  TYPESE	 PROPER TAG, & ANSWER TRUE
	SWA  RLSPRO
	JAT  TYPESE
	JUN  EXITFA	ELSE, RETURN ANSWER FALSE
*
TYPESR	EQU  $
	ITA  TINTEG	SEARCH TYPE STACKS FOR NAME IN CENTRAL
	SWA  RINTEG
	JAT  CLR1EX
*
	ITA  TSREAL	IF FOUND, RETURN WITH ASSOCIATED
	SWA  RSREAL	 TAG INSERTED IN W0 PTR, AND
	JAT  CLR1EX 	 ANSWER SET TRUE.
*
	ITA  TDREAL
	SWA  RDREAL
	JAT  CLR1EX
*
	ITA  TDBYTE	* SEARCH BYTE STACK
	SWA  RBYTE	*
	JAT  CLR1EX	*
*
	ITA  TDINT4	* SEARCH INTEGER *1 STACK
	SWA  RINTE4	*
	JAT  CLR1EX	*
*
	ITA  TLOGIC	 INSERTED AND ANSWER SET FALSE
	SWA  RLOGIC
	JAT  CLR1EX
*
	ITA  TC8TYP	* SEARCH COMPLEX *8
	SWA  RCMPL8
	JAT  CLR1EX
*
	ITA  TC6TYP	* SEARCH COMPLEX *16
	SWA  RCMPL6
	JAT  CLR1EX
*
	JUN  EXITFA
*
REGSCA	EQU  $
	PNG  RSCALE	ADD NAME IN CENTRAL TO SCALAR STACK
	PGO  RSCALE	 RETURN POINTER WITH PROPER TAG
*
TYPESE	EQU  $
	JSB  TYPESR	INSERT TAG FOR NAME IN CENTRAL INTO
	JAT  EXIT	 POINTER ON WORK STACK
*
TYPES1	EQU  $
	FET  VSYM1	IF NAME IS ON ID STACK, RETURN
	JML  A1STLT	 ASSOCIATED TYPE
	MUL  K39SQ
	ADP  MLOBLK	ELSE RETURN IMPLICIT TYPE
	SWT  VDATA1
	SWA  RIMPLI
	JAF  TYPESA	IF IMPLICITLY DECLARED, RETURN
	W1   SWTX
	ASP  VDATA1
	FRP  RUNG1	IMPLICIT TYPE
	W1   SWTX
	W1   ITAX
	W1   ASPX
	JUN  EXIT
*
TYPESA	EQU  $
	ASK  VDATA1	ELSE, FOLLOW CONVENTIONS
	CLA  VSYM1
	SLE  KMONE
	JAT  TYPES3
	SLE  MH
	JAT  TYPES4
*
TYPES2	EQU  $
	POW  1		I-N TYPE INTEGER
	ITA  TINTEG
	JUN  EXIT
*
TYPES3	EQU  $
	SLE  MN
	JAT  TYPES2
*
TYPES4	EQU  $
	POW  1		A-J OR O-Z -- TYPE REAL
	ITA  TSREAL
	JUN  EXIT
*
*  TEMPIN IS CALLED AT THE START OF EACH NEW STATEMENT EXECUTION.
*  IT COMPARES THE MAXIMUM NUMBER OF TEMPS USED FOR:
*
*       VCTMPS  COMPARED TO VMTMPS  (REGULAR TEMPS)
*       VCATMP  COMPARED TO VMATMP  (ADDRESS TEMPS)
*
*  TWO OTHER CELLS ARE USED FOR MODULE RESERVED TEMPORARIES (E.G.
*  TEMPORARIES NEEDED FOR ADJUSTABLE DIMENSION CALCULATIONS, ETC.).
*  THEY ARE:
*
*       VITMPS :  RESERVED CALCULATION TEMPORARIES
*       VIATMP :  RESERVED ADDRESS TEMPORARIES
*
*  IF MORE TEMPS WERE USED THAN PREVIOUSLY ALLOCATED, THEN THE
*  MAXIMUM (VMTMPS AND VMATMP) CELLS ARE UPDATED WITH THE NEW COUNT.
*
TEMPIN	EQU  $
	FET  VITMPS	INITIALIZE TEMP CELL COUNTERS
	SWT  VCTMPS
	SLE  VMTMPS
        JAT  $+4	RESET CURRENT COUNTS TO INITIAL
	ASK  VMTMPS	 (NON RESERVED) VALUES
	CLA  VIATMP
	SWT  VCATMP
	SLE  VMATMP	UPDATE MAXIMUM COUNTS AS REQ'D
	JAT  CLR1EX
	ASP  VMATMP
	JUN  EXIT
*
*  ITEMPM : INTEGER TEMPORARY MAKER
*
ITEMPM	EQU  $		GENERATE INTEGER *2 TEMPORARY
	FET  TINTEG	RETURN 2 POINTERS ON WORK STACK
*
*  TEMPMK : MAKE A TEMPORARY OF TYPE ON W0 STACK
*
TEMPMK	EQU  $
	JSB  CALCSI	GENERATE DATA TEMP OF TYPE ON W0
	FET  VELEMS	GET ELEMENT SIZE (IN BYTES)
	ADP  KONE	ROUND UP
	ANP  XFFFE	ROUND OFF
	SCL  8
	SCL  7		 / 2
	ADP  VCTMPS	+ CURRENT TEMPS OFFSET
	SWT  VCTMPS
	SLE  KADRFL
	ADP  PCTEMP	CREATE POINTER
	JAF  ZPCOVE
	W1   ITAX
	W1   ASKX	RETURN 2 TAGGED PTRS ON WORK STACK
	JUN  EXIT	 (1 IN PLACE OF PASSED TAG)
*
*  ATEMPM : MAKE AN ADDRESS TEMPORARY
*
ATEMPM	EQU  $
	FET  VCATMP	GENERATE ADDRESS TEMP
	TLY  VCATMP	(# OF BYTES IN A TEMPORARY)
	SLE  KADRFL
	ADP  PATEMP	CREATE POINTER
	JAF  ZPCOVE
	JUN  EXIT	RETURN SINGLE PTR ON WORK STACK
*
*  CALCSI : CALCULATE SIZE OF ELEMENT.  TOP OF WORK STACK HAS TAGGED
*           POINTER TO VARIABLE.   RETURNS NUMBER OF BYTES IN EACH
*	    ARRAY OR SCALAR ELEMENT IN VARIABLE VELEMS.
*
CALCSI	EQU  $
	ZER  VELEMS	CALCULATE STORAGE SIZE OF ELEMENT WHOSE TAG
	TLY  VELEMS	  IS ON W0
	STG  TDBYTE	* BYTE?
	JAT  EXIT	* YES, JUST EXIT
	TLY  VELEMS	* SET 2 BYTES
	STG  TINTEG	* INTEGER *2?
	JAT  EXIT	*
	STG  TLOGIC	* LOGICAL *2?
	JAT  EXIT	*
	TLY  VELEMS	* SET 4 BYTES
	TLY  VELEMS	*
	STG  TSREAL	* SINGLE PRECISION?
	JAT  EXIT	*
	STG  TDINT4	* INTEGER *4?
	JAT  EXIT	*
	FET  KEIGHT	* TRY FOR 8 BYTES
	ASP  VELEMS
	STG  TDREAL	* DOUBLE PRECISION?
	JAT  EXIT	*
	STG  TC8TYP	* COMPLEX *8?
	JAT  EXIT
	FET  KSXTEE	* GET CONSTANT 16
	ASP  VELEMS	* SAVE AS ELEMENT SIZE
	JUN  EXIT
*
EOLCHE	EQU  $
	SNZ  FACTIO	CHECK FOR END OF LINE
        JAF  $+6
	SCE  ECOLON	TABLE ACTION: MUST BE COLON
	JUN  $+4	ELSE MUST BE CARRIAGE RETURN
	SCE  ECARRT     CARRIAGE RETURN (SIMULATED)?
	JAT  EXIT	 Y -- EXIT TRUE
	JUN  EXITFA	 N -- EXIT FALSE
*
LABELM	EQU  $
	FET  VCMLBL	GENERATE MADE LABEL
	TLY  VCMLBL
	SLE  X3FF
	ADP  PMLABE	UPDATE MADE-LABEL COUNT AND RETURN
	JAF  ZPCOVE	 2 MADE LABEL PTRS ON WORK STACK
	W0   FETX	DUP THE STACK
	JUN  EXIT
*
*  LABELS : SCAN AND REGISTER LABEL REFERENCE
*
LABELS	EQU  $
	SCK  DIGITK	SCAN AND REGISTER LABEL REFERENCES
	JAF  ZSYNTA	IF NON-NUMERIC, ERROR
	JSB  DIGITI	 COMPLETION ACTION
	JSB  DIGITS
	FET  VCSCAN	ELSE SCAN LABEL NUMBER
	SLE  KFIVE	 NUMBER FAIL IF >5 DIGITS
	JAF  ZNUMBE
	SWA  RLABEL	REGISTER LABEL
	JAT  LABEL1
	CLA  VDATA2	IF NOT ON STACK, ADD AS
	ITA  VLBLKE	 UNDEFINED, WITH USE AS
	ASK  VDATA2	 SPECIFIED BY VLBLKE
	PNG  RLABEL
	PGO  RLABEL
*
LABEL1	EQU  $
	ITA  VLBLKE
	W1   ASKX	INSERT USAGE TAG IN PTR & SAVE
	MON  RREFLB
	JUN  EXIT	RETURN TAGGED POINTER TO CALLER
*
*  PARSCM - PARSE A COMPLEX CONSTANT.
*
*  THIS SUBROUTINE IS CALLED TO PARSE A COMPLEX CONSTANT IN FORM
*  OF (X,Y).   IT RETURNS A PROPERLY STORED CONSTANT ON VDATA1-4
*  (FOR COMPLEX *8) OR VDATA1-8 (FOR COMPLEX *16); AND THE CONSTANT
*  TYPE ON TOP OF W0 STACK.
*
PARSCM	EQU  $
	ZER  FMINUS	SET POSITIVE VALUE
	CSA  EPLUS	IF UNARY +, SKIP IT
	JAT  $+8
	CSA  EMINUS	IF UNARY -, SET FLAG
	JAF  $+4
	NOZ  FMINUS
	SCK  DIGITK	MAKE SURE FOLLOWING IS A DIGIT
	JAF  EXITFA	IF NOT, EXIT FALSE
	ZER  VGENID	ZERO INITIAL DIGIT (NONE)
	JML  AGENCO	CONSTANT
	CSA  ECOMMA	COMMA MUST FOLLOW
	JAF  C1EXFA	POP TYPE & EXIT
	FET  VDATA1	SAVE THE FIRST CONSTANT
	ASP  VTEMP1
	FET  VDATA2
	ASP  VTEMP2
	FET  VDATA3
	ASP  VTEMP3
	FET  VDATA4
	ASP  VTEMP4
*			PREVIOUS CONSTANT TYPE STILL ON W0
	ZER  FMINUS
	CSA  EPLUS	IF UNARY PLUS, SKIP IT
	JAT  $+8
	CSA  EMINUS	IF UNARY MINUS, SET FLAG
	JAF  $+4
	NOZ  FMINUS
	SCK  DIGITK	MAKE SURE NEXT IS DIGIT
	JAF  ZNUMBE	IF NOT, NUMBER FAIL
	ZER  VGENID	SET NO PREVIOUS CHARACTER
	JML  AGENCO	GENERATE THE CONSTANT
	CSA  ERPARE	RIGHT PARENTHESIS MUST FOLLOW
	JAF  ZNUMBE	BRIF NOT, ERROR
*
	STG  TSREAL	IS THIS A REAL *4 CONSTANT?
	JAT  PARSCA	BRIF YES, SEE IF 2ND IS REAL *8
*
	STG  TDREAL	IS EITHER CONSTANT A D.P. REAL?
	JAT  PARSCC	BRIF 1ST ARG IS REAL *8
	JUN  ZNUMBE	IF NOT R*4 OR R*8 NUMBER, ERROR
*
PARSCA	EQU  $
	W1   SWTX	SWITCH W0 & W1
	STG  TSREAL	IS SECOND A R*4 NUMBER?
	JAT  PARSCB	BRIF YES
	STG  TDREAL
	JAT  PARSCC	BRIF SECOND ARG IS A R*8 NUMBER
	JUN  ZNUMBE	ELSE, NUMBER FAIL
*
PARSCB	EQU  $
	POW  2		POP OFF 2 VALUES, TYPES FOR CONSTANT
	FET  VDATA1	FORM 8 BYTE CONSTANT
	ASP  VDATA3
	FET  VDATA2
	ASP  VDATA4
	FET  VTEMP1
	ASP  VDATA1
	FET  VTEMP2
	ASP  VDATA4
	FET  TC8TYP	FORCE COMPLEX *8 TYPE
	JUN  EXIT
*
PARSCC	EQU  $
	POW  2		POP OFF 2 VALUES, TYPES FOR CONSTANT
	FET  VDATA1	FORM 16 BYTE CONSTANT
	ASP  VDATA5
	FET  VDATA2
	ASP  VDATA6
	FET  VDATA3
	ASP  VDATA7
	FET  VDATA4
	ASP  VDATA8
	FET  VTEMP1
	ASP  VDATA1
	FET  VTEMP2
	ASP  VDATA2
	FET  VTEMP3
	ASP  VDATA3
	FET  VTEMP4
	ASP  VDATA4
	FET  TC6TYP	FORCE COMPLEX *16 TYPE
	JUN  EXIT
*
	TITL 'START OF STATEMENT TRANSLATION'
*
*  ENTRY INTO INTERPRETER - OPTIONS SCANNING
*
OPTSCA	EQU  $-2	SCAN OPTIONS CARD
	FEX  OPTSC4
	NOZ  F1STPG
	EAW  72
	NOZ  FBLANK
	JOW  OPTSC4
	CLI  8
	JOW  OPTSC4
	CSA  EBLANK
        JAT  $-4
	POW  1
*
OPTSC1	EQU  $
	JML  ASYMSC	SCAN OPTION NAME
	SWA  ROPTIO
	JAF  ZILLOP     UNKNOWN -- GIVE ERROR
	ANP  KADRFL
	JML  AOPTSA	SAVE OPTION FLAG
	JUN  OPTSC3
*
OPTSC3	EQU  $
	POW  1		CHECK FOR NEXT OPTION
	CSA  ECOMMA
	JAT  OPTSC1	Y -- REPEAT OPTION SCAN
	SCE  EBLANK
	JAF  ZSYNTA	N -- ENSURE FOLLOWING BLANK
*
OPTSC4	EQU  $
	ZER  FBLANK
	JML  ANXSTM
*
*  ENTRY INTO INTERPRETER - STATEMENT SCANNING
*
START 	EQU  $-2	SCAN TITLE STATEMENTS IF ANY
	PLD  MBLANK
	PST  VPROGN
	FEX  STMT+2
	CSA  EBLANK	CHECK FOR HEADER STATEMENT
	QSA  QPROGR
	JAT  SPROGR	PROGRAM
	SNZ  FNC	IF NC OR NS=1, PRINT ONLY
	JAT  SETFLA	 LOCAL SYMBOLS FOR FUNCTIONS
	SNZ  FNS	 AND SUBROUTINES
        JAF  $+4
SETFLA	EQU  $
	NOZ  FMAPCT
	QSA  QSUBR
	JAT  SSUBR	SUBROUTINE
	JSB  TYPQTS
	QSF  QFUNC	FUNCTION
*
*  IT'S A FUNCTION SUBPROGRAM.  SCAN FUNCTION NAME & SAVE ARGS
*
SETFL1	EQU  $
	JML  ASYMSC	FUNCTION STATEMENT
	PLD  VSYM1
	CSF  ELPARE	SCAN & SAVE NAME
	SNZ  VINDIR
        JAF  $+4	IF TYPE WAS SPECIFIED, REGISTER
	IND  PGOX	 NAME ON APPROPRIATE ID STACK
	PGO  RSCALE
	TLY  FSPROG	SET FSPROG FOR FUNCTION SUBPROGRAM
	CSA  ERPARE	REGISTER NAME AS SCALAR VARIABLE
	JAF  SPROGA
	JUN  SPROGE	SCAN ARGUMENT LIST IF ANY
*
* SENTRY : PROCESS ENTRY STATEMENT
*
SENTRY	EQU  $		ENTRY INTO A SUBPROGRAM
	CNT  RDOLOO	ANYTHING ON DO LOOP STACK (OR IF/ELSE/ENDIF)?
	JOW  SENTR1	BRIF NOTHING CURRENTLY DEFINED
	JAT  ZSYNTA	ELSE, SYNTAX ERROR (OPEN DO)
*
*  IT'S A FUNCTION SUBPROGRAM.  PROCESS APPROPRIATELY
*
SENTR1	EQU  $
	FET  FSPROG	GET SUBPROGRAM/PROGRAM FLAG
	JOW  ZSYNTA	ERROR IF MAIN PROGRAM
	JOW  SENTR2	BRIF SUBROUTINE, NOT FUNCTION SUBPROGRAM
	JSB  TYPQTS	GET TYPE OF FUNCTION, IF SPECIFIED
	JML  ASYMSC	FUNCTION STATEMENT
	PLD  VSYM1
	CSF  ELPARE	SCAN & SAVE NAME
	SNZ  VINDIR
        JAF  $+4	IF TYPE WAS SPECIFIED, REGISTER
	IND  PGOX	 NAME ON APPROPRIATE ID STACK
	PGO  RSCALE
	CSA  ERPARE	REGISTER NAME AS SCALAR VARIABLE
	JAF  SPROGA
	JUN  SPROGE
*
*  IT'S A SUBROUTINE ENTRY STATEMENT.  PROCESS APPROPRIATELY
*
SENTR2	EQU  $
	JML  ASYMSC	SUBROUTINE STATEMENT
	PLD  VSYM1
	CSA  ELPARE	SCAN & SAVE NAME
	JAF  SPROGE
	JUN  SPROGA
*
*  SUBROUTINE SUBPROGRAM
*
SSUBR 	EQU  $
	JML  ASYMSC	SUBROUTINE STATEMENT
	PLD  VSYM1
	CSA  ELPARE	SCAN & SAVE NAME
	JAF  SPROGE
*
SPROGA	EQU  $
	SNZ  FNC	PROGRAM STATEMENT, IF NC=1,
	JAF  SCANNA	PRINT ONLY LOCAL SYMBOLS
	NOZ  FMAPCT
SCANNA	EQU  $
	JML  ASYMSC	SCAN ARGUMENT LIST (IF ANY)
	SWA  RGDUMM
	JAT  ZID	ARGUMENT NAMES MUST BE UNIQUE
	PGO  RGDUMM
	CSA  ECOMMA	REGISTER ARGS AS GLOBAL DUMMIES
	JAT  SPROGA
	CSF  ERPARE	ENSURE FOLLOWING RIGHT PAREN
*
SPROGE	EQU  $
	SCE  ECARRT	ENSURE FOLLOWING END OF LINE
	JAF  ZSYNTA
	TLY  FSPROG
	NOG  RGDUMM
	FET  KZERO	OUTPUT 'DATA  -#ARGS'
	W1   SUPX	       'ADRL  BASE'
	BIN  CDATA	AS FIRST LOGIC
	CLA  PBASE
	BIN  CADRL	SET PROGRAM NAME
	CFC  RPROLO
	JUN  HEADRE
*
*  PROGRAM STATEMENT
*
SPROGR	EQU  $
	JML  ASYMSC	PROGRAM STATEMENT
	PLD  VSYM1
	SCE  ECARRT	SCAN & SAVE NAME
	JAF  ZSYNTA
*
HEADRE	EQU  $
	PST  VPROGN	SET PROGRAM NAME
*
STMT  	EQU  $
	JML  ANXSTM	TRANSLATE PROGRAM BODY
	FEX  STMT12
	NOZ  FBLANK	INITIALIZE FOR STATEMENT
	JSB  DIGITI	INIT SCAN POS & ERROR FLAGS
	ZER  PSTALB	SET FAIL EXIT TO PRINT STMT
	FET  KFIVE	SET UP FOR SCAN OF LABEL FIELD
*
STMT1 	EQU  $
	JOW  STMT2	SCAN LABEL FIELD (COLUMNS 1-5)
	CSA  EBLANK
	JAT  STMT1	MUST CONTAIN BLANKS AND/OR DIGITS
	SCK  DIGITK
	JAF  ZSYNTA
	NOZ  PSTALB
	JSB  DIGITC	CONVERT LABEL DIGITS TO BINARY
	JML  ANXTCH
	JUN  STMT1
*
STMT2 	EQU  $
	ZER  FBLANK	INSURE COLUMN 6 CONTAINS BLANK OR ZERO
	CSA  EBLANK
	JAT  NOTBLL
	CSF  EZERO
NOTBLL	EQU  $
	SNZ  PSTALB	REGISTER STATEMENT LABEL IF ANY
	JAF  STMT5
	SWA  RLABEL	NONE -- SCAN TEXT FIELD
	JAT  STMT3
	FET  VDATA2	UNKNOWN LABEL :
	ADP  KDEFLB	ENTER ON LABEL STACK AS
	ASP  VDATA2	 CURRENT LABEL ( WITH MEAN-
	PNG  RLABEL	 INGLESS USAGE TAG) & BUILD
	PGO  RLABEL	 LABEL INSTRUCTION
	JUN  STMT4
*
STMT3 	EQU  $
	W0   FETX	KNOWN LABEL:
	W0   FETX	 IF NOT PREVIOUSLY DEFINED,
	FRP  RUNG0	 FLAG IS DEFINED (WITH MEAN-
	SOP  OUNDEF	 INGFUL USAGE TAG) & BUILD
	ADP  KDEFLB	 LABEL INSTRUCTION
	ADP  KDEFLB
	ARP  RUNG0	IF PREVIOUSLY DEFINED, FLAG
	JAT  STMT4	AS MULTIPLY DEFINED & IGNORE
	POW  1
	ZER  PSTALB
	JUN  STMT5
*
STMT4 	EQU  $
	ASK  PSTALB	SAVE LABEL POINTER
	BIN  CLABEL	BUILD LABEL INSTRUCTION
*
STMT5 	EQU  $
	JSB  TEMPIN	SCAN TEXT FIELD OF STATEMENT
	JSB  STAXLA	SCAN TEXT AND GENERATE CODE
	JAT  STMT5A
STMT5B	EQU  $
	ZER  VLBLKE	ERROR STATEMENT LBL ALLOWS BRANCH ONLY
	JUN  STMT6
STMT5A	EQU  $
	SNZ  FUNCLS
	JAT  STMT5B
	SNZ  FPRGEN	GENERATE ERROR ('MISSING ENDIF')
	JAF  STMT5C	IF RIF NOT EMPTY
	MOA  RIF
	JAF  STMT5C
	MON  RIF
	EAW  QUNCLS
	FET  PLSTCH
	ASP  PERRCH
	ASP  PERRMS
	JUN  STMT5B
STMT5C	EQU  $		RESET ERROR FLAG IF STATEMENT OK
	ZER  PERRMS
*
STMT6 	EQU  $
	SNZ  PSTALB	SET USAGE TAG OF STMT LBL
	JAF  STMT8	NONE -- SKIP
	FET  PSTALB
	ITA  VLBLKE	IF 'CURRENT' LABEL, SIMPLY DEFINE
	JSB  CONFLC	 BY STATEMENT TYPE
	JAT  STMT8
	STG  TGOTO	IF  'DEFINED' LABEL, CHECK USAGE
	JAF  STMT9	 CONFLICT. N -- SET BY TYPE
*
STMT7 	EQU  $
	W1   ITAX	DEFINE FROM USAGE
	ARP  RUNG0
*
STMT8 	EQU  $
	MOA  RREFLB	SET USAGE TAGS OF REF'D LABELS
	JAF  STMT10	FOR EACH ONE:
	JSB  CONFLC
	JAT  STMT8	CHECK FOR USAGE CONFLICT
	STG  TGOTO
        JAT  $+6	'GOTO' LABEL
	POW  2		VALID IF LABEL IS UNDEFINED
	JUN  STMT8	INSERT EXEC TAG IN LABLE
	SOP  OUNDEF
	JAT  STMT7	MISUSE IF LABEL IS DEFINED
*
STMT9 	EQU  $
	JSB  MISUSE	FLAG LABEL MISUSED
	JUN  STMT8
*
STMT10	EQU  $
	SNZ  PSTALB	CHECK FOR CLOSING STATEMENT OF
	JAF  STMT12	DO LOOP
*
STMT1A	EQU  $
	MOA  RDOLOO
	JAF  STMT12	CHECK IS MADE ONLY AGAINST
	SAD  PSTALB	LATEST DO LOOP. A NESTING
	JAT  STMT11	ERROR WILL CAUSE THE OUTER
	MON  RDOLOO	DO LABELS TO BE UNRECOGNIZED
	JUN  STMT12
*
STMT11	EQU  $
	POW  1		OUTPUT CLOSING DO LOOP CODE
	MOA  RDOLOO
	ASP  VIATMP
	MOA  RDOLOO	RESET COUNT OF ADDRESS TEMPS
	ASP  VITMPS	RESET COUNT OF NON-ADDRESS TEMPS RESERVED
	CTC  RDOLOO	TO VALUE AT START OF LOOP
	SNZ  FJUMP
	JAF  STMT1A	COPY CODE TO CODE STACK
	FET  PSTALB
	FET  PSTALB	IF CLOSING LABEL WAS ON JUMP
	FRP  RUNG0	STATEMENT, FLAG AS MISUSED
	JSB  MISUSE
	JUN  STMT1A
*
STMT12	EQU  $
	REL  RDELTA	TERMINATE CURRENT STATEMENT
	REL  RWORK	RELEASE TEMP STACKS, PRINT &
	JUN  STMT	 PUNCH STMT, THEN SCAN NEXT
*
CONFLC	EQU  $
	W0   FETX	CHECK FOR LABEL USAGE CONFLICT
	FRP  RUNG0
	SOP  OCURLB	'CURRENT' LABEL
        JAF  $+6	NO CONFLICT POSSIBLE.  UPDATE
	ADP  KDEFLB	TO 'DEFINED' STATUS & RETURN
	JUN  EXITFA	ANSWER FALSE
	W1   STGX	USAGE MATCH:
	JAT  CLR2EX	SIMPLY RETURN ANSWER TRUE
	STG  TFORMA
	JAT  MISUSE	FORMAT/NON-FORMAT CONFLICT:
	W1   SWTX	FLAG MISUSED & RETURN TRUE
	STG  TFORMA
	W1   SWTX	ELSE CHECK DEPENDS ON LABEL TYPE
	JAF  EXITFA	SIMPLY EXIT FALSE
*
MISUSE	EQU  $
	ITA  TMISUS	FLAG LABEL MISUSED
	ARP  RUNG0	FLAG & ALTER STACK ENTRY
	JUN  EXIT	RETURN
*
	PAGE
*
*  STAXLA - TEXT FIELD TRANSLATION
*
STAXLA	EQU  $
	JML  ASTATU	TRANSLATE TEXT FIELD OF STATEMENT
	FEX  SKEYWD
	ZER  FINDRC
	JSB  IDSCAN	FIRST TRY AS ASSIGNMENT STATEMENT
	JAT  SASSIG	 OR STATEMENT FUNCTION DEF'S
	CSA  ELPARE	IF NOT, THEN SCAN FOR KEYWORD.
	JAT  SSTFUN
	JSB  REGSCA
	JUN  SASSN2
*
	TITL 'ASSIGNMENT STATEMENT'
*
*  ASSIGNMENT STATEMENTS
*
SASSIG	EQU  $
	JSB  VARCHE	TRANSLATE ASSIGNMENT STATEMENT
	JAF  ZSCRIP	LH NAME IS VARIABLE
*
SASSN2	EQU  $
	CSF  EEQUAL	IF NO '=', TAKE FAIL EXIT
	JSB  RHEXPR	
	BIM  CSTORE	ELSE, GENERATE RIGHT HAND EXPR
	JUN  ACTVEX	EVALUATION AND STORE
*
*  STATEMENT FUNCTION
*
SSTFUN	EQU  $
	SNZ  FACTIV	TRANSLATE STATEMENT FUNCTION DEF'N
	JAT  ZSYNTA	MUST APPEAR BEFORE ANY ACTIVE STATEMENT
	SCK  LETTRK
	JAF  ZSYNTA
	SWA  RGDUMM
	JAT  ZID	FUNCTION NAME MUST BE UNKNOWN
	JSB  LABELM
	BIN  CB		GENERATE BRANCH AROUND
	JSB  LABELM
	BIN  CLABEL	GENERATE FUNCTION MADE LABEL
	JSB  TYPESE
	ASP  VDATA1	RESERVE RETURN ADDRESS TEMP
	JSB  ATEMPM
	ITA  VDATA1	ENTER NAME AS LOCAL SPROG
	PGO  RLSPRO
*
STAFU1	EQU  $
	JML  ASYMSC	SCAN DUMMY ARGUMENT LIST
	SWA  RLDUMM
	JAT  ZID	SAME NAME MAY NOT APPEAR TWICE
	JSB  ATEMPM
	ASP  VDATA1	GENERATE DUMMY ADDRESS TEMP
	PGO  RLDUMM
	CSA  ECOMMA	CHECK FOR NEXT ARGUMENT
	JAT  STAFU1
	CSF  ERPARE	ENSURE FOLLOWING ')='
	CSF  EEQUAL
	NOG  RLDUMM	GENERATE NEGATIVE ARGUMENT COUNT
	FET  KZERO
	W1   SUPX	GENERATE RETURN ADDRESS TEMP ADRL
	BIN  CDATA
	W1   CLAX	GEN CODE TO EVALUATE FUNCTION &
	BIN  CADRL	RETURN RESULT IN ACCUMULATOR
	JSB  RHEXPR
	BIN  CFUNCE	GENERATE FUNCTION EXIT CODE
	BIN  CLABEL
	REL  RLDUMM	GENERATE BRANCH AROUND TARGET
	JSB  EOLCHE	 LABEL
	JAF  ZSYNTA
	FET  VCATMP	RESERVE ADDRESS TEMPORARIES USED
	ASK  VIATMP
	CLA  VCTMPS
	ASP  VITMPS
	JUN  FUNCEX
	TITL 'KEYWORD STATEMENTS'
*
*  KEYWORD STATEMENTS BRANCH TABLE
*
SKEYWD	EQU  $
	FEX  EXITFA	TRANSLATE KEYWORD STATEMENT
	SNZ  FNTSPE
	JAT  SACTIV
	QSA  QDATA	IF NON-SPECIFICATION STATEMENT
	JAT  SDATA	 HAS BEEN SEEN, DON'T BOTHER
	QSA  QDIMEN	 CHECKING FOR SPECIFICATION.
	JAT  SDIMEN
	JSB  TYPQTS
	JAT  STYPE
	QSA  QCOMMO
	JAT  SCOMMO	COMMON
	QSA  QEQUIV
	JAT  SEQUIV	EQUIVALENCE
	QSA  QEXTER
	JAT  SEXTER	EXTERNAL
	QSA  QIMPLI
	JAT  SIMPLI	IMPLICIT
*
SACTIV	EQU  $
	QSA  QDOWHI
	JAT  SDOWHI	DO WHILE
	QSA  QDO
	JAT  SDO	DO
	QSA  QIF
	JAT  SIF	IF
	QSA  QGOTO
	JAT  SGOTO	GOTO
	QSA  QCALL
	JAT  SCALL	CALL
	QSA  QREAD
	JAT  SREAD	READ
	QSA  QREAD1
	JAT  SACCEP	READ (WITH NO PARENTHESIS)
	QSA  QACCEP
	JAT  SACCEP	ACCEPT
	QSA  QWRITE
	JAT  SWRITE	WRITE
	QSA  QTYPES
	JAT  STYPES	TYPE
	QSA  QPRINT
	JAT  SPRINT	PRINT
	QSA  QFORMA
	JAT  SFORMA	FORMAT
	QSA  QCONTI
	JAT  ACTVEX	CONTINUE (NO CODE)
	QSA  QSTOP
	JAT  SSTOP	STOP
	QSA  QPAUSE
	JAT  SPAUSE	PAUSE
	QSA  QRETUR
	JAT  SRETUR	RETURN
	QSA  QENDIF
	JAT  SENDIF	ENDIF
	QSA  QENDDO
	JAT  SENDDO	ENDDO
	QSA  QREPEA
	JAT  SENDDO	REPEAT (SAME AS ENDDO)
	QSA  QEND
	JAT  SEND	END
	QSA  QINCLU
	JAT  SINCLU	INCLUDE
	QSA  QELSEI
	JAT  SELSEI	ELSEIF
	QSA  QELSE
	JAT  SELSE	ELSE
	QSA  QENTRY
	JAT  SENTRY	ENTRY
	JUN  C1EXFA
	TITL 'SPECIFICATION STATEMENTS'
	PAGE
*
*  DIMENSION STATEMENT
*
SDIMEN	EQU  $
	JSB  IDSCAN
	JAT  ZID
	CSF  ELPARE	NAME MUST NOT HAVE BEEN PREVOUSLY
	JSB  DIMENS
	CSA  ECOMMA
	JAT  SDIMEN	REPEAT FOR EACH NAME IN LIST
	JUN  SPECEX
*
*  TYPE STATEMENTS
*
TYPQTS	EQU  $
	EAW  DINTEG
	QSA  QINTEG
	JAF  TYPQTA
	CSA  EASTRS	IS IT INTEGER *1, INTEGER *2, OR INTEGER *4?
	JAF  TYPQT1	ASSUME INTEGER *2 IF NOT SPECIFIED
	CSA  ETWO	IS IT INTEGER *2?
	JAT  TYPQT1
	CLI  DBYTE	IS IT INTEGER *1?
	CSA  EONE
	JAT  TYPQT1
	CLI  DINTE4	IS IT INTEGER *4?
	CSA  EFOUR
	JAT  TYPQT1
*
TYPQTA	EQU  $
	CLI  DSREAL
	QSA  QREAL
	JAF  TYPQTB
	CSA  EASTRS	IS IT REAL *4, REAL *4?
	JAF  TYPQT1	BRIF NOT SPECIFIED, ASSUME REAL *4
	CSA  EFOUR
	JAT  TYPQT1	BRIF REAL *4
	CLI  DDREAL
	CSA  EEIGHT
	JAT  TYPQT1	BRIF REAL *8
*
TYPQTB	EQU  $
	CLI  DDREAL
	QSA  QDBLPR
	JAT  TYPQT1
*
	CLI  DLOGIC
	QSA  QLOGIC
	JAF  TYPQTC
*
	CSA  EASTRS	IS IT LOGICAL *2
	JAF  TYPQT1	BRIF NOT SPECIFIED, ASSUME LOGICAL *2
	CSA  ETWO
	JAT  TYPQT1	BRIF LOGICAL *2
*
TYPQTC	EQU  $
	CLI  DBYTE
	QSA  QBYTE	BRIF INTEGER *1 (BYTE)
	JAT  TYPQT1
*
	CLI  DBYTE
	QSA  QCHARA	BRIF CHARACTER *1 (BYTE)
	JAT  TYPQT1
*
	CLI  DCMLX8	TRY FOR COMPLEX *8
	QSA  QCOMPL
	JAF  C1EXFA	BRIF NOT COMPLEX, DON'T UNDERSTAND STATEMENT
	CSA  EASTRS	IS THERE AN ASTERICK?
	JAF  TYPQT1	BRIF NO, IT IS COMPLEX *8
	CSA  EEIGHT	IS THERE AN EIGHT?
	JAT  TYPQT1	BRIF YES, IT'S TYPE COMPLEX *8
	CSA  EONE	IS IT A ONE?
	JAF  C1EXFA	BRIF NO, ERROR
	CSA  ESIX	IS IT A SIX?
	JAF  C1EXFA	BRIF NO, ERROR
	CLI  DCMLX6	ELSE, IT IS COMPLEX *16
*
TYPQT1	EQU  $
	ASP  VINDIR
	JUN  EXIT
*
TYPETA	EQU  $
	EAW  DINTEG	CONVERT TYPE STACK # TO TAG
	FET  VINDIR
	W1   SUPX	SUBTRACT RINTEG # FROM STACK #
	SCL  7		* IN VINDIR & SHIFT TO
	ASP  VDATA2	TAG FIELD OF VDATA2
	JUN  CLR1EX
*
STYPE 	EQU  $
*
STYPE1	EQU  $
	FET  KZERO	TYPE DECLARATION
*
STYPE2	EQU  $
	JSB  IDSCAN
	JAT  ZID	DECLARED NAMES MUST NOT BE KNOWN
	JSB  TYPESR	AND MAY NOT HAVE BEEN DECLARED
        JAT  $+6
	IND  PGOX
        JUN  $+8
	JSB  TYPETA
	STG  VDATA2
	JAF  ZTYPE
	CSA  ELPARE	REGISTER DECLARED NAME ON APPROPRIATE TYPE STACK
        JAF  $+4
	JSB  DIMENS
	CSA  ECOMMA	IF NAME SUBSCRIPTED, SCAN DIMENSIONS AND DEFINE
	JAT  STYPE2	 ARRAY
	POW  1
	JUN  SPECEX
*
SIMPLI	EQU  $
	CNT  RARRAY	TRANSLATE IMPLICIT STATEMENT
        JOW  $+4
	JUN  ZTYPE	GENERATE TYPE CONFLICT IF ANY
	JSB  TYPQTS	 ARRAYS DEFINED
	JAF  ZSYNTA
	CSF  ELPARE	SCAN IMPLICIT TYPE & SET TAG
	JSB  TYPETA	 IN VDATA2
*
SIMPL1	EQU  $
	JSB  IMPLCL	SCAN LETTER & REGISTER ON RIMPLIC
	JSB  IMPLCR
	CSA  EMINUS
	JAF  SIMPL2	CHECK FOR RANGE (-)
	JSB  IMPLCL
	W1   SLEX	Y -- SCAN RANGE END & INSURE
	JAT  ZID	     IN ALPHABETICAL ORDER
	W1   SWTX
	ADP  KONE	REGISTER EACH LETTER IN RANGE
	JSB  IMPLCR	 ON RIMPLI
	W1   SNEX
        JAT  $-6
	POW  1
*
SIMPL2	EQU  $
	POW  1		SCAN & PROCESS REMAINING
	CSA  ECOMMA	 PARAMETERS IF ANY
	JAT  SIMPL1
	CSF  ERPARE	ENSURE CLOSING PAREN & EXIT
	JUN  SPECEX
*
IMPLCL	EQU  $		SCAN IMPLICIT STMT LETTER
	JML  ASYMSC
	FET  MBLANK
	SNE  VSYM2	ENSURE SINGLE LETTER
	JAT  ZID
	SNE  VSYM3
	JAT  ZID	N -- ID CONFLICT
	CLA  VSYM1
	JML  A1STLT	RETURN LETTER ON WA
	JAT  EXIT
	JUN  ZID
*
IMPLCR	EQU  $
	ASK  VDATA1	REGISTER IMPLICIT STMT LETTER
	MUL  K39SQ
	ADP  MLOBLK
	SWT  VDATA1	PAD ON RIGHT WITH MOD39 BLANKS
	SWA  RIMPLI
        JAT  $+6	BUILD 2-WORD GROUP WITH LETTER
	PGO  RIMPLI	 AND TYPE TAG
	JUN  EXIT
	FRP  RUNG1	IF ALREADY ON RIMPLI, INSURE
	STG  VDATA2	 MATCHING TYPE
	JAT  CLR1EX
	JUN  ZTYPE
	TITL 'COMMON STATEMENT'
	PAGE
*
*  COMMON STATEMENT
*
SCOMMO	EQU  $
	JSB  CMNAME	TRANSLATE COMMON STATEMENT
	PGO  RCOMMO	SCAN VARIABLE NAME
	CSA  ECOMMA	ENTER NAME ON RCOMMO
	JAT  SCOMMO	REPEAT FOR EACH NAME
	JUN  SPECEX
*
CMNAME	EQU  $
	JML  ASYMSC	SCAN NAME DECLARED IN COMMON
	SWA  RGDUMM
	JAT  ZALLOC	MAY NOT BE DUMMY NAME
	SWA  RCOMMO
	JAT  ZALLOC
	SWA  RCMNAM	PREVIOUSLY IN COMMON
	JAT  ZALLOC
	CSA  ELPARE	CHECK FOR ARRAY DECLARATION
	JAF  EXIT	N -- RETURN
	JSB  IDCHEC
	JAF  DIMENS	Y -- INSURE NAME CURRENTLY UNDEFINED,THEN DEFINE
	JUN  ZID
*
	TITL 'DIMENSIONS SCAN'
	PAGE
*
*  DIMENSIONS SCAN
*
DIMENS	EQU  $
	PNG  RARRAY
	JSB  TYPESE	INITIALIZE
	JSB  CALCSI	ARRAY STACK POINTER ON WORK STACK
	RSV  RTEMP	ARRAY ELEMENT SIZE (IN BYTES) IN VELEMS
	FET  PLSTCH	LAST CHAR POINTER ON WORK STACK
	FET  KZERO	INITIAL OFFSET ON WORK STACK
	FET  VELEMS	FIRST MULTIPLIER ON WORK STACK
*
DIMEN1	EQU  $
	SCK  LETTRK	CHECK FOR VARIABLE
	JAT  ADJDIM	Y -- MUST BE ADJUSTABLE DUMMY
	JSB  INTSCA
	FET  VDATA3	ELSE GET INTEGER DIMENSION
	SLE  KZERO	IF <1 TAKE ALLOCATION FAIL
	JAT  ZALLOC
	W1   MULX	COMPUTE NEXT MULTIPLIER
	W1   SWTX
	W2   ADPX	UPDATE OFFSET VALUE
	W2   ASKX
	W1   CLAX	SAVE CURRENT MULTIPLER
	MON  RTEMP
	CSA  ECOMMA	CHECK FOR NEXT DIMENSION
	JAT  DIMEN1	Y -- REPEAT
	CSF  ERPARE	N -- SYNTAX FAIL UNLESS RPAREN
	POW  1		FIXED DIMENSIONS
	W2   ASKX
	POW  2		SAVE OFFSET -- DISCARD T VALUE,
	PNG  RASTAT	CHAR COUNT, AND ARRAY POINTER
	CNT  RTEMP
	MON  RASTAT	CREATE STATS PLEX
	EAW  DASTAT
	CAR  RTEMP	PLEX COUNT & MULTIPLIER
	SWA  RGDUMM
        JAF  $+6	INSERT DUMMY TAG IN STATS POINTER
	POW  1          IF DUMMY ARRAY
	ITA  TDUMMY
	ASP  VDATA1	SET STATS POINTER & OFFSET VALUE
	ASP  VDATA2
	PGO  RARRAY	PUT GROUP ON ARRAY STACK & RETURN
	JUN  EXIT	 TO CALLER
*
ADJDIM	EQU  $
	POW  2		ADJUSTABLE DIMENSIONS
	SWA  RGDUMM
	JAF  ZALLOC	ALLOCATION FAIL UNLESS DUMMY ARRAY
	REL  RTEMP
	RSV  RTEMP	RE-INITIALIZE FOR ADJUSTABLE SCAN
	W1   SWTX	DISCARD ANY MULTIPLIERS
	ASP  PCURCH	DISCARD OFFSET VALUE
	JML  ANXTCH	RESET SCAN POSITION
	RSV  RCODE	RESERVE CODE STACK
	FET  VELEMS	SAVE ELEMSZ FOR OFFSET CALC
	FET  VELEMS	GEN 'LD =ELEMSZ' FOR TEMPORARY CALC
	JSB  REGWKC
	BIN  CLOAD
*
ADJDI1	EQU  $
	SCK  LETTRK	SCAN ADJUSTABLE DIMENSIONS
	JAF  ADJDI2
	JSB  ISCALS	VARIABLE:
	SWA  RGDUMM
	JAF  ZALLOC	ALLOCATION FAIL UNLESS DUMMY VARIABLE
	POW  1
	JUN  ADJDI3
*
ADJDI2	EQU  $
	JSB  INTSCA	CONSTANT:
	FET  VDATA3
	SLE  KONE	ALLOCATION FAIL UNLESS >1
	JAT  ZALLOC
	JSB  REGWKC
*
ADJDI3	EQU  $
	W0   FETX	GEN 'MUL D(I)'
	BIM  CMULT	SAVE D(I) POINTER
	MON  RTEMP
	CSA  ECOMMA	CHECK FOR NEXT DIMENSION
	JAT  ADJDI1	 Y -- REPEAT
	CSF  ERPARE	 N -- SYNTAX FAIL UNLESS RIGHT PARENTHESIS
*
	JSB  ITEMPM	RESERVE TEMPORARY CELL & GEN
	BIN  CSTORE	 STORE OF TEMPORARY CELL
	MOA  RTEMP
	POW  1		DISCARD LAST DIMENSION
	MON  RTEMP	SAVE TEMPORARY POINTER INSTEAD
	TLY  VITMPS	TALLY RESERVED CALCULATION TEMPS
	PNG  RASTAT	SET STATS POINTER
	ITA  TADJUS	INSERT ADJUSTABLE TAG
*
	CNT  RTEMP	CREATE STATS PLEX
	MON  RASTAT	PLEX COUNT & DIMENS POINTER
	EAW  DASTAT
	CAR  RTEMP
	RSV  RTEMP	GENERATE OFFSET CALCULATION
	W3   ASKX
	CPO  RTEMP	IF 1-DIMENSIONAL ARRAY, NONE REQUIRED
	MOA  RTEMP	 JUST SET OFFSET 0 (AS FLAG)
	CLA  KZERO
	MOA  RTEMP	ELSE GEN 'LD  D(N-1)'
	JAF  ADJDI5		 'INC R5'
	BIM  CLOAD
*
ADJDI4	EQU  $
	POC  IINCR5	FOR EACH ADDITIONAL DIMENSION,
	MOA  RTEMP	GENERATE: 'MUL D(I-1)'
        JAF  $+6		  'INC R5'
	BIM  CMULT
	JUN  ADJDI4
*
	W1   CLAX	GENERATE  'MUL =ELEMSZ'
	JSB  GENIMU
	JSB  ITEMPM	RESERVE TEMP CELL & GENERATE
	BIN  CSTORE	STORE OF OFFSET VALUE
	TLY  VITMPS	OFFSET = TEMPORARY POINTER.
*
ADJDI5	EQU  $
	REL  RTEMP	CREATE ADJUSTABLE DIMENSION ARRAY STACK GROUP
	W2   SWTX
	JML  ALDGRP
	POW  2		NAME
	ASP  VDATA2	OFFSET TEMP PTR (OR 0)
	ASP  VDATA1	STATS POINTER
	PGO  RARRAY
	CFC  RPROLO	SAVE GENERATED CODE & RETURN
	JUN  EXIT	TO CALLER
	TITL 'EQUIVALENCE STATEMENT'
	PAGE
*
*  EQUIVALENCE STATEMENT
*
SEQUIV	EQU  $
	CSF  ELPARE	TRANSLATE EQUIVALENCE STATEMENT
	FET  KMARKE
	ASP  VSYM1	PRECEDE EQUIVALENCE SET MY MARKER GROUP
	PGO  REQUIV
SEQUI0	EQU  $
	JML  ASYMSC
	SWA  RGDUMM	EQUIVALENCED NAME MAY NOT BE
	JAT  ZALLOC	 GLOBAL DUMMY
	SWA  RARRAY
        JAF  $+8
	CSA  ELPARE	IF NAME IS SCALAR, UNSUBSCRIPTED
	JAT  SEQUI1	 ARRAY, OR UNKNOWN, PUT NAME
	POW  1		 ON REQUIV WITH ZERO OFFSET
	ZER  VDATA1
	JUN  SEQUI6
*
SEQUI1	EQU  $
	JSB  TYPESE	IF NAME IS ARRAY WITH SINGLE
	JSB  CALCSI	 SUBSCRIPT, SUBSCRIPT GIVES
	JSB  SCRSET	 ELEMENT NUMBER BY ALLOCATION
	POW  1		 (COLUMN-MAJOR ORDER) REGARDLESS
	JSB  INTSCA	 OF DIMENSIONALITY OF ARRAY
	CSA  ERPARE
	JAF  SEQUI2
	CLA  VDATA3	COMPUTE WORD DISPLACEMENT OF
	JOW  ZSCRIP	 SPECIFIED ELEMENT AND PUT
	MUL  VELEMS	 NAME ON REQUIV WITH THIS
	JUN  SEQUI5
*
SEQUI2	EQU  $
	CLA  KZERO	IF NAME IS ARRAY WITH MULTIPLE
	SUP  VOFFSE	 SUBSCRIPTS, SUBSCRIPTS SPECIFY
	FLP  RTEMP	 ELEMENT IN STANDARD FASHION
	FET  VELEMS
*
SEQUI3	EQU  $
	MUL  VDATA3
	W1   ADPX	NUMBER OF SUBSCRIPTS MUST
	W1   ASPX	 MATCH DIMENSIONALITY OF
	MOA  RTEMP	 ARRAY
	JAF  SEQUI4
	CSA  ECOMMA
	JAF  ZSCRIP	COMPUTE WORD DISPLACEMENT OF
	JSB  INTSCA	 SPECIFIED ELEMENT
	JUN  SEQUI3
*
SEQUI4	EQU  $
	CSA  ERPARE	INSURE PROPER SCRIPT COUNT
	JAF  ZSCRIP
	SLE  KMONE
	JAT  ZSCRIP	INSURE DISPLACEMENT NOT < 0
*
SEQUI5	EQU  $
	SWT  VMAXSC
	SLE  VMAXSC	INSURE DISPLACEMENT < SIZE
	JAT  ZSCRIP
	CLA  VMAXSC
	ASP  VDATA1	PUT NAME ON REQUIV WITH
	REL  RTEMP	 DISP AS OFFSET
*
SEQUI6	EQU  $
	PGO  REQUIV	PUT NAME AND OFFSET ON REQUIV
	CSA  ECOMMA
	JAT  SEQUI0	REPEAT FOR EACH NAME IN GROUP
	CSF  ERPARE
	CSA  ECOMMA
	JAT  SEQUIV	IF ANOTHER GROUP, REPEAT AS IF
	JUN  SPECEX	 NEW STATEMENT
	TITL 'EXTERNAL STATEMENT'
	PAGE
*
*  EXTERNAL STATEMENT
*
SEXTER	EQU  $
	JSB  IDSCAN	TRANSLATE EXTERNAL STATEMENT
	JAT  ZID
	SWA  RGDUMM	NAMES MUST BE UNKNOWN
	JAT  ZID
	PNG  RGDUMM	REGISTER NAMES AS IF DUMMY
	PGO  RGDUMM	 ARGUMENTS OF SUBROUTINE
	ASP  VDATA1
	PGO  REXTER	REGISTER NAMES AS EXTERNALS
	CSA  ECOMMA	 WITH DUMMAY ARGUMENT INDEX
	JAT  SEXTER
	JUN  SPECEX	REPEAT FOR EACH NAME
	TITL 'DATA STATEMENT'
	PAGE
*
*  DATA STATEMENT
*
SDATA 	EQU  $
	RSV  RTEMP	TRANSLATE DATA STATEMENT
	RSV  RTEMP1
	FET  KZERO
*
DATALI	EQU  $
	JSB  IDSCAN	SCAN LIST OF VARIABLES
        JAT  $+4
	JSB  REGSCA	NAME MUST BE LOCALLY-ALLOCATED
	SWA  RGDUMM	 SCALAR OR ARRAY VARIABLE
	JAT  ZALLOC
	JSB  CALCSI	CALCULATE SIZE OF SINGLE DATA ELEMENT
	FET  VELEMS	 FETCH IT
	MON  RTEMP1	 MOVE ON TO WORK STACK
	JSB  VARCHE	SCAN SUBSCRIPTS, IF ANY
	JAT  DATAL1
	JSB  SCRSET	IF NON-SUBSCRIPTED ARRAY, ENTIRE
	CLA  VMAXSC	 ARRAY IS TO BE INITIALIZED
	ASK  VELEMS
	REL  RTEMP
	W1   SWTX	OUTPUT ARRAY POINTER FOLLOWED
	JUN  DATAL4
*
DATAL1	EQU  $
	JSB  CALCSI	SCALAR OR ARRAY ELEMENT
	SOP  RSCALE
	JAT  DATAL5	IF SCALAR, OUTPUT SCALAR POINTER
	SOP  RDELTA
	JAF  ZSCRIP	IF ARRAY ELEMENT, MUST HAVE
	W0   FETX	CONSTANT SUBSCRIPTS
	FRP  RUNG1
	W1   SWTX	OUTPUT ARRAY-ELEMENT POINTER
	FRP  RUNG0	FOLLOWED BY WORD DISPLACEMENT
	ANP  X3FF	OF ELEMENT
	ADP  PARYEL
*
DATAL4	EQU  $
	MON  RTEMP
*
DATAL5	EQU  $
	FET  VELEMS	ELEMENT SIZE UPDATED FOR ARRAY SIZE
	MON  RTEMP1	SAVE ON WORK STACK
	MON  RTEMP	UPDATE TOTAL DATA WORD COUNT
	SUP  VELEMS	(KEPT NEGATIVE)
	CSA  ECOMMA	SCAN NEXT VARIABLE IF ANY
	JAT  DATALI
*
*  END OF VARIABLE ITEM LIST.  START PARSING DATA ITEMS
*
	FLP  RTEMP1	FLIP STACK OF VARIABLE LENGTHS
	CSF  ESLASH	AT END OF VARIABLE LIST, INITIALIZE FOR
	CNT  RTEMP	SCAN OF DATA ITEMS -- PRECEDE
	BIN  CDATST	VARIABLE LIST BY:
	CTC  RTEMP	'DATASTMT  LISTCOUNT'
*
DATUM 	EQU  $
	FET  KONE	SCAN DATA ITEMS
	ZER  VSELEM	ZERO SIZE OF THIS ELEMENT
	ZER  VARRSI	ZERO TOTAL SIZE OF ELEMENT
*
DATUMA	EQU  $
	FET  VARRSI	FETCH THE CURRENT ELEMENT TOTAL SIZE
	SLE  KZERO	IS TOTAL SIZE <= ZERO?
	POW  1
	JAF  DATUMD	BRIF NO, MORE TO GET FOR THIS VARIABLE
*
	MOA  RTEMP1	GET NEXT ELEMENT SIZE
	JAF  DATUMC	BRIF EMPTY SIZE STACK (ERROR)
	ASP  VSELEM
*
	MOA  RTEMP1	GET TOTAL ARRAY SIZE (MAY BE SAME AS ELEMENT SIZE)
	JAF  DATUMC	BRIF EMPTY SIZE STACK (ERROR)
	ASP  VARRSI
	JUN  DATUMD	- GO PROCESS DATA
*
*  START PARSING THE ACTUAL DATA CONTAINED IN SLASHES / ... /
*
DATUMD	EQU  $
	SCE  EQUOTE	QUOTE STRING
	JAT  DATUMJ
	CSA  EZ		* HEXADECIMAL CONSTANT
	JAT  DATUMG     *
	CSA  EO		* OCTAL CONSTANT
	JAT  DATUMO	*
	CSA  EB		* BINARY CONSTANT
	JAT  DATUMP	*
	CSA  ECAT	ADDRESS LITERAL
	JAT  DATUMH
	ZER  FMINUS	CLEAR MINUS FLAG
	CSA  EPLUS	UNARY PLUS (IGNORE)
        JAT  $+8
	CSA  EMINUS	UNARY MINUS (SET FLAG)
        JAF  $+4
	NOZ  FMINUS	OTHER NON-DIGIT (MUST BE LOGICAL
	SCK  DIGITK	 OR FRACTIONAL NUMERIC CONSTANT)
	JAT  DATUME	BRIF YES
	CSA  ELPARE	IS IT A COMPLEX VARIABLE TYPE?
	JAF  DATUMQ	BRIF NO
*
*  COMPLEX DATA TYPE.
*
	JSB  PARSCM	PARSE THE COMPLEX DATA TYPE
	JAF  ZNUMBE	IF NOT A COMPLEX NUMBER, ERROR
	JUN  DATUMR
*
*  SIMPLE NUMERIC DATA TYPE
*	
DATUME	EQU  $
	ZER  VGENID	ZERO INITIAL DIGIT (NONE)
	JML  AGENCO	CONSTANT OR REPEAT COUNT
*
DATUMF	EQU  $
	STG  TINTEG
	JAF  DATUMR
	CLA  VDATA3	NON-INTEGER, NUMERIC CONSTANT
	SLE  KZERO
	JAT  DATUMV	NON-POSITIVE -- INTEGER COUNT
	SCE  EH
	JAT  DATUML	H -- HOLLERITH CONSTANT
	CSA  EASTRS
	JAF  DATUMV	* -- REPEAT COUNT
	W1   ASPX
	JUN  DATUMD	ELSE -- INTEGER CONSTANT
*
DATUMG	EQU  $
	CSF  EQUOTE	* MUST BE STARTED BY A QUOTE
	JML  AHEXSC	* SCAN HEX CONSTANT
	CSF  EQUOTE	* MUST END WITH A QUOTE
	JUN  DATUMF	*
*
DATUMH	EQU  $
	JSB  IDSCAN	ADDRESS LITERAL
        JAT  $+4
	JSB  REGSCA	MUST BE NON-DUMMY VARIABLE
	SWA  RGDUMM
	JAT  ZID
	W1   POCX	IF SO, OUTPUT POINTER
	POC  KMONE	 WITH SIZE=-1 TO SIGNAL
	JSB  VARCHE	 PASS 2 THAT POINTER IS
	JAF  DATUMI	 NOT DATA VALUE
	SOP  RSCALE
	JAF  DATUMI
	SOP  RDELTA	DETERMINE VARIABLE CLASS &
	JAF  ZSCRIP	 SCAN SUBSCRIPTS IF ANY
	W0   FETX
	FRP  RUNG0
	ANP  X3FF	IF ARRAY ELEMENT, MUST HAVE
	ADP  PARYEL	 CONSTANT SUBSCRIPTS --
	MON  RCODE	 OUTPUT ARRAY ELEMENT POINTER
	FRP  RUNG1	 FOLLOWED BY DISPLACEMENT
*
DATUMI	EQU  $
	W0   POCX	IF SCALAR OR NON-SUBSCRIPTED
	CLA  KTWO	 ARRAY ELEMENT, OUTPUT
	ASP  VELEMS	 POINTER ONLY
	JUN  DATUM9
*
DATUMJ	EQU  $
	FET  PCURCH	QUOTE STRING
	JSB  QUOTSC	SCAN QUOTED STRING
	SCE  EX		CHECK HEX CONSTANT IN FORM 'XXXX'X
	JAT  DATUMK	BRIF HEX CONSTANT
	POW  1		MUST BE A TEXT CONSTANT
	JUN  DATUMM
*
DATUMK	EQU  $		PROCESS HEX ITEM IN FORM 'XXXX'X
	REL  RTEMP
	ASP  PCURCH
	JML  ANXTCH
	JML  AHEXSC	SCAN HEXADECIMAL CONSTANT
	CSF  EQUOTE
	CSF  EX
	JUN  DATUMF
*
DATUML	EQU  $
	JSB  HOLLSC	HOLLERITH STRING
DATUMM	EQU  $
	CNT  RTEMP	SCAN & OUTPUT
	SCL  1		CONVERT TO BYTE COUNT
	SNZ  VTICTO	WAS AN ODD NUMBER OF BYTES READ
	JAF  DATUMN	BRIF NO, WAS EVEN
	SUP  KONE	ELSE, DECREMENT BYTE COUNT READ
DATUMN	EQU  $
	ASP  VELEMS
	W0   POCX	REPEAT COUNT
	POC  VELEMS	BYTE LENGTH
	CTC  RTEMP	STRING
	JUN  DATUM9
*
DATUMO  EQU  $		*
	CSF  EQUOTE	* MUST BE STARTED BY A QUOTE
	JML  AOCTSC	* SCAN OCTAL CONSTANT
	CSF  EQUOTE	* MUST END WITH A QUOTE
	JUN  DATUMF	*
*
DATUMP  EQU  $		*
	CSF  EQUOTE	* MUST BE STARTED BY A QUOTE
	JML  ABINSC	* SCAN BINARY CONSTANT
	CSF  EQUOTE	* MUST END WITH A QUOTE
	JUN  DATUMF	*
*
DATUMQ	EQU  $
	CSF  EPERIO	IS IT LOGICAL OR FRACTIONAL NUMERIC
	SCK  DIGITK	 CONSTANT?
	JAF  DATUMU	NON-DIGIT -- MUST BE LOGICAL
	FET  VLSTCH	NUMERIC   -- SET CURRENT CHARACTER TO A
	ASP  VGENID		     A PERIOD, AND SCAN FRACTION
	JML  AGENCO
*
*  NON-INTEGER NUMERIC CONSTANT.  SAVE APPROPRIATE VALUES TO CODE STACK
*
DATUMR	EQU  $
	JSB  CALCSI	NON-INTEGER NUMERIC CONSTANT
	W1   POCX
	POC  VELEMS	OUTPUT	REPEAT COUNT
	STG  TSREAL	INTEGER *2?
	JAT  DATUMZ
	STG  TDINT4	INTEGER *4?
	JAT  DATUMZ
	STG  TDREAL	REAL    *8?
	JAT  DATUMS
	STG  TC8TYP	COMPLEX *8?
	JAT  DATUMS
	STG  TC6TYP	COMPLEX *16?
	JAT  DATUMT
*			MUST BE INTEGER *1 TYPE
	POW  1
	POC  VDATA3	ELSE, PUT OUT INTEGER (BYTE) VALUE
	JUN  DATUM9
*
DATUMS	EQU  $		DOUBLE PRECISION TYPE
	POW  1		POP OFF TAG TYPE
	POC  VDATA1	PUT OUT 4 WORDS FOR DOUBLE PRECISION
	POC  VDATA2
	POC  VDATA3
	POC  VDATA4
	JUN  DATUM9
*
DATUMT	EQU  $		COMPLEX *16 TYPE
	POW  1		POP OFF TAG TYPE
	POC  VDATA1	PUT OUT 8 WORDS FOR COMPLEX *16
	POC  VDATA2
	POC  VDATA3
	POC  VDATA4
	POC  VDATA5
	POC  VDATA6
	POC  VDATA7
	POC  VDATA8
	JUN  DATUM9
*
DATUMU	EQU  $
	FET  KTRUE	LOGICAL CONSTANT -- SINGLE WORD
	QSA  QTRUE
        JAT  $+6	.TRUE., - VALUE = 1
	CLA  KFALSE
	QSF  QFALSE	.FALSE. - VALUE=0
	ASK  VDATA3
*
*  THE CONSTANT ROUTINE HAS DETERMINED THAT THIS IS AN INTEGER
*  CONSTANT (E.G. 1,2, ETC.).  THE FOLLOWING LOGIC DETERMINES IF
*  THE ASSOCIATED VARIABLES ARE INTEGER *2, IF SO THEN EVERYTHING
*  IS OK.  IF NOT, CONVERT THE INTEGER *2 CONSTANT TO THE DESIRED
*  BASE (INTEGER *4 OR INTEGER *1) AND SAVE IT.
*
DATUMV	EQU  $
	FET  VSELEM	FETCH INDIVIDUAL ELEMENT SIZE (1, 2, OR 4)
	SNE  KFOUR	AM I STORING AN INTEGER *4?
	JAT  DATUMW	BRIF NO, MUST BE INTEGER *1 OR INTEGER *2
*
*  INTEGER *4 PROCESSING
*
	POW  1
	FET  VDATA3	OTHERWISE, CONVERT THE INTEGER *2 VARIABLE TO
	ASK  VDATA2	 AN INTEGER *4
	SLE  KMONE	IS VALUE NEGATIVE?
	JAT  $+6	BRIF YES
	FET  KZERO
	JUN  $+4
	FET  KMONE
	ASP  VDATA1	INTEGER *4 CONSTANT NOW IN VDATA1/VDATA2
	POW  1
	CLA  KFOUR	INTEGER *4 CONSTANT (REGISTER)
	ASP  VELEMS
	W0   POCX	OUTPUT REPEAT COUNT
	POC  VELEMS
	POC  VDATA1	OUTPUT VALUE
	POC  VDATA2
	JUN  DATUM9	DONE
*
*  INTEGER *1 PROCESSING
*
DATUMW	EQU  $
	SNE  KONE	INTEGER *1 PROCESSING?
	JAT  DATUMX	BRIF INTEGER *2
	POW  1
	FET  VDATA3	MAKE INTEGER *2 AN INTEGER *1
	SCL  8
	ANP  XFF00	MASK IT
	ASP  VDATA3	AND SAVE IT
	CLA  KONE	INTEGER 81 CONSTANT (ONE BYTE)
	JUN  DATUMY
*
*  INTEGER *2 PROCESSING
*
DATUMX	EQU  $
	POW  1
	CLA  KTWO	INTEGER *2 CONSTANT (TWO BYTES)
DATUMY	EQU  $
	ASP  VELEMS
	W0   POCX	OUTPUT REPEAT COUNT
	POC  VELEMS	BYTE LENGTH (=2)
	POC  VDATA3	OUTPUT VALUE
	JUN  DATUM9
*
DATUMZ	EQU  $		SINGLE PRECISION OR INTEGER *4
	POW  1
	POC  VDATA1	VALUE (SINGLE PRECISION)
	POC  VDATA2	
*
*  END OF A VARIABLE LIST ITEM.  DECREMENT THE ARRAY SIZE (VARRSI) BY
*  THE ELEMENT SIZE (VELEMS).  IF THERE ARE MORE DATA ITEMS, GO BACK
*  AND PROCESS NEXT.  IF THERE ARE NO MORE DATA ITEMS, WE ARE EITHER
*  AT THE END OF A DATA STATEMENT OR WE WILL START ANOTHER VARIABLE
*  (E.G.   DATA I /1/, J/2/)
*
DATUM9	EQU  $
	FET  VARRSI	GET TOTAL UPDATE SIZE
	SUP  VELEMS	 - THIS ELEMENT SIZE
	ASP  VARRSI
	CSA  ECOMMA	EAT THE COMMA BETWEEN DATA ELEMENTS
	JAT  DATUMA	GO PROCESS MORE
*
*  NEXT CHARACTER ISN'T A COMMA.  IF IT IS NOT A SLASH, THEN SYNTAX
*
	CSF  ESLASH
*
*  SLASH WAS DETECTED (END OF DATA STATEMENT). MAKE SURE MY COUNTS ARE
*  ZEROED
*
	POW  2		POP OLD SIZE & REPEAT COUNT
	FET  VARRSI	GET CURRENT ARRAY SIZE
	W0   SNEX	IS IT ZERO?
	POW  1
	JAT  DATUMC	BRIF NO, ERROR
	MOA  RTEMP1	SEE IF TEMP1 EMPTY
	JAT  DATUM8	BRIF NO, ERROR
*
*  PREVIOUS COUNTS AGREE WITH NUMBER OF DATA ITEMS.  SEE IF THERE IS
*  A CONTINUATION OF THIS DATA STATEMENT OR WE ARE AT THE END OF A
*  STATEMENT.
*
	CSA  ECOMMA	IS THIS A COMMA?
	JAT  SDATA	YES, GO PROCESS AS IF ANOTHER DATA STATEMENT
*	
	SCE  ECARRT	TERMINATOR A CARRIAGE RETURN?
	JAT  SPECEX
	JUN  ZSYNTA	ELSE, SYNTAX
*
*  COUNT ERROR IN DATA STATEMENT, EXIT WITH ERROR
*
DATUM8	EQU  $
	POW  1
DATUMC	EQU  $
	CLI  QDATCN	DATA COUNT ERROR
	ASK  PERRMS
	CLA  PLSTCH	SET ERROR FLAGS & EXIT FALSE
	ASP  PERRCH
	JUN  EXITFA	OUTPUT CODE UP TO ERROR POINT
*
	TITL 'DO, DO WHILE, ENDDO'
	PAGE
*
*  DO STATEMENT
*
*  NOTE:  REWORKED ON 4/DEC/1988 TO ALLOW ANY TYPE OF VARIABLE FOR
*	  DO LOOP ARGUMENTS.
*
SDO	EQU  $
	SNZ  FIFARG	TRANSLATE DO STATEMENT
	JAT  ZSBSTM	IF SUBSTATEMENT OF LOGICAL 'IF', SUBSTATEMENT FAIL
*
	ZER  VLBLKE
	JSB  LABELS	SCAN LABEL,
	JSB  KSCALS	     INDEX VARIABLE
	W0   FETX	GET COPY OF VARIABLE TYPE
	ANP  KTAGFL	 EXTRACT TYPE
	ASP  VSELEM	 AND SAVE
	CSF  EEQUAL
	JSB  DOPARA	SCAN INDEX PARAMETERS
	FET  VCTMPS
	SWT  VITMPS	RESERVE ANY TEMPORARIES USED
	MON  RDOLOO
	FET  VCATMP	RESERVE ANY ADDRESS TEMPORARIES USED
	SWT  VIATMP
	MON  RDOLOO
	MON  RDOLOO	SAVE END-LOOP LABEL & EXIT
	JUN  EXECEX
*
*  DOPARA : PROCESS DO LOOP PARAMETERS
*
DOPARA	EQU  $
	JSB  KXLOAD	SCAN & GENERATE EXPRESSION
	CSF  ECOMMA
	W0   FETX	SCAN FIRST PARAMETER AND GEN CODE
	BIM  CSTORE	 TO STORE IN INDEX VARIABLE
	JSB  KXSTOR
	CSA  ECOMMA	SCAN SECOND PARAMETER AND ENSURE
	JAF  DOPAR1	 RESULT IS IN STORAGE
	JSB  KXSTOR
	JUN  DOPAR2	SCAN THIRD PARAMETER
*
DOPAR1	EQU  $
	FET  KONE	IF NOT SPECIFIED, USE 1
	JSB  REGWKC
*
DOPAR2	EQU  $
	JSB  LABELM	GENERATE LOOP RETURN LABEL
	BIN  CLABEL
	RSV  RCODE
	W3   SWTX	GENERATE DO LOOP CLOSE CODE
	W1   SWTX	 RDOLOO FOR OUTPUT AT END
	W1   FETX	 OF TARGET STATEMENT
*
	BIM  CLOAD
*
	W1   ETAX	GET CONVERT FROM (INDEX VARIABLE, PARM1)
	W1   ETAX	GET CONVERT TO   (STEP VARIABLE, PARM3)
	JSB  CONVCH	CONVERT IT IF NEEDED
*
	W0   FETX
	BIM  CADD	ADD THE STEP VARIABLE
*
	W0   ETAX	GET CONVERT FROM (STEP VARIABLE, PARM3)
	W2   ETAX	GET CONVERT TO   (INDEX VARIABLE, PARM1)
	JSB  CONVCH	CONVERT IT IF NEEDED
*
	W1   FETX
	BIM  CSTORE	STORE IN INDEX VARIABLE
*
	W1   ETAX	GET CONVERT FROM (INDEX VARIABLE, PARM1)
	W3   ETAX	GET CONVERT TO   (CONDITION VARIABLE, PARM2)
	JSB  CONVCH
*
	W2   FETX	SUBTRACT THE INDEX VARIABLE
	BIM  CSUB
*
*  CHECK FOR INTEGER *4, WHICH DOESN'T SET THE STATUS BITS PROPERLY ON
*  STORE OPERATION, IT MUST BE FORCED.
*
	W2   FETX
	STG  TDINT4	* IS IT INTEGER *4?
	JAF  DOPAR3	* BRIF NO
	POC  ISETI4	* ELSE, DO INTEGER *4 COMPARE TO ZERO
*
DOPAR3	EQU  $
	POW  4		* POP 3 PARAMETERS & STG
*
	W0   FETX
	BIN  CBAN
	BIN  CBAZ
*
	RSV  RDOLOO
	CFC  RDOLOO
	JUN  EXIT
*
*  CONVCH - CHECK THE CONVERSION OF THE TOP TWO POINTERS ON WORK STACK.
*           IF TYPES ARE DIFFERENT, GENERATE A CONVERSION.
*
CONVCH	EQU  $
	W1   SNEX	ARE THE POINTERS THE SAME?
	JAF  CONVC1	BRIF THE SAME
	JSB  CONVGE	ELSE, GENERATE THE CONVERSION
	POW  1		RELEASE POINTER
	JUN  EXIT
*
CONVC1	EQU  $
	POW  2		RELEASE POINTERS
	JUN  EXIT	AND RETURN
*
*  DO WHILE
*
SDOWHI	EQU  $
	JSB  EXPRSC	TRANSLATE WHILE STATEMENT
	CSF  ERPARE	 WHILE STATEMENT MUST BE LOGICAL
	JSB  GENERA	 ELSE IS IN ERROR
	JSB  LOADCH
	SCK  DIGITK
	JAT  ZTYPE
	STG  TLOGIC	CONDITION MUST BE LOGICAL
	JAF  ZTYPE
*
SDOWH1	EQU  $
	POW  2
	SNZ  FIFARG
	JAT  ZSBSTM
	NOZ  FIFARG	GEN 'JEQ' TO NEW LABEL
	JSB  LABELM
	BIN  CBAZ
	JSB  ACTIVF
	FET  FLONGN
	ZER  FIFARG
	ZER  FJUMP
	JSB  EOLCHE
	JAF  ZSYNTA
	RSV  RCODE	PUT OLD VDOLOO ON CODE STACK
	POC  VDOLOO	 AND COPY TO RIF
	CFC  RIF
	ZER  VDOLOO
	MOA  RDOLOO
	JAF  SWHIL2
	ASK  VDOLOO
	MON  RDOLOO
SWHIL2	EQU  $
	RSV  RIF	USE DOLOOP AS WORK STACK
	RSV  RDOLOO
	CFC  RDOLOO
	JSB  LABELM
	BIN  CLABEL	GEN 'BRANCH TARGET' LEBEL
	RSV  RCODE
	BIN  CB
	ADP  FLONGN	RESTORE FLONGN STATUS
	ASP  FLONGN
	BIN  CLABEL	GEN 'JEQ-TARGET' LABEL
	CFC  RIF	 & MOVE CODE TO RIF
	CTC  RDOLOO
	RSV  RCODE
	POC  KTWO
	RSV  RIF
	CFC  RIF
	JUN  EXIT
*
*  ENDDO
*
SENDDO	EQU  $
	MOA  RIF	ERROR IF NO 2 ON RIF
	JAF  ZNESTD	ELSE, POP 2 FROM RIF
	SNE  KTWO
	JAT  SENDD4
	MON  RIF
	JSB  EOLCHE
	JAF  ZSYNTA
	MOA  RIF	ERROR IF NOTHING ON RIF
	JAF  ZENDIF
	CTC  RIF
	CTC  RIF
	MOA  RIF
	MOA  RDOLOO	GENERATE ERROR IF CONTENTS OF
	JAF  SENDD1	 OF RDOLOO HAVE CHANGED
	SNE  VDOLOO
	JAT  SENDD3
	MON  RDOLOO
	ASP  VDOLOO
	JUN  EXIT
SENDD1	EQU  $
	SNZ  VDOLOO
	JAT  SENDD2
	ASP  VDOLOO
	JUN  EXIT
SENDD3	EQU  $		DO WHILE STATEMENT INCORRECTLY
	MON  RDOLOO	 NESTED
SENDD2	EQU  $
	ASP  VDOLOO
	JUN  ZNESTD
SENDD4	EQU  $
	MON  RIF
	JUN  ZNESTD
	TITL 'INCLUDE STATEMENT PROCESSING'
	PAGE
*
*  INCLUDE
*
SINCLU	EQU  $
	CSA  EQUOTE	TRANSLATE INCLUDE STATEMENT
	JAF  CLR1EX	NOT INCLUDE STATEMENT
	SNZ  FINCL	ERROR IF CURRENTLY PROCESSING AN
	JAT  SYNTXE	 INCLUDED FILE
	CSA  EQUOTE	SCAN FOR FILE NAME
	JAT  SYNTXE	BRIF NONE, ERROR
	CSA  ESLASH
	JAT  SYNTXE	ERROR, NO LABEL
	ZER  VTICTO	SCAN FILE NAME
	ZER  FBLANK
	JML  ANXTCH
*
SINCL1	EQU  $
	SCE  ECARRT	LINE TERMINATOR ?
	JAT  SYNTXE	BRIF YES, ERROR (NO ENDING QUOTE)
	JSB  PACK	PACK THE LAST CHARACTER
	SCE  ESLASH	/LIST OR /NOLIST?
	JAT  SINCL2	BRIF YES, TERMINATE STRING
	CSA  EQUOTE	ENDING QUOTE ?
	JAT  SINCL3	BRIF YES, TERMINATE STRING
	JML  ANXTCH	ELSE, GET NEXT CHARACTER
	JUN  SINCL1
*
SINCL2	EQU  $
	QSA  QLIST	/LIST OPTION?
	JAT  SINCL3	BRIF YES, NOTHING TO DO
	QSA  QNOLIS	/NOLIST OPTION?
	JAF  SYNTXE	BRIF NO, ERROR IN STATEMENT
	POC  INOLIS
*
SINCL3	EQU  $
	SCE  ECARRT	ENSURE TERMINATOR
	JAF  SYNTXE	IF NONE, ERROR
	ZER  FBLANK
	CSA  EBLANK	UPDATE POINTER IF ON BLANK
	CNT  RTEMP	COUNT WORDS ON TEMP STACK
	ASK  VFLENT	SAVE
	ASK  VINOPL
	SLE  KZERO
	JAT  SYNTXE	BRIF NOTHING SPECIFIED
	SLE  KTWELV	24 CHARS MAXIMUM
	JAF  SYNTXE
	FLP  RTEMP	FLIP TEMP STACK
SINCL5	EQU  $
	MOA  RTEMP	MOVE TEMP TO PAB
	JAF  EXIT
	ASP  VFDES0
	MOA  RTEMP
	JAF  EXIT
	ASP  VFDES1
	MOA  RTEMP
	JAF  EXIT
	ASP  VFDES2
	MOA  RTEMP
	JAF  EXIT
	ASP  VFDES3
	MOA  RTEMP
	JAF  EXIT
	ASP  VFDES4
	MOA  RTEMP
	JAF  EXIT
	ASP  VFDES5
	MOA  RTEMP
	JAF  EXIT
	ASP  VFDES6
	MOA  RTEMP
	JAF  EXIT
	ASP  VFDES7
	MOA  RTEMP
	JAF  EXIT
	ASP  VFDES8
	MOA  RTEMP
	JAF  EXIT
	ASP  VFDES9
	MOA  RTEMP
	JAF  EXIT
	ASP  VFDESA
	MOA  RTEMP
	JAF  EXIT
	ASP  VFDESB
	JUN  EXIT
SYNTXE	EQU  $
	ZER  VINOPL	CLEAR INPUT LABEL CELL
SYNTXF	EQU  $
	MOA  RTEMP
	JAF  ZSYNTA	FLUSH TEMP STACK
	JUN  SYNTXF
OPTERR	EQU  $
	ZER  VINOPL
	JUN  ZILLOP
	TITL 'CONTROL TRANSFER'
	PAGE
*
*  CONTROL TRANSFER STATEMENTS
*
SCALL	EQU  $
	JSB  IDSCAN
	JAT  $+4	SCAN & REGISTER SPROG NAME
	REG  RGSPRO
	SOP  RGSPRO	INSURE NOT VARIABLE OR STATEMENT FUNCTION
	JAF  ZID
	JSB  SPROGS	SCAN ARGUMENTS & GENERATE CALL
	JSB  LINKGE
	JUN  ACTVEX	EXIT
*
*  STANDARD GOTO
*
SGOTO	EQU  $
	ZER  VLBLKE
	CSA  ELPARE	SCAN GOTO
	JAT  CGTEX	'(' -- COMPUTED LABEL LIST
	JSB  LABELS	ELSE SCAN SINGLE LABEL
	BIM  CB
	JUN  JUMPEX	GEN 'B @LABEL' AND EXIT
*
*  COMPUTED GOTO
*
CGTEX	EQU  $
	RSV  RPTRS	SCAN COMPUTED LABEL LIST
*
CGTEX1	EQU  $
	JSB  LABELS	SCAN LABEL & SAVE POINTER
	MON  RPTRS
	CSA  ECOMMA	CHECK FOR NEXT LABEL
	JAT  CGTEX1	Y -- REPEAT
	CSF  ERPARE
	CSA  ECOMMA	SCAN RPAREN & OPTIONAL COMMA
	FET  TINTEG	FETCH TYPE I AM AFTER (INTEGER *2)
	ASP  VSELEM	 (FOR KXEXPG)
	JSB  EXPRSC	SCAN & GEN PASSED TYPE EXPRESSION
	JSB  KXEXPG	SCAN & GEN, W/PASSED CONVERSION IF REQUIRED
	JSB  LOADCH	ENSURE RESULT IN PSUEDO-ACCUMULATOR
	POW  1		DISCARD ACCUMULATOR POINTER
	POC  ICGTEX	COMPUTED GOTO SUBROUTINE
	CNT  RPTRS
	SCL  1		* 2
	BIN  CDATA	GENERATE 'BL @CGTEX '
	FLP  RPTRS		 'DATA N*2  '
	MOA  RPTRS		 'ADRL LBL1 '
	JAF  $+6		     .
	BIN  CADRL		     .
	JUN  $-6		 'ADRL LBLN '
	REL  RPTRS
	JUN  JUMPEX
*
	TITL 'IF STATEMENT'
	PAGE
*
*  IF STATEMENT
*
SIF	EQU  $
	JSB  EXPRSC	TRANSLATE IF STATEMENT
	CSF  ERPARE	SCAN & GENERATE CONDITIONAL EXPRESSION
	JSB  GENERA
	JSB  LOADCH	ENSURE RESULT IN ACCUMULATOR
	SCK  DIGITK
	JAT  ARITHI	CHECK TYPE OF STATEMENT
	STG  TLOGIC	LOGICAL -- COND MUST BE LOGICAL
	JAF  ZTYPE
	POW  2
	SNZ  FIFARG
	JAT  ZSBSTM	MAY NOT BE SUBSTATEMENT OF LOGICAL IF
	NOZ  FIFARG
	JSB  LABELM	GEN 'JEQ' AROUND SUBSTATMENT
	BIN  CBAZ
	JSB  ACTIVF	SCAN & GENERATE SUBSTATEMENT
	FET  FLONGN
	QSA  QTHEN	SCAN FOR 'THEN' STATEMENT
	JAT  STHEN
	JSB  STAXLA
	ADP  FLONGN
	ASP  FLONGN
	BIN  CLABEL	GENERATE JEQ TARGET LABEL
	ZER  FIFARG
	ZER  FJUMP
	JAT  EXIT	EXIT TO CALLER, REFLECTING
	JUN  EXITFA	STATUS OF SUBSTATEMENT
*
ARITHI	EQU  $
	STG  TLOGIC	ARITHMETIC -- COND MUST BE ARITHMETIC
	JAT  ZTYPE	TAKE TYPE CONFLICT FAIL
	STG  TINTEG	* IF INTEGER OR INTEGER *1, NO COMPARE NEEDED
	JAT  ARITH1     *
	STG  TDBYTE	*
	JAT  ARITH1	*
	STG  TDINT4	* INTEGER *4 ?
	JAF  ARITHR	* BRIF NO, MUST BE REAL
	POC  ISETI4	* SET INTEGER *4 STATUS
	JUN  ARITH1	*
ARITHR	EQU  $		*
	POC  ISETST	* SET STATUS FOR REAL (MOV R5,R5)
ARITH1	EQU  $		*
	POW  1
	ZER  VLBLKE
	JSB  LABELS
	CSF  ECOMMA	SCAN 3 LABELS SEPERATED BY COMMAS
	JSB  LABELS
	CSF  ECOMMA
	JSB  LABELS
	W3   SNZX	IF EXPRESSION VALUE NEGATIVE, INVERT
	JAT  $+4	 ORDER OF LABELS
	W2   SWTX
*
	W2   SNEX	GEN JLT UNLESS NEGATIVE-LABEL &
	JAT  $+6	 POSITIVE-LABEL ARE THE SAME
	POW  1
	JUN  $+4  
	BIN  CBAN
*
	W1   SNEX	GEN 'BAX' UNLESS ZERO LABEL &
	JAT  $+6	POSITIVE LABEL ARE THE SAME
	POW  1
	JUN  $+4
	BIN  CBAZ
*
	BIN  CB		GEN 'B' UNCONDITIONALLY & EXIT
	POW  1
	JUN  JUMPEX
*
STHEN	EQU  $
	ZER  FIFARG
	ZER  FJUMP
	JSB  EOLCHE
	JAF  ZSYNTA
	RSV  RCODE	PUT OLD VDOLOO ON CODE STACK
	POC  VDOLOO	 AND COPY TO RIF
	CFC  RIF
	ZER  VDOLOO
	MOA  RDOLOO
	JAF  STHEN1
	ASK  VDOLOO
	MON  RDOLOO
STHEN1	EQU  $
	RSV  RIF
	RSV  RIF
	RSV  RCODE
	ADP  FLONGN	RESTORE FLONGN STATUS
	ASP  FLONGN
	BIN  CLABEL	GEN 'JEQ TARGET' LABEL
	POC  KZERO
	CFC  RIF	MOVE CODE TO RIF
	JUN  EXIT
*
	TITL 'ELSE, ELSEIF, ENDIF'
	PAGE
*
*  ELSE
*
SELSE	EQU  $
	JSB  EOLCHE
	JAF  ZSYNTA
	MOA  RIF	ERROR IF NO 0 ON RIF, OTHERWISE,
	JAF  ZELSE	POP 0 FROM RIF
	SNE  KZERO
	JAT  SELSE2
	JSB  LABELM	GEN BRANCH AROUND TO NEW LABEL
	BIN  CB
	CTC  RIF
	RSV  RIF
	RSV  RCODE
	BIN  CLABEL	GEN BRANCH AROUND TARGET LABEL
	POC  KONE
	CFC  RIF
	MOA  RDOLOO	GENERATE ERROR IF CONTENTS OF
	JAF  SELSE1	 RDOLOO HAVE CHANGED
	SNE  VDOLOO
	JAT  SELSE3
	MON  RDOLOO
	JUN  EXIT
SELSE1	EQU  $
	SNZ  VDOLOO
	JAT  ZNESTD
	JUN  EXIT
SELSE2	EQU  $
	MON  RIF	INVALID CONTROL STRUCTURE USING
	JUN  ZELSE	ELSE STATEMENT
SELSE3	EQU  $
	MON  RDOLOO	DO STATEMENT INCORRECTLY NESTED
	JUN  ZNESTD
*
*  ELSEIF
*
SELSEI	EQU  $
	MOA  RIF	ERROR IF NO 0 ON RIF, OTHERWISE,
	JAF  ZELSEI	POP 0 FROM RIF
	SNE  KZERO
	JAT  ELSIF2
	MON  RIF	TRANSLATE IF STATEMENT.  STATEMENT
	RSV  RCODE	 MUST BE LOGICAL.  OTHERWISE,
	JSB  EXPRSC	 IT IS AN ERROR.
	CSF  ERPARE
	JSB  GENERA
	JSB  LOADCH
	SCK  DIGITK
	JAT  ZTYPE
	STG  TLOGIC	LOGICAL - CONDITION MUST BE LOGICAL
	JAF  ZTYPE
	POW  2
	SNZ  FIFARG
	JAT  ZSBSTM
	NOZ  FIFARG
	JSB  LABELM	GENERATE 'JEQ' TO NEW LABEL
	BIN  CBAZ
	JSB  ACTIVF
	FET  FLONGN
	QSA  QTHEN	SCAN FOR 'THEN' STATEMENT
	JAF  ZMISKE
	ZER  FIFARG
	ZER  FJUMP
	JSB  EOLCHE
	JAF  ZSYNTA
	MOA  RIF
	POW  1
	RSV  RWORK
	CFC  RWORK
	JSB  LABELM	GEN 'BRANCH AROUND' TO NEW LABEL
	BIN  CB
	CTC  RIF
	RSV  RCODE	GEN BRANCH AROUND TARGET LABEL
	BIN  CLABEL	MOVE CODE TO RIF
	CFC  RIF
	CTC  RWORK
	RSV  RCODE
	ADP  FLONGN
	ASP  FLONGN
	BIN  CLABEL
	POC  KZERO
	RSV  RIF
	CFC  RIF	COPY CODE FROM RIF
	MOA  RDOLOO	GENERATE ERROR IF CONTENTS
	JAF  ELSIF1      HAVE CHANGED
	SNE  VDOLOO
	JAT  ELSIF3
	MON  RDOLOO
	JUN  EXIT
ELSIF1	EQU  $
	SNZ  VDOLOO
	JAT  ZNESTD
	JUN  EXIT
ELSIF2	EQU  $
	MON  RIF
	JUN  ZELSEI
ELSIF3	EQU  $
	MON  RDOLOO
	JUN  ZNESTD
*
*  ENDIF
*
SENDIF	EQU  $
	JSB  EOLCHE
	JAF  ZSYNTA
	MOA  RIF	ERROR IF NOTHING ON RIF
	JAF  ZENDIF
	CTC  RIF	MOVE CODE TO RCODE
	CTC  RIF
	MOA  RIF
	MOA  RDOLOO	GEN ERROR IF CONTENTS OF
	JAF  SENIF1	RDOLOO HAVE CHANGED
	SNE  VDOLOO
	JAT  SENIF3
	MON  RDOLOO
	ASP  VDOLOO
	JUN  EXIT
*
SENIF1	EQU  $
	SNZ  VDOLOO
	JAT  SENIF2
	ASP  VDOLOO
	JUN  EXIT
*
SENIF3	EQU  $
	MON  RDOLOO
*
SENIF2	EQU  $
	ASP  VDOLOO
	JUN  ZNESTD
	TITL 'STOP & PAUSE'
	PAGE
*
SSTOP	EQU  $
	SCK  DIGITK	TRANSLATE STOP STATEMENT
	JAF  $+6  
	POC  ISTOPN	IF FOLLOWING NUMBER, GEN
	JUN  PAUSE	'B STOPN'  'DATA N'
	POC  ISTOP
	JUN  JUMPEX	ELSE GEN 'B STOP'
*
SPAUSE	EQU  $
	POC  IPAUSE	TRANSLATE PAUSE STATEMENT
	ZER  VDATA3	GEN 'B PAUSE'
	SCK  DIGITK
	JAF  $+4	SCAN FOLLOWING # IF ANY
*
PAUSE	EQU  $
	JSB  INTSCA
	FET  VDATA3
	BIN  CDATA	OUTPUT # & EXIT
	JUN  JUMPEX
	TITL 'CONTROL TRANSFER STMT'
	PAGE
*
SRETUR	EQU  $
	FET  FSPROG	TRANSLATE RETURN STATEMENT
	JOW  ZSYNTA
	JOW  $+10	ALLOWED ONLY IN SUBPROGRAM
*
	CLA  PSCLR0
	JML  ALDGRP	IF FUNCTION, PRECEDE RETURN BY
	JSB  TYPESE	'LOAD FUNCNAME'
	BIN  CLOAD
*
	POC  IRETUR	GEN 'B RETURN' & EXIT
	JUN  JUMPEX
*
SEND 	EQU  $
	SCE  ECARRT	TRANSLATE END OR ENFILE STATEMENT
	JAF  ZSYNTA
	SNZ  FIFARG
	JAT  ZSBSTM
	NOZ  FEND	END -- TERMINATE PASS 1 AND ENTER
*				ALLOCATION PHASE
ENDGEN	EQU  $
	MOA  RIF	GENERATE ERROR IF MISSING
	JAF  ENDGE1	ENDIF(S)
	EAW  QUNCLS
	FET  PLSTCH
	ASP  PERRCH
	ASP  PERRMS
	ZER  FBLANK
	ZER  FLONGN
	NOZ  FUNCLS
ENDGE1	EQU  $
	SNZ  FSPROG
	JAT  SRETUR
	POC  ISTOP	OUTPUT 'STOP' OR 'RETURN'
	JUN  JUMPEX
	TITL 'READ AND WRITE STATEMENTS'
	PAGE
*
*  READ/WRITE STATEMENTS
*
*  THE FOLLOWING I/O STATEMENTS ARE SUPPORTED:
*
*    READ      - READ FROM SPECIFIED UNIT #
*    ACCEPT    - READ FROM DEFAULT UNIT # (CRT)
*    WRITE     - WRITE TO SPECIFIED UNIT #
*    PRINT     - PRINT ON DEFAULT PRINTER DEVICE
*    TYPE      - TYPE ON DEFAULT UNIT # (CRT)
*
STYPES	EQU  $
SPRINT	EQU  $
	FET  KTWO	SET KEY=2 (OUTPUT)
	JUN  SACCE1
*
SACCEP	EQU  $
	FET  KZERO	SET KEY=0 (INPUT)
SACCE1	EQU  $
	ASK  FINOUT	SAVE INPUT/OUTPUT FLAG
	FET  KZERO	UNIT #
	FET  KZERO
	ZER  VREC
	ZER  VEND
	ZER  VERR	ZERO OPTIONAL PARAMETERS
	ZER  VSTATU
	ZER  VORD
	CLA  KMONE
	JSB  REGWKC	REGISTER AS FIXED CONSTANT
	CSA  ECOMMA	LIST DIRECTED FORMATTING IS SPECIFIED
	JAT  SIO3A	 BY NO FORMAT NUMBER, OR BY AN ASTERICK.
	CSA  EASTRS	 PASS A -1 FOR THE FORMAT ADDRESS
	JAT  SACCE3
*
*  NOT LIST DIRECTED FORMATTING.  PARSE THE FORMAT LABEL.
*
	CLA  TFORMA	SCAN FORMAT LABEL
	ASP  VLBLKE
	JSB  LABELS
	ZER  VLBLKE
SACCE3	EQU  $
	CSF  ECOMMA	MAKE SURE CLOSING COMMA
	JUN  SIO3A
*
SREAD	EQU  $
	FET  KZERO	SET KEY=0
	JUN  SIO
*
SWRITE	EQU  $
	FET  KTWO	SET KEY=2
*
SIO	EQU  $		START I/O
	ASK  FINOUT	SAVE INPUT/OUTPUT FLAG
	FET  KZERO	ZERO IS THE WILD CARD UNIT NUMBER
	CSA  EASTRS	 IF AN ASTERICK IS SPECIFIED
	JAT  SIO0
	POW  1
	JSB  FXSTOR	SCAN & GENERATE FILE EXPRESSION
SIO0	EQU  $
	FET  KZERO
	ZER  VREC
	ZER  VEND
	ZER  VERR	ZERO OPTIONAL PARAMETERS
	ZER  VSTATU
	ZER  VORD
	CSA  ECOMMA	CHECK FOR FORMAT SPECIFICATION
	JAF  SIO3
	CLA  KMONE
	JSB  REGWKC	AN ASTERICK FOR THE FORMAT NUMBER
	CSA  EASTRS	 SPECIFIES LIST DIRECTED FORMATTING
	JAT  SIO2	 SO PASS A -1 TO EXECUTION TIME TO TELL IT
*
*  NOT LIST DIRECTED FORMATTING.  SEE IF A FORMAT CHAR HAS BEEN
*  SPECIFIED.  IF NOT, PASS A ZERO.
*
	CLA  KZERO
	SCK  LETTRK
	JAT  SIO1	NOTHING -- END ARG LIST
	CLA  TFORMA
	ASP  VLBLKE
	JSB  LABELS
	ZER  VLBLKE
	JUN  SIO2
*
SIO1 	EQU  $
	ZER  VLBLKE	LETTER -- MAY BE FORMAT ARRAY
	JSB  KEYWDS	 OR KEYWORD PARAMETER
	JAT  SIO2
	POW  1
	JSB  IDSCAN	NOT KEYWORD, MUST BE ARRAY
	JAF  ZID
	SOP  RARRAY
	JAF  ZID
*
SIO2 	EQU  $
	CSA  ECOMMA	SCAN OPTIONAL PARAMETERS, IF ANY
	JAF  SIO3
	JSB  KEYWDS	COMMA - PARAMETER MUST FOLLOW
	JAT  SIO2
	JUN  ZSYNTA
*
SIO3 	EQU  $
	CSF  ERPARE	INSURE CLOSING RIGHT PARENTHESIS
SIO3A	EQU  $
	RSV  RPTRS
	FET  VORD
	MON  RPTRS
	FET  VSTATU	MOVE PARAMETER POINTERS TO POINTERS STACK
	MON  RPTRS	 FOR ARGUMENT LIST GENERATION
	FET  VREC
	MON  RPTRS	ORDER CODE (UNUSED)
	FET  VERR	STATUS VARIABLE
	MON  RPTRS	RANDOM REC #
	FET  VEND	ERROR TRANSFER
	MON  RPTRS	END TRANSFER
	MON  RPTRS	FORMAT POINTER
	MON  RPTRS	FILE SPECIFICATION
	FET  KONE
	POC  ISTRTI	GEN START IO LINK & ARGUMENT LIST
	JSB  ARGLIS
	JSB  EOLCHE	CHECK FOR I/O VARIABLE LIST
	JAT  $+4	Y -- GENERATE I/O LINKS
	JSB  IOLIST
	NOZ  FIO	SET FLAG THAT SAYS PROGRAM DOES I/O
	POC  ISTOPI
	JUN  ACTVEX	GENERATE STOP I/O LINK & EXIT
*
*  IOLIST : TRANSLATE I/O VARIABLE LIST
*
IOLIST	EQU  $
	RSV  RCODE
*
IOLIS1	EQU  $
	CSA  ELPARE	IF LIST IN PARENTHESIS, CALL SELF
	JAF  IOLIS2	 TO TRANSLATE. ON COMPLETION,
	JSB  IOLIST	 INSURE RIGHT PARENTHESIS AND CHECK
	CSF  ERPARE	 FOR NEXT LIST ELEMENT
	JUN  IOLIS6
*
IOLIS2	EQU  $
	SCE  EQUOTE	IS THIS A QUOTED STRING?
	JAF  IOLIS4	BRIF NO
*
*  IT IS A QUOTED STRING.  SCAN THE QUOTED STRING, AND GENERATE
*  A CHARACTER STRING WRITE.
*
	SNZ  FINOUT	MAKE SURE IT IS AN OUTPUT ONLY
	JAF  ZSYNTA	IT IS A READ, SYNTAX ERROR
*
	FET  PCURCH
	JSB  QUOTSC	SCAN QUOTED STRING
	CNT  RTEMP	SCAN & OUTPUT
	SCL  1		CONVERT TO BYTE COUNT
	SNZ  VTICTO	WAS AN ODD NUMBER OF BYTES READ
	JAF  IOLIS3	BRIF NO, WAS EVEN
	SUP  KONE	ELSE, DECREMENT BYTE COUNT READ
IOLIS3	EQU  $
	POC  ICHRIO	   BL   @CHRIO
	BIN  CDATA	   DATA N         # OF BYTES WHICH FOLLOW
	CNT  RTEMP	GET # OF WORDS AGAIN IN STRING
	ADP  IDATA	FORM DATA WORD
	W0   POCX	DATA WORD
	CTC  RTEMP	ACTUAL FORMAT STRING
	JUN  IOLIS6
*
*  NOT A CHARACTER CONSTANT.  SCAN VARIABLE LIST ELEMENT
*
IOLIS4	EQU  $
	JSB  VARSCA	ELSE SCAN LIST VARIABLE
	JAT  IOLIS5
	W0   FETX
	FRP  RUNG3	NON-SUBSCRIPTED ARRAY
	W0   FETX
	FRP  RUNG0
	ASP  VINDIR
	STG  TADJUS	IF ADJUSTABLY DIMENSIONED, GENERATE
	IND  FRPX	' B    ADJIO'
	W1   SWTX	' DATA ARRAY-TEMP '
        JAF  $+8	' DATA T-TEMP'
*
*  ADJUSTABLE ARRAY:
*
	BIM  CADJDI
	BIN  CADRL
	JUN  IOLIS6	ELSE, GENERATE:
*
*  NON-ADJUSTABLE ARRAY:
*
	BIM  CARRYI	' B    ARRYIO'
	BIN  CDATA	' DATA ARRAY (OR TEMP)'
	JUN  IOLIS6	' DATA T'
*
IOLIS5	EQU  $
	CSA  EEQUAL	SCALAR OR ARRAY ELEMENT
	JAT  IOLIS7	' B    SCLRIO'
	BIM  CSCLRI	' DATA VAR   '
*
IOLIS6	EQU  $
	CSA  ECOMMA	CHECK FOR NEXT LIST ELEMENT
	JAT  IOLIS1
	RSV  RTEMP	Y -- REPEAT SCAN
	CFC  RTEMP
	CTC  RTEMP	ELSE REMOVE RESERVE ON RCODE
	JUN  EXIT	 AND RETURN TO CALLER
*
IOLIS7	EQU  $
	STG  TINTEG	'VAR=' -- MUST BE IMPLIED DO LOOP
	JAF  ZTYPE
	W0   FETX	GET COPY OF VARIABLE TYPE
	ANP  KTAGFL	 EXTRACT TYPE
	ASP  VSELEM	 AND SAVE
	SOP  RSCALE	INSURE INTEGER SCALAR INDEX VARIABLE
	JAF  ZID
	SRD  RCODE	INSURE SOME IO LIST TO REPEAT
	JAF  ZSYNTA
	RSV  RCODE	TRANSLATE DO PARAMETERS, RE-
	JSB  DOPARA	 ORDER GENERATED CODE, & EXIT
	RSV  RTEMP
	CFC  RTEMP	DO LOOP OPEN CODE
	CFC  RTEMP	INPUT/OUTPUT LIST CODE
	CTC  RTEMP	 (REPLACE ON RCODE)
	CTC  RDOLOO	DO LOOP CLOSE CODE
	JUN  EXIT
*
KEYWDS	EQU  $
	QSA  QREC	SCAN 1 I/O KEYWORD PARAMETER
	JAF  KEYWD1
	JSB  FXSTOR	'REC=' INTEGER EXPRESSION
	SWT  VREC
	JUN  KEYWD4		OR
*
KEYWD1	EQU  $
	QSA  QENDEQ
	JAF  KEYWD2
	JSB  LABELS	'END=' BRANCH TARGET
	SWT  VEND
	JUN  KEYWD4
*
KEYWD2	EQU  $
	QSA  QERR
	JAF  KEYWD3
	JSB  LABELS	'ERR=' BRANCH TARGET
	SWT  VERR
	JUN  KEYWD4
*
KEYWD3	EQU  $
	QSA  QSTATU
	JAT  KEYW3A	'STATUS=' INTEGER VARIABLE
*
	QSA  QIOSTA
	JAF  EXITFA	'IOSTAT=' INTEGER VARIABLE
*
*  HANDLE THE STATUS= (FORTRAN66) OR THE IOSTAT= (FORTRAN77) INTEGER
*  VARIABLE.
*
KEYW3A	EQU  $
	JSB  VARSCA
	JAF  ZSCRIP
	STG  TINTEG
	JAF  ZTYPE
	SWT  VSTATU	NONE - RETURN ANSWER FALSE
*
KEYWD4	EQU  $
	JOW  EXIT	RETURN PTR IN VAR W/ANSWER TRUE
	JUN  ZSYNTA	SPECIFIED TWICE -- SYNTAX FAIL
	PAGE
	TITL 'FORMAT STATEMENT'
	PAGE
*
*  FORMAT STATEMENT
*
SFORMA	EQU  $
	SNZ  PSTALB	SCAN & PARSE FORMAT STATEMENT
	JAF  ZNOLBL	STATEMENT MUST BE LABELLED
	SNZ  FIFARG	MAY NOT BE LOGICAL IF SUBSTATEMENT
	JAT  ZSBSTM
	ZER  VTICTO	OUTPUT CONDENSED ASCII STRING
	RSV  RTEMP
	JSB  FMLIST	SCAN FORMAT LIST
	CNT  RTEMP
	BIN  CFORMA	GEN 'FORMAT N' WHERE N=WORD LENGTH
	CTC  RTEMP	 OF FORMAT STRING
	FET  TFORMA
	ASP  VLBLKE	SET FORMAT LABEL KEY
	NOZ  FJUMP
	JUN  ACTVDO	EXIT
*
FMLIST	EQU  $
	JSB  PACK	SCAN FORMAT LIST
FMLIS1	EQU  $
	CSA  ESLASH
	JAT  FMLIS2	<LIST> :== /)
	JSB  FMDESC	     |   /<LIST>
	CSA  ESLASH	     |   /,<LIST>
	JAT  FMLIS2	     |   <DESCR>
	CSA  ECOMMA	     |   <DESCR>/
	JAT  FMLIST	     |   <DESCR>/<LIST>
	CSF  ERPARE	     V   <DESCR>,<LIST>
	JUN  PACK
*
FMLIS2	EQU  $
	JSB  PACK	COMMAS FOLLOWING SLASHES ARE
	CSA  ECOMMA	 SUPERFLOUS & ARE SUPPRESSED
	JAT  FMLIS1
	CSA  ERPARE	BLANKS NOT WITHIN HOLLERITH
	JAF  FMLIS1	 FIELDS ARE SUPPRESSED
	JUN  PACK
*
*  FMDESC : SCAN FORMAT DESCRIPTOR
*
FMDESC	EQU  $
	SCK  DIGITK
	JAT  FMDES1
	SCE  EN
	JAT  FMDES1
	SCK  LETTRK	<DESCR> :== <SCALE><OPT#><REAL>
	JAT  FMDES4		| <OPT#><REAL>
	CSA  ELPARE		| <OPT#><FIXED>
	JAT  FMLIST		| <OPT#><LDESCR>
	SCE  EQUOTE
	JAT  FMDES8		| <OPT#><QUOTE>
	CSF  EMINUS		| <OPT#><HOLL>
	JSB  FMNUMB		| <NOZ#><HOLL>
	CSF  EP			| <NOZ#>X
	JUN  FMDES2		| <OPT#>(<LIST>
*				V <OPT#>/
*
FMDES1	EQU  $
	JSB  FMNUM0	* v3.0
	JUN  FMDES3
*
FMDES2	EQU  $
	JSB  PACK	<SCALE> :== <INT#>P
	SCK  DIGITK		| -<INT#>P
	JAT  $+6  
	SCE  EN
	JAF  FMDES5
	JSB  FMNUMB+2
	SNZ  VDATA3	<INT#> :== ANY INTEGER (>=0)
	JAT  FMDES5
	JUN  ZNUMBE
*
FMDES3	EQU  $
	SNZ  VDATA3	<OPT#> :== ANY INTEGER >0
	JAF  ZNUMBE		| NIL
	SCE  ESLASH
	JAT  EXIT
	SCE  EQUOTE
	JAT  FMDES8
	SCE  EH		<NOZ#> :== ANY INTEGER >0
	JAT  FMDES9
	CSA  ELPARE
	JAT  FMLIST
*
FMDES4	EQU  $
	CSA  EX
	JAT  PACK
	CSA  EI		<FIXED> ::= I<INT#>
	JAT  FMNUMB		| A<INT#>
	CSA  EA			| Z<INT#>
	JAT  FMONUM		| R<INT#>
	CSA  EZ			| C<INT#>
	JAT  FMNUMB		| Q
	CSA  ER                 V
	JAT  FMNUMB
	CSA  EC
	JAT  FMNUMB
	CSA  EL
	JAT  FMNUMB
	CSA  EQ		* v3.0
	JAT  PACK
*
FMDES5	EQU  $
	CSA  EF		<REAL> ::= F<INT#>.<INT#>
        JAT  $+12	  | E<INT#>.<INT#>
	CSA  EE		  | D<INT#>.<INT#>
	JAT  $+8	  | M<INT#>.<INT#>
	CSA  ED           V
	JAT  $+4 
	CSF  EM
	JSB  FMNUMB
	CSF  EPERIO
	JUN  FMNUMB
*
FMDES8	EQU  $
	EAW  EFAKEQ	<QUOTE> ::= '<STRING>'
	ASP  VLSTCH
	JSB  PACK	<STRING> IS A STANDARD FORTRAN
	JSB  QUOTSC+2	QUOTED STRING. THE QUOTE
	EAW  EFAKEQ	CHARACTERS ARE REPLACED BY
	ASP  VLSTCH	EFAKEQ, & INTERNAL DOUBLE-
	JUN  PACK	QUOTES REDUCED TO SINGLE.
*
FMDES9	EQU  $
	FET  VDATA3	<HOLL> ::= H<HOLLFIELD>
	JSB  HOLLSC
	PNG  RHOLVA	<HOLLFIELD> IS A STANDARD FORTRAN
	CNT  RTEMP	 HOLLERITH FIELD, OF LENGTH
	MON  RHOLVA	 GIVEN BY PRECEDING <NOZ#>.
	EAW  DX3	<HOLL> IS REPLACED BY A 2-WORD
	CAR  RTEMP	 INSTRUCTION WHICH REACHES THE
	FET  IHOLVA	 EXECUTION SUPPORT PACKAGE AS:
	MON  RTEMP	   'HOLL'
	MON  RTEMP	   'ADRL <HOLLFIELD>
	ZER  VTICTO	 WHERE:  <HOLLFIELD> IS IN THE
	JUN  EXIT	 PROTECTED DATA AREA
*
*  FMNUMB : FORMAT ITEM REQUIRES A NUMBER FOLLOWING.  SCAN FOR
*           DIGIT OR 'N' AND MAKE SURE WHAT FOLLOWS IS OK.
*
FMONUM	EQU  $		OPTIONAL NUMBER FOLLOWING (E.G. A)
	JSB  PACK	PACK 'A'
	SCK  DIGITK
	JAT  FMNU0A	BRIF DIGIT FOLLOWING
	SCE  EN		IS IT 'N' FOLLOWING?
	JAT  FMNUM2	BRIF YES, PROCESS
	JUN  EXIT	ELSE, JUST EXIT THIS
*
*  FMNUMB : SCAN NUMBER IN FORMAT DESCRIPTOR.  SCAN FOR DIGIT OR 'N'
*	    AND MAKE SURE WHAT FOLLOWS IS OK.
*
FMNUMB	EQU  $
	JSB  PACK
FMNUM0  EQU  $
	SCK  DIGITK
	JAF  FMNUM2	MUST BE DIGIT STRING OR 'N'
FMNU0A	EQU  $
	JSB  DIGITI
*
FMNUM1	EQU  $
	JSB  DIGITC	CONVERT TO BINARY
	JML  ANXTCH
	JSB  PACK	ALSO PACK ASCII
	SCK  DIGITK
	JAT  FMNUM1
	JUN  EXIT
*
FMNUM2	EQU  $
	CSF  EN		IF 'N', RETURN -1 AS BINARY VALUE
	FET  KMONE
	ASP  VDATA3	('N' ILLEGAL FOR H FORMAT)
	JUN  PACK
	TITL 'EXPRESSION HANDLING'
	PAGE
*
*  EXPRESSION HANDLING
*
FXLOAD	EQU  $
	JSB  EXPRSC	SCAN & GEN LOADED INTEGER EXPRESSION
	JSB  FXEXPG	SCAN & GEN, W/INTEGER CONVERSION IF REQUIRED
	JSB  LOADCH	ENSURE RESULT IN ACCUMULATOR
	JUN  CLR1EX	DISCARD ACCUMULATOR POINTER & EXIT
*
FXSTOR	EQU  $
	JSB  EXPRSC	SCAN & GEN STORED INTEGER EXPRESSION
	JSB  FXEXPG	SCAN & GEN, W/INTEGER CONVERSION IF REQUIRED
	JUN  STOREC	ENSURE RESULT IS IN STORAGE
*
KXLOAD	EQU  $
	JSB  EXPRSC	SCAN & GEN PASSED TYPE EXPRESSION
	JSB  KXEXPG	SCAN & GEN, W/PASSED CONVERSION IF REQUIRED
	JSB  LOADCH	ENSURE RESULT IN PSUEDO-ACCUMULATOR
	JUN  CLR1EX	DISCARD ACCUMULATOR POINTER & EXIT
*
KXSTOR	EQU  $
	JSB  EXPRSC	SCAN & GEN PASSED TYPE EXPRESSION
	JSB  KXEXPG	SCAN & GEN, W/PASSED CONVERSION IF REQUIRED
	JUN  STOREC	ENSURE RESULT IS IN STORAGE
*
*  RHEXPR : RIGHT HAND EXPRESSION HANDLING
*
RHEXPR	EQU  $
	JSB  EXPRSC	SCAN, GEN, AND CONVERT LOADED
	JSB  EXPRGE	 EXPRESSION TO TYPE SPECIFIED BY
	JSB  LOADCH	 POINTER ON W0
	W1   STGX
	JAT  CLR1EX	IF TYPES MATCH, JUST EXIT
	STG  TLOGIC
	JAT  ZTYPE	ELSE CHECK FOR LOGICAL/NUMERIC
	W1   ETAX	TYPE CONFLICT
	STG  TLOGIC
	JAT  ZTYPE	Y -- GIVE TYPE CONFLICT ERROR
	JSB  CONVGE
	JUN  CLR1EX	N -- GEN CONVERSION AND EXIT
*
*  EXPRESSION SCAN
*
*  EXPRSC IS CALLED FROM VARIOUS STATEMENT HANDLING ROUTINES
*  TO EVALUATE AN ARITHMETIC OR LOGICAL EXPRESSION.
*
*  TERMSC IS CALLED RECURSIVELY FROM WITHIN EXPRSC TO
*  EVALUATE SUBEXPRESSIONS WITH PARENTHESIS AND SUBPROGRAM
*  ARGUMENT EXPRESSIONS
*
*  THE EVALUATED EXPRESSION IS BUILT ON RPOLIS IN POLISH
*  NOTATION, WITH EACH ELEMENT REPRESENTED BY ITS POINTER
*  (SCALAR, CONSTANT, ETC) AND EACH OPERATOR BY ITS DRIVER
*  (PLUS, MINUS, ETC.)
*
EXPRSC	EQU  $
	ZER  FARG	SCAN EXPRESSION
*
TERMSC	EQU  $
	FET  DTERM	SCAN TERM OF EXPRESSION
*
ELEMSC	EQU  $
	ZER  FMINUS	SCAN EXPRESSION ELEMENT
	SCK  LETTRK
	JAT  ELEM1	 VARIABLE OR SUBPROGRAM NAME
	SCK  DIGITK
	JAT  ELEM6	 NUMERIC OR HOLLERITH CONSTANT
	CSA  EPERIO
	JAT  ELEM7	 NUMERIC OR LOGICAL CONSTANT
	SCE  ELPARE
	JAT  ELEM9	 TERM IN PARENTHESIS
	SCE  EQUOTE
	JAT  ELEM10	 QUOTED HOLLERITH CONSTANT
	CSA  EPLUS
	JAT  ELEMSC	 UNARY PLUS (IGNORE)
	CSF  EMINUS
	NOZ  FMINUS
	SCK  DIGITK
	JAT  ELEM6	NEGATIVE CONSTANT
	FET  DUMINU
	JUN  ELEMSC	UNARY MINUS
*
ELEM1	EQU  $
	QSA  QBQ	IS IT A BINARY CONSTANT ?
	JAT  ELE10B	BRIF YES
	QSA  QOQ	IS IT AN OCTAL CONSTANT ?
	JAT  ELE10C	BRIF YES
	QSA  QZQ	IS IT A HEX CONSTANT ?
	JAT  ELE10D	BRIF YES
	JSB  IDSCAN	NAME:
	JAF  ELEM4
	SOP  RSCALE	KNOWN:
	JAT  ELEMMO
	SOP  RLDUMM	SCALAR
	JAT  ELEMMO	MOVE POINTER TO POLISH STACK
	SOP  RARRAY
	JAT  ELEM2
	SCE  ELPARE	FUNCTION WITH ARGUMENTS
	JAT  ELEM5	SCAN ARGUMENT LIST
	SOP  RGSPRO
	JAT  ZID	FUNCTION W/NO ARGUMENTS
	SNZ  FARG
	JAT  ELEM3	MUST BE GLOBAL
	JUN  ZID	MUST BE SPROG ARGUMENT
*
ELEM2	EQU  $
	JSB  ARRAYS	ARRAY
	JAT  ELEMMO	IF SUBSCRIPTED, MOVE POINTER
	SNZ  FARG	ELSE MUST BE SUBPROGRAM ARGUMENT
	JAF  ZSCRIP
*
ELEM3	EQU  $
	ZER  FARG	SUBPROGRAM OR ARRAY SUBPROGRAM ARGUMENT
	MON  RPOLIS	RETURN ARGUMENT POINTER
	JUN  CLR1EX	DISCARD TERM DRIVER
*
ELEM4	EQU  $
	SCE  ELPARE	UNKNOWN:
	JAT  $+6  
	JSB  REGSCA	SCALAR UNLESS FOLLOWED BY '('
	JUN  ELEMMO	MOVE POINTER TO POLISH STACK
	PNG  RGSPRO
	PGO  RGSPRO	GLOBAL FUNCTION IF '('
	JSB  TYPESE
*
ELEM5	EQU  $		FUNCTION REFERENCE:
	SOP  RLSPRO
	JAT  ELEM5C	CHECK IF INTRINSIC FUNCTION
	SWA  RGDUMM
	JAT  ELEM5B	NOT INTRINSIC IF LOCAL SUBPROGRAM
	SFA  RINTRI	 (STATEMENT FUNCTION) OR
	JAT  ELE5B1	 DUMMY ARGUMENT
	SFA  RINTR1
	JAF  ELEM5C
ELE5B1	EQU  $
	FET  VSYM3
	SNE  MBLANK	NOT INTRINSIC IF DECLARED
	POW  1		 'EXTERNAL' (ALL EXTERNALS
	JAT  ELEM5B	 ARE ON GLOBAL DUMMY STACK)
	ASK  VTEMP1
	FRP  RUNG2	NOT INTRINSIC IF DECLARED IN
	SWT  VTEMP1	 CONFLICTING TYPE STATEMENT
	JSB  TYPESR
	JAF  $+6
	STG  VTEMP1
	JAF  ELEM5B	INTRINSIC FUNCTION:
	W0   EADX
	POW  1
	FRP  RUNG3
	W0   FETX	* DUP THE STACK (LAST WORD OF INTRINSIC)
	ANP  KADRFL	* EXTRACT # OF ARGS ALLOWED PAST MAXIMUM
	ASP  VARGSA	* SAVE IT FOR LATER
	ANP  XFF80	* MASK OP FIELD & TYPE FOR CONVERSION DRIVER
	SWT  VTEMP1
	SUP  KONE	* DECREMENT MY # ARGUMENTS BY ONE
	SOP  CALL	IF TO BE CALLED FROM LIBRARY,
	JAF  $+6	 PUSH NAME POINTER ON RPOLIS
	W1   FETX
	MON  RPOLIS
	W1   ASKX
	CLA  VTEMP1	EXTRACT FUNCTION DRIVER AND
	W1   EADX	 ARGUMENT CONVERSION DRIVER FROM
	W2   NOZX	 RINTRI ENTRY.
	CSF  ELPARE
*
ELEM5A	EQU  $
	JSB  TERMSC	SCAN & GENERATE POLISH EXPRESSION
	SPT  TLOGIC	 FOR EACH ARGUMENT
	JAT  ZTYPE
	W1   FETX
	MON  RPOLIS	PUSH ARGUMENT CONVERSION DRIVER
	JOW  $+6	 ON RPOLIS FOR EACH ARG
	CSF  ECOMMA
	JUN  ELEM5A
	CSA  ERPARE	* IS THIS THE END OF THE LIST?
	JAT  ELE5A1	* BRIF YES (USED MINIMUM ARGS)
	CSA  ECOMMA	* IS THERE ANOTHER ARGUMENT?
	JAF  ZSYNTA	* NO, ITS A SYNTAX ERROR
	FET  VARGSA	* ELSE, GET # ARGUMENTS LEFT THAT I AM ALLOWED
ELE5A2  EQU  $
	JOW  ZSYNTA	* BRIF NO MORE ARGUMENTS ALLOWED
	W2   TLYX	* TALLY ARGUMENT COUNT
	JSB  TERMSC	* SCAN ANOTHER TERM
	SPT  TLOGIC	* IS IT A LOGICAL EXPRESSION?
	JAT  ZTYPE	* YES, LOGICALS AREN'T ALLOWED IN INTRINSIC
	W1   FETX	* GET CONVERSION DRIVER
	MON  RPOLIS	* PUT ON POLISH STACK
	CSA  ECOMMA	* ANOTHER ARGUMENT?
	JAT  ELE5A2	* BRIF YES, PROCESS IT
	POW  1		* POP THE ARG COUNT OFF OF THE WORK STACK
	CSF  ERPARE	* ELSE, IS THIS BETTER BE A RIGHT PARENTHESIS
ELE5A1  EQU  $		*
	POW  1		RPOLIS AS EXPRESSION ELEMENT
	JUN  ELEMMO
*
ELEM5B	EQU  $
	POW  1		NON-INTRINSIC ARGUMENT:
*
ELEM5C	EQU  $
	JSB  SPROGS	SCAN ARGUMENT LIST
	JUN  ELEMMO	MOVE POINTER TO POLISH STACK
*
ELEM6	EQU  $
	ZER  VGENID	SET NO PREVIOUS CHARACTER
	JML  AGENCO	NUMERIC OR STACK CONSTANT
	JSB  CONSTR	SCAN & REGISTER
	JUN  ELEMMO	MOVE POINTER TO POLISH STACK
*
ELEM7	EQU  $
	SCK  DIGITK	NUMERIC OR LOGICAL CONSTANT
	JAT  ELEM8
	FET  DNOT	.NOT.
	QSA  QNOT	GET .NOT. & SCAN NEXT ELEM
	JAT  ELEMSC
	CLA  KTRUE
	QSA  QTRUE	LOGICAL .TRUE. OR .FALSE.
	JAT  $+6	SCAN & REGISTER (1 OR 0)
	CLA  KFALSE	INSERT LOGICAL TAG
	QSF  QFALSE	MOVE POINTER TO POLISH STACK
	JSB  REGWKC
	ITA  TLOGIC
	JUN  ELEMMO
*
ELEM8	EQU  $
	FET  VLSTCH	FETCH LAST CHARACTER (A DECIMAL POINT)
	ASP  VGENID	 AND SAVE FOR CONSTANT SCAN ROUTINE
	JML  AGENCO	CONSTANT SCAN
	JSB  CONSTR	REGISTER CONSTANT
	JUN  ELEMMO	MOVE POINTER TO POLISH STACK
*
*  TERM IS IN PARENTHESIS.  TRY FOR A COMPLEX CONSTANT, WHICH IS
*  IN THE FORM OF (X,Y).  IF IT ISN'T A COMPLEX CONSTANT, THEN IT
*  IS THE START OF A NEW TERM.
*
ELEM9	EQU  $
	RSV  RTEMP	SAVE TEMP STACK
	FET  PCURCH	FETCH CURRENT CHARACTER
	JML  ANXTCH	SKIP LEADING LEFT PARENTHESIS
	JSB  PARSCM	GO PARSE COMPLEX CONSTANT
	JAF  ELEM9C	BRIF NOT A COMPLEX CONSTANT
	W1   SWTX	SAVE CURRENT CONSTANT TYPE (C*8 OR C*16)
	POW  1		FORGET OLD CHARACTER POINTER
	JSB  CONSTR	REGISTER CONSTANT
	JUN  ELEMMO	GO MOVE ELEMENT
*
*  NOT A COMPLEX CONSTANT.  MUST BE A LEFT PAREN FOLLOWED BY A NORMAL
*  CONSTANT (START OF NEW TERM).  PARSE IT.
*
ELEM9C	EQU  $
	REL  RTEMP
	ASP  PCURCH	REMEMBER OLD CHARACTER POSITION
	JML  ANXTCH	GET STARTING CHARACTER AGAIN
	JSB  TERMSC	TERM IN PARENTHESIS
	CSF  ERPARE	SCAN TERM
	JUN  OPSCAN	SCAN FOLLOWING OPERATOR
*
*  QUOTED HOLLERITH CONSTANT
*
ELEM10	EQU  $
	RSV  RTEMP
	FET  PCURCH
	JSB  QUOTSC
	SCE  EX
	JAT  ELE10A
	POW  1
	JSB  HOLLRE	SCAN & REGISTER
	JUN  ELEMMO	MOVE POINTER TO POLISH STACK
*
ELE10A	EQU  $
	REL  RTEMP	PROCESS HEX EXPRESSION IN
	ASP  PCURCH	FORM 'XXXX'X
	JML  ANXTCH
	JML  AHEXSC	SCAN HEXADECIMAL CONSTANT
	CSF  EQUOTE
	CSF  EX
	JSB  CONSTR
	JUN  ELEMMO
*
ELE10B	EQU  $
	JML  ABINSC	SCAN BINARY CONSTANT
	CSF  EQUOTE	MUST BE TERMINATED BY QUOTE
	JSB  CONSTR	REGISTER CONSTANT
	JUN  ELEMMO
*
ELE10C	EQU  $
	JML  AOCTSC	SCAN OCTAL CONSTANT
	CSF  EQUOTE	MUST BE TERMINATED BY QUOTE
	JSB  CONSTR	REGISTER CONSTANT
	JUN  ELEMMO
*
ELE10D	EQU  $
	JML  AHEXSC	SCAN HEXADECIMAL CONSTANT
	CSF  EQUOTE	MUST BE TERMINATED BY QUOTE
	JSB  CONSTR	REGISTER CONSTANT
	JUN  ELEMMO
*
ELEMMO	EQU  $
	ZER  FARG	MOVE ELEMENT POINTER TO POLISH STACK
	MON  RPOLIS	RESET FIRST SUBPROGRAM ARGUMENT ELEMENT POINTER
*
OPSCAN	EQU  $
	CSA  EPERIO	SCAN FOR NEXT OPERATOR OF TERM
	JAT  OPSCA1	'.' -- LOGICAL OR RELATIONAL OP
	FET  DADD
	CSA  EPLUS	ELSE - NUMERIC OR END OF TERM
	JAT  OPSCA2
	CLA  DSUB
	CSA  EMINUS
	JAT  OPSCA2
	CLA  DDIV
	CSA  ESLASH
	JAT  OPSCA2
	CLA  DEOTER
	CSA  EASTRS
	JAF  OPSCA2
	CLA  DMULT
	CSA  EASTRS
	JAF  OPSCA2
	CLA  DEXPON
	JUN  OPSCA2
*
OPSCA1	EQU  $
	FET  DEQ	LOGICAL OR RELATIONAL OP
	QSA  QEQ
	JAT  OPSCA2
	CLA  DGE
	QSA  QGE
	JAT  OPSCA2
	CLA  DGT
	QSA  QGT
	JAT  OPSCA2
	CLA  DLE
	QSA  QLE
	JAT  OPSCA2
	CLA  DLT
	QSA  QLT
	JAT  OPSCA2
	CLA  DNE
	QSA  QNE
	JAT  OPSCA2
	CLA  DAND
	QSA  QAND
	JAT  OPSCA2
	CLA  DOR
	QSA  QOR
	JAT  OPSCA2
	CLA  DEOR
	QSF  QEOR
*
OPSCA2	EQU  $
	ASP  VCRNTO	INSERT OP INTO POLISH EXPRESSION
*
OPSCA3	EQU  $
	W0   EADX	COMPARE PRECEDENCES OF CURRENT
	EAD  VCRNTO	OPERATOR & PREVIOUS OPERATOR
	W1   SLEX
	POW  2
	JAF  OPSCA4
	SNE  DTERM	CURRENT LOWER OR EQUAL
	JAF  CLR1EX	EXIT TERMSCAN IF PREVIOUS=MARKER
	JSB  TYPECH
	MOA  RPOLIS	CHECK FOR LOGIC/NUMERIC CONFLICT
	W1   ETAX	 BETWEEN PREVIOUS OPERATOR & ITS
	W1   ETAX 	 RIGHT HAND ARG (ON POLISH STACK)
	W1   SLEX
	POW  2
        JAT  $+8 
	W1   SWTX	INSERT HIGH OF 2 TAGS INTO
	W1   ITAX	PREVIOUS OP DRIVER
	W1   SWTX
	MON  RPOLIS
	SAD  KRLPRE	MOVE PREIOUS OP DRIVER ONTO
	JAF  $+8	 POLISH STACK. IF RELATIONAL, MOVE
	W0   ETAX	 TAG ONTO FIRST, THEN FOLLOW BY
	MON  RPOLIS	DRIVER WITH LOGICAL TAG INSERTED
	ITA  TLOGIC
	MON  RPOLIS
	JUN  OPSCA3	REPEAT FOR NEXT PREVIOUS OPERATOR
*
OPSCA4	EQU  $
	FET  VCRNTO	CURRENT GREATER:
	JSB  TYPECH	CHECK FOR LOGIC/NUMERIC CONFLICT
	MOA  RPOLIS	 BETWEEN CURRENT OPERATOR & ITS
	W1   SWTX	 LEFT HAND ARG (ON POLISH STACK)
	W1   ITAX
	W1   SWTX	INSERT LEFT-HAND ARGUMENT TAG IN CURRENT DRIVER
	MON  RPOLIS	 LEAVE CURRENT DRIVER ON WORK STACK
	JUN  ELEMSC	 SCAN NEXT ELEMENT OF TERM
*
TYPECH	EQU  $
	W0   EADX	COMPARE OPERATOR (W0) TYPE WITH
	SLE  KLGPRE	ARGUMENT (P0) TYPE
	JAF  NUMERC
	SPT  TLOGIC	LOGICAL OPERATOR:
	JAT  CLR1EX	TYPE CONFLICT UNLESS
	JUN  ZTYPE	LOGICAL OPERATOR
*
NUMERC	EQU  $
	SPT  TLOGIC	NUMERIC OPERATOR
	JAT  ZTYPE	TYPE CONFLICT UNLESS NUMERIC ARGUMENT
	JUN  CLR1EX
	TITL 'VARIABLE SCAN'
	PAGE
*
*  VARIABLE SCAN
*
*  RETURNS POINTER TO VARIABLE AT CURRENT SCAN POSITION
*
*  IF ARRAY, RETURNS A=F IF NO SUBSCRIPTS
*            RETURNS A=T OTHERWISE, W0 HOLDS POINTER
*             TO ELEMENT. CALCULATION CODE (IF ANY)
*             IS GENERATED ON CODE STACK.
*
VARSCA	EQU  $		SCAN VARIABLE
	JSB  IDSCAN
	JAF  REGSCA	REGISTER AS SCALAR IF UNKNOWN
*
VARCHE	EQU  $
	SOP  RSCALE	INSURE NAME IN CENTRAL IS VARIABLE
	JAT  EXIT	TAKE ID CONFLICT FAIL IF NOT
	SOP  RARRAY	SIMPLY RETURN POINTER IF SCALAR
	JAF  ZID	SCAN SUBSCRIPTS IF ARRAY
*
ARRAYS	EQU  $
	CSA  ELPARE	SCAN ARRAY SUBSCRIPTS & GEN CODE TO
	JAF  EXITFA	EVALUATE. EXIT FALSE IF NONE
	JSB  CALCSI
	JSB  SCRSET	INITIALIZE FOR SETUP
	ZER  VVARCN
	STG  TADJUS	CHECK FOR ADJUSTABLE DIMENSIONS
	JAT  ADJUS1	Y -- SCAN ALL SCRIPTS FIRST
*
	FLP  RTEMP	NON-ADJUSTABLE DIMENSIONS
	FET  VELEMS
*
NONAD1	EQU  $
	JSB  SCRIPT	SCAN & GENERATE FOR EACH SCRIPT
	W3   MULX	IN ORDER ENCOUNTERED
	SWT  VOFFSE
	SUP  VOFFSE
	ASP  VOFFSE	SUBTRACT M*J FROM VOFFSE
	SNE  KZERO
	JAT  NONA1A	CHECK FOR VARIABLE IN SCRIPT
	POW  3
	JUN  NONAD2	N -- CHECK FOR NEXT SCRIPT
*
NONA1A	EQU  $
	FET  VVARCN	VARIABLE, GEN 'MOV @VAR,R5'
        JOW  $+12
        JOW  $+8
	POC  IAR5R1	PRECEDE BY 'A R5,R2' IF >2ND
	POW  1
	JUN  $+4  
	POC  IMR5R1	PRECEDE BY 'MOV R5,R2' IF 2ND
	BIM  CLOAD
	W1   MULX
	JSB  GENIMU	FOLLOW BY 'MUL =M*K'
	POW  1
	TLY  VVARCN	UPDATE VARIABLE COUNT
*
NONAD2	EQU  $
	MOA  RTEMP	CHECK FOR NEXT SCRIPT
	JAF  NONAD3	Y -- MUST BE PRECEEDED BY COMMA
	CSA  ECOMMA
	JAT  NONAD1	COMMA -- SCAN NEXT SCRIPT
	JUN  ZSCRIP	ELSE TAKE SUBSCRIPT FAIL
*
NONAD3	EQU  $
	CSA  ERPARE	END OF SCRIPTS
	JAF  ZSCRIP	SUBSCRIPT FAIL UNLESS RPAREN
	FET  VVARCN
	SLE  KONE	GENERATE 'A R2,R5' IF MORE
	JAT  $+4	THAN 1 VARIABLE SCRIPT
	POC  IAR1R5
	POW  1
*
	STG  TDUMMY	CHECK FOR DUMMY ARRAY
	POW  1		Y -- GENERATE DUMMY WINDUP
	JAT  NONAD5
	SNZ  VVARCN	CHECK FOR VARIABLE SCRIPTS
	JAT  NONAD4	Y -- GENERATE BASE OFFSET
*
	JSB  CONSCR	NON-DUMMY ARRAY W/CONSTANT SCRIPTS
	ASK  VDATA2	INSURE SCRIPT VALUE WITHIN RANGE
	PNG  RDELTA
	PGO  RDELTA	GENERATE DELTA STACK ENTRY AND
	JUN  ARRAY2	RETURN DELTA POINTER
*
NONAD4	EQU  $
	FET  KZERO	NON-DUMMY ARRAY W/VARIABLE SCRIPTS
	SUP  VOFFSE
	ASP  VDATA3	REGISTER BASE-OFFSET VALUE
	ASK  VDATA2
	REG  RMODAD	GENERATE 'A =BASE-OFFSE'
	BIN  CADD
	SNZ  FSC	IF SUBSCRIPT OPTION, GENERATE LINK
	JAF  ARRAY1	TO NON-DUMMY ARRAY CHECK
	W0   FETX
	BIN  CSUBCH	GENERATE 'SC BASE T'
	FET  VMAXSC
	BIN  CDATA
	JUN  ARRAY1	GENERATE STORE IN ADR TMP
*
NONAD5	EQU  $
	SNZ  VVARCN	NON-ADJUSTABLE DUMMY ARRAY
	JAT  NONAD6
	SNZ  VOFFSE	CONSTANT SCRIPTS
	JAF  ARRAY3	ZERO OFFSET - RETURN ARRAY PTR
	JSB  CONSCR
	REG  RFXCON	ELSE GEN 'MOV @OFFSET,R5'
	BIN  CLOAD
	JUN  DUMMY1	GENERATE 'A   @BASETE,R5'
*
NONAD6	EQU  $
	SNZ  VOFFSE	VARIABLE SCRIPTS
        JAF  $+8
	FET  VOFFSE	GENERATE 'S @OFFSET,R5' UNLESS
	JSB  REGWKC	OFFSET VALUE IS ZERO
	BIN  CSUB
	SNZ  FSC
	JAF  DUMMY1	GENERATE 'NDSC T-VALUE' IF
	POC  INDSCH	SC OPTION
	FET  VMAXSC
	BIN  CDATA
	JUN  DUMMY1	GENERATE 'A  @BASETE,R5'
*
ADJUS1	EQU  $
	POW  1		ADJUSTABLY DIMENSIONED ARRAY
	RSV  RWORK	RESERVE WORK STACK
	CNT  RTEMP	INITIALIZE SCRIPT COUNT
*
ADJUS2	EQU  $
	ASP  VCDIME	SCAN ALL SCRIPTS OF ADJ DIMEN ARRAY
	JSB  SCRIPT
	W1   SNZX	SCAN 1 SCRIPT
	JAT  $+6  
	SNE  KONE	TALLY VVARCN UNLESS SCRIPT IS
	JAF  $+4	A CONSTANT 1
	TLY  VVARCN
	FET  VCDIME	SCAN NEXT SCRIPT IF ANY
	JOW  ADJUS3      N - BEGIN CODE GENERATION
	CSA  ECOMMA	 Y - INSURE SEPERATED BY COMMA
	JAT  ADJUS2	TAKE SUBSCRIPT FAIL IF NOT
	JUN  ZSCRIP
*
ADJUS3	EQU  $
	CSA  ERPARE	INSURE SCRIPTS FOLLOWED BY RPAREN
	JAF  ZSCRIP	N - TAKE SUBSCRIPT FAIL
	SNZ  VVARCN
	JAT  $+6	IF CONSTANT FIRST ELEM REFERENCE,
	REL  RWORK	GENERATE NO CODE - JUST RETURN
	JUN  ARRAY3	ARRAY POINTER
*
	W1   SNZX	BEGIN CODE GENERATION
	JAT  ADJUS4
	JSB  REGWKC	IF LAST SCRIPT IS CONSTANT 'J'
	BIN  CLOAD	THEN GEN 'LI R5,J'
	POW  2
	JUN  ADJUS6
*
ADJUS4	EQU  $
	W1   SWTX	ELSE GEN 'MOV @V,R5'
	BIM  CLOAD		 'MUL @K'
	W1   SWTX
	JSB  GENIMU
*
ADJUS5	EQU  $
	JOW  ADJUS6	GENERATE ADJ DIMEN SCRIPT CODE
	ADP  KONE
	JSB  REGWKC	GEN 'AI R5,J' IF ANY J
	BIN  CADD
*
ADJUS6	EQU  $
	MOA  RTEMP	GEN 'MUL @D(I-1)'
	JAF  ADJUS8	IF I=0, THIS IS END OF CALC
	BIM  CMULT
	W2   SWTX	PREVIOUS SCRIPT:
	SLE  KTWO
	JAT  ADJUS7	K>2, GENERATE
	POC  IMR5R1
	W1   SWTX	 'MOV  R5,R2'
	BIM  CLOAD	 'MOV  @V,R5'
	JSB  REGWKC	 'MUL  K,R5'
	BIN  CMULT	 'A    R2,R5'
	POC  IAR1R5
	JUN  ADJUS5
*
ADJUS7	EQU  $
	SNE  KTWO	K=2, GENERATE
        JAT  $+8
	W1   CLAX	 'A   @V,R5'
	BIM  CADD	 'A   @V,R5'
        JUN  $+8
	POW  1
	JOW  ADJUS5	ELSE GENERATE 'A @V,R5' IF ANY V
	ADP  KONE
	BIM  CADD
	JUN  ADJUS5	LOOP BACK TO GEN 'A @J,R5'
*
ADJUS8	EQU  $
	REL  RWORK	END OF ADJ DIMEN GEN
	FET  VELEMS
	JSB  GENIMU	GEN 'MUL @ELEMSI,R5'
	FET  VOFFSE
	SNZ  VOFFSE	GEN 'S   @OFFSET,R5'
	JAT  $+6  
	CLA  VELEMS	FOR D=1, OFFSET=ELEMSIZE
	JSB  REGWKC
	BIN  CSUB
	SNZ  FSC	GEN 'DSC T-TEMP' IF SC OPTION
	JAF  DUMMY1
	FET  VMAXSC
	BIN  CADSCH
*
DUMMY1	EQU  $
	JML  ALDGRP	ANY DUMMY ARRAY W/GENERATED CODE
	SWA  RGDUMM	GENERATE 'A @BASETE,R5'
	BIN  CADD
*
ARRAY1	EQU  $
	JSB  ATEMPM	ANY ARRAY W/GENERATED CODE
	W0   FETX
	BIN  CSTORE	GENERATE 'MOV R5,@ADRTEM'
*
ARRAY2	EQU  $
	W1   ITAX	ANY ARRAY RETURNING DIFFERENT PTR
	W1   ASPX	INSERT TAG & DISCARD ARRAY PTR
*
ARRAY3	EQU  $
	REL  RTEMP	ANY ARRAY
	JUN  EXIT	RELEASE TEMP STACK & RETURN
*
SCRIPT	EQU  $		SCAN 1 SUBSCRIPT (K*V  J)
	FET  KONE	RETURN: W0 HOLDS J VAL
	FET  KZERO		W1 HOLDS V PTR
	FET  KZERO		W2 HOLDS K VAL
	SCK  LETTRK
	JAT  SCRIP1	DIGIT: SCAN K OR J
	JSB  INTSCA
	CLA  VDATA3
	CSA  EASTRS
	JAF  EXIT	'*' FOLLOWS - WAS K
	W2   ASKX	ELSE WAS CONSTANT J
	CLA  KZERO
*
SCRIP1	EQU  $
	JSB  ISCALS	LETTER: SCAN INTEGER SCALAR V
	W2   ASPX
	CSA  EMINUS	CHECK FOR   J OR -J
	JAT  SCRIP2
	CSA  EPLUS
	JAF  EXIT	NO -- RETURN 0
	JSB  INTSCA
	CLA  VDATA3
	JUN  EXIT	J - RETURN   #
*
SCRIP2	EQU  $
	JSB  INTSCA
	SUP  VDATA3
	JUN  EXIT	-J - RETURN -#
*
GENIMU	EQU  $		GENERATE MULT BY POS INTEGER
	SNE  KONE	IS IT ONE ?
	JAF  CLR1EX	BRIF YES, JUST EXIT
	SNE  KTWO
	JAF  GENIM2	BRIF ITS 2
	SNE  KFOUR
	JAF  GENIM4	BRIF ITS 4
	SNE  KEIGHT
	JAF  GENIM8	BRIF ITS 8
*
	JSB  REGWKC	ELSE, GEN GENERAL MULTIPLY
	BIN  CMULT	USING CONSTANT PASSED
	JUN  EXIT	& EXIT
*
GENIM2	EQU  $
	POC  IAR5R5	=2, ADD R5,R5
	JUN  CLR1EX
*
GENIM4	EQU  $
	POC  IMUL4K	=4, SLA R5,2
	JUN  CLR1EX
*
GENIM8	EQU  $
	POC  IMUL8K	=8, SLA R5,3
	JUN  CLR1EX
*
*  ISCALS : SCAN INTEGER SCALAR VARIABLE.
*
ISCALS	EQU  $
	JSB  KSCALS	SCAN FOR ANY TYPE OF SCALAR VARIABLE
	STG  TINTEG	MAKE SURE TYPE IS INTEGER *2
	JAF  ZTYPE	TYPE CONFLICT IF NOT INTEGER *2
	JUN  EXIT
*
*  JSCALS : SCAN FOR ANY INTEGER TYPE (I*1, I*2, I*4)
*
JSCALS	EQU  $
	JSB  KSCALS	SCAN FOR ANY TYPE OF INTEGER
	STG  TINTEG
	JAT  EXIT
	STG  TDBYTE
	JAT  EXIT
	STG  TDINT4
	JAT  EXIT
	JUN  ZTYPE
*
*  KSCALS : SCAN FOR A VARIABLE NAME, REGARDLESS OF TYPE
*
KSCALS	EQU  $
	JSB  IDSCAN	SCAN SCALAR VARIABLE
	JAT  $+4
	JSB  REGSCA
	SOP  RSCALE
	JAT  $+6	ID CONFLICT IF NOT SCALAR OR
	SOP  RLDUMM	 LOCAL DUMMY
	JAF  ZID
	JUN  EXIT
*
*  CONSCR : CONSTANT SCRIPT
*
CONSCR	EQU  $
	FET  KZERO	CONSTANT SCRIPTS - ENSURE WITHIN
	SUP  VOFFSE	 RANGE & RETURN PROPERLY SIGNED
	SLE  KMONE	 OFFSET IN VDATA3
	JAT  ZSCRIP
	ASK  VDATA3
	CLA  VMAXSC
	SLE  VDATA3	-1 < VALID RANGE < VMAXSC
	JAF  CLR1EX
	JUN  ZSCRIP
*
SCRSET	EQU  $
	W0   FETX	INITIALIZE FOR ARRAY SCRIPT SCAN
	FRP  RUNG4
	ASK  VOFFSE	OFFSET VALUE IS VOFFSET
	W1   CLAX
	FRP  RUNG3	STATS POINTER ON WORK STACK
	W0   FETX
	RSV  RTEMP	STATS ON TEMP STACK
	CPO  RTEMP
	MOA  RTEMP	MAX SCRIPT VALUE IN VMAXSC
	ASP  VMAXSC
	JUN  EXIT
*
	TITL 'SUBPROGRAMS'
	PAGE
*
*  SUBPROGRAM SCAN
*
SPROGS	EQU  $		SCAN SUBPROGRAM ARGUMENTS
	FET  DSPROG	ENTRY:	SCAN POSITION RIGHT OF NAME
	W1   ITAX		SPROG POINTER ON WORK STACK
	W1   SWTX	RETURN W/CODE ON POLISH STACK &
	MON  RPOLIS	 SUBPROGRAM DRIVER W/# ARGS ON WORK STACK
	CSA  ELPARE
	JAF  EXIT
*
SPROG1	EQU  $
	NOZ  FARG	SCAN SINGLE ARGUMENT TERM
	JSB  TERMSC	(SUBPROGRAM NAME W/O ARGLIST OR ARRAY
	ADP  KONE	 NAME W/O SCRIPTS ALLOWABLE)
	CSA  ECOMMA
	JAT  SPROG1	REPEAT FOR EACH ARGUMENT
	CSF  ERPARE
	JUN  EXIT	INSURE RIGHT PARENTHESIS & EXIT
	TITL 'REGISTER CONSTANT'
	PAGE
*
*  REGISTER CONSTANT
*
CONSTR	EQU  $		REGISTER CONSTANT IN DATA1-3
	STG  TINTEG	  ENTRY: TAG ON W0
	JAT  CONSR1	  RETURN PTR ON W0
*
	STG  TDBYTE
	JAT  CONSRB
*
	STG  TDINT4
	JAT  CONSR4
*
	STG  TSREAL
	JAT  CONSRS
*
	STG  TDREAL
	JAT  CONSRD
*
	STG  TC8TYP
	JAT  CONSR8
*
	REG  RC6CON	REGISTER COMPLEX *16
	JUN  CONSRC
*
CONSR8	EQU  $		REGISTER COMPLEX *8
	REG  RC8CON
	JUN  CONSRC
*
CONSRD	EQU  $
	REG  RDPCON	REGISTER DOUBLE PRECISION
	JUN  CONSRC
*
CONSRS	EQU  $
	REG  RSPCON	REGISTER SINGLE PRECISION
	JUN  CONSRC
*
CONSR4	EQU  $
	REG  RI4CON	REGISTER INTEGER *4
	JUN  CONSRC
*
CONSRB	EQU  $
	REG  RBYCON	REGISTER INTEGER *1
*
CONSRC	EQU  $
	W1   ITAX	INSERT TAG
	W1   ASPX	RETURN TO CALLER
	JUN  EXIT
*
CONSR1	EQU  $
	CLA  VDATA3	INTEGER *2 TYPE
	SCE  EH		ENSURE NO FOLLOWING H
	JAF  REGWKC	IF NOT, REGISTER INTEGER
	JSB  HOLLSC	OTHERWISE REGISTER HOLLERITH
*
HOLLRE	EQU  $
	FET  KBLANS	FETCH BLANKS
	ASK  VDATA1
	ASK  VDATA2	CLEAR OUT POSSIBLE TEXT BUFFER
	ASK  VDATA3
	ASK  VDATA4
	ASK  VDATA5
	ASK  VDATA6
	ASK  VDATA7
	ASP  VDATA8
	MOA  RTEMP
	JAF  ZNUMBE	ZERO WORDS, NUMBER FAIL
	MOA  RTEMP
	JAF  HOLLRI	SINGLE WORD - INTEGER OR BYTE
	MOA  RTEMP
	JAF  HOLLRS	DOUBLE WORD - SINGLE PRECISION
	MOA  RTEMP	REGISTER HOLLERITH CONSTANT
	JAF  HOLLRD	TRIPLE WORD - DOUBLE PRECISION
	MOA  RTEMP
	JAF  HOLLRQ	EXECUTE QUAD WORD MOVE
	MOA  RTEMP
	JAF  HOLLR5
	MOA  RTEMP
	JAF  HOLLR6
	MOA  RTEMP
	JAF  HOLLR7
	MOA  RTEMP
	JAF  HOLLR8
	MOA  RTEMP
	JAT  ZNUMBE	MORE THAN 8 WORDS, NUMBER FAIL
*
HOLLR5	EQU  $
	ASP  VDATA1	5 WORDS, USE VDATA1-5
	ASP  VDATA2
	ASP  VDATA3
	ASP  VDATA4
	ASP  VDATA5
	JUN  CMPLXC
*
HOLLR6	EQU  $		6 WORDS, USE VDATA1-6
	ASP  VDATA1
	ASP  VDATA2
	ASP  VDATA3
	ASP  VDATA4
	ASP  VDATA5
	ASP  VDATA6
	JUN  CMPLXC
*
HOLLR7	EQU  $		7 WORDS, USE VDATA1-7
	ASP  VDATA1
	ASP  VDATA2
	ASP  VDATA3
	ASP  VDATA4
	ASP  VDATA5
	ASP  VDATA6
	ASP  VDATA7
	JUN  CMPLXC
*
HOLLR8	EQU  $		8 WORDS, USE VDATA1-8
	ASP  VDATA1
	ASP  VDATA2
	ASP  VDATA3
	ASP  VDATA4
	ASP  VDATA5
	ASP  VDATA6
	ASP  VDATA7
	ASP  VDATA8
CMPLXC	EQU  $
	ITA  RC6CON
	JUN  HOLLRX
*
HOLLRQ	EQU  $
	ASP  VDATA1	QUAD WORD, USE D.P.
	ASP  VDATA2
	ASP  VDATA3
	ASP  VDATA4
	JUN  HOLLRF
*
HOLLRD	EQU  $
	ASP  VDATA1	TRIPLE WORD, USE D.P.
	ASP  VDATA2
	ASP  VDATA3
*
HOLLRF	EQU  $		QUAD CLEANUP
	REG  RDPCON	SET DOUBLE PRECISION CONSTANT TYPE
	ITA  TDREAL
	JUN  HOLLRX
*
HOLLRS	EQU  $
	ASP  VDATA1	REGISTER SINGLE PRECISION HOLLERITH CONST
	ASP  VDATA2
	REG  RSPCON
	ITA  TSREAL
	JUN  HOLLRX
*
HOLLRI	EQU  $
	SNZ  VTICTO	WAS A SINGLE BYTE READ
	JAF  HOLLR1	BRIF NO, TWO BYTES READ, MUST BE INTEGER
	ASP  VDATA3	STORE CONSTANT
	REG  RBYCON	REGISTER IT
	ITA  TDBYTE	SET TAG AS A BYTE CONSTANT (FUTURE CHARACTER)
	JUN  HOLLRX
*
HOLLR1	EQU  $
	JSB  REGWKC	REGISTER INTEGER HOLLERITH CONSTANT
*
HOLLRX	EQU  $
	REL  RTEMP
	JUN  EXIT	RELEASE TEMP STACK & EXIT
*
*  HOLLSC : SCAN A HOLLERITH FIELD
*
HOLLSC	EQU  $		SCAN HOLLERITH FIELD (H)
	RSV  RTEMP
	SLE  KZERO	ENTRY: COUNT ON W0
	JAT  ZNUMBE	CURRENT CHAR IS H
	ZER  VTICTO
	NOZ  FBLANK	RETURN WORDS ON RSV'D TEMP STACK
	JML  ANXTCH
*
HOLLS1	EQU  $
	JOW  HOLLQU	FOR EACH CHARACTER IN FIELD:
	SCE  ECARRT
	JAT  ZSYNTA	INSURE NOT CAR RETN
	JML  ANXTCH	GET NEXT CHAR
	JSB  PACK	PACK LAST CHAR
	JUN  HOLLS1	REPEAT
*
HOLLQU	EQU  $
	ZER  FBLANK	UPDATE SCAN POINTER IF ON BLANK
	CSA  EBLANK
	JUN  EXIT	EXIT
*
*  QUOTSC : SCAN A QUOTED STRING
*
QUOTSC	EQU  $
	ZER  VTICTO	SCAN HOLLERITH FIELD (')
	NOZ  FBLANK	ENTRY: CURRENT CHAR IS FIRST QT
	JML  ANXTCH	RETURN WORDS ON UNRSV'D TEMP STACK
*
QUOTS1	EQU  $
	SCE  ECARRT	FOR EACH CHARACTER IN FIELD:
	JAT  ZSYNTA
	CSA  EQUOTE	INSURE NOT CARRAIGE RETURN
	JAF  $+6	EXIT ON QUOTE CHARACTER UNLESS
	SCE  EQUOTE	 DOUBLE QUOTE, IN WHICH CASE
	JAF  HOLLQU	 PACK SINGLE CHARACTER
	JML  ANXTCH	GET NEXT CHARACTER
	JSB  PACK	PACK LAST CHARACTER
	JUN  QUOTS1
*
PACK 	EQU  $
	SNZ  VTICTO	PACK LAST CHAR INTO WORD ON
	JAT  PACKLO	TEMP STACK
	NOZ  VTICTO
	FET  VLSTCH	HIGH CHARACTER -- PAD ON RIGHT
	SCL  8		WITH BLANK & MOVE ON TEMP STACK
	ADP  KBLANK
	MON  RTEMP	TOGGLE VTICTO & EXIT
	JUN  EXIT
*
PACKLO	EQU  $
	ZER  VTICTO	LOW CHARACTER - COMBINE WITH
	MOA  RTEMP	 HIGH CHARACTER IN LAST WORD ON
	SUP  KBLANK	 TEMP STACK
	ADP  VLSTCH
	MON  RTEMP	TOGGLE VTICTO & EXIT
	JUN  EXIT
	TITL 'EXPRESSION GENERATION'
	PAGE
*
*  EXPRESSION GENERATION
*
FXEXPG	EQU  $		GENERATE INTEGER EXPRESSION WITH
	JSB  EXPRGE	 PROPER SIGN
	STG  TINTEG
	JAT  EXIT	RESULT IN EITHER R5 OR STORAGE
	STG  TLOGIC
	JAT  ZTYPE	TYPE CONFLICT IF INT/LOGICAL CONV
	JSB  LOADCH
	FET  TINTEG	FOR CONVERSION, ENSURE IN R5
	NOZ  FMXMOD
	JUN  CONVGE
*
*  KXEXPG :  GENERATE NUMERICAL EXPRESSION OF ANY TYPE
*
KXEXPG	EQU  $		GENERATE PASSED TYPE EXPRESSION WITH
	JSB  EXPRGE	 PROPER SIGN
	STG  TLOGIC	MAKE SURE NOT LOGICAL OR CHARACTER TYPES
	JAT  ZTYPE
*
	JSB  LOADCH	ENSURE VALUE IS LOADED
	W0   FETX	ENSURE TYPE MATCHES TARGET VARIABLE
	ANP  KTAGFL
	FET  VSELEM
	W1   SNEX	COMPARE W0/W1
	POW  2
	JAF  EXIT	BRIF BOTH THE SAME
	NOZ  FMXMOD	SET WARNING - MIXED MODE
	FET  VSELEM	CONVERT TO TAG TYPE
	JUN  CONVGE	CONVERT TO PROPER TYPE
*
*  EXPRGE : GENERATE EXPRESSION WITH PROPER SIGN
*
EXPRGE	EQU  $
	JSB  GENERA	RESULT IN EITHER R5 OR STORAGE
	W1   SNZX
	W1   ASPX	IF SIGN OK, SIMPLY RETURN PTR
	JAF  EXIT
	JSB  LOADCH	FOR SIGN CHANGE, SIMPLY RETURN PTR
*
CHNGSI	EQU  $
	W0   ETAX	GENERATE CHANGE SIGN
	SCL  8		 IN LOW BYTE
	SCL  1
	ADP  ICHSIG	+ BASE
	MON  RCODE	EXTRACT TAG, ADD TO CHANGE-
	JUN  EXIT	SIGN BASE, AND OUTPUT
*
GENERA	EQU  $		GENERATE CODE TO EVALUATE EXPR
	MOA  RPOLIS
	W0   EOPX	RETURN SIGN OF EXPR ON W1
	SCL  6
	SLE  KMAXPT
	JAF  DRIVER
	CLA  KPLUS	IF 'EXPR' IS SINGLE PTR,
	W1   SWTX	RETURN SIGN & PTR
	JUN  EXIT
*
DRIVER	EQU  $		IF 'EXPR' BEGINS WITH DRIVER, GO
	ASP  VTEMP1	THROUGH TABLE TO APPROPRIATE GEN
*			ROUTINE. LEAVE DRIVER ON W0
	JML  ADRIVE
DRIVET	EQU  $
	DATA EORGEN-POP/2
	DATA ORGEN-POP/2
	DATA ANDGEN-POP/2
	DATA NOTGEN-POP/2
	DATA EQGEN-POP/2
	DATA NEGEN-POP/2
	DATA LTGEN-POP/2
	DATA GTGEN-POP/2
	DATA LEGEN-POP/2
	DATA GEGEN-POP/2
	DATA SUBGEN-POP/2
	DATA ADDGEN-POP/2
	DATA MULTGE-POP/2
	DATA DIVGEN-POP/2
	DATA EXPONG-POP/2
	DATA UNMING-POP/2
	DATA SPROGG-POP/2
	DATA CVNGEN-POP/2
	DATA CVEGEN-POP/2
	DATA IANDGE-POP/2
	DATA IIORGE-POP/2
	DATA IEORGE-POP/2
	DATA INOTGE-POP/2
	DATA IABSGE-POP/2
	DATA JABSGE-POP/2
*
ANDGEN	EQU  $		Generate logical AND
	JSB  BINARY	 Evaluate both arguments and discard sign
	POW  1		 generate AND instruction
	BIM  CAND	 return accumulator pointer
	JUN  ACCRSL
*
ORGEN	EQU  $
	JSB  BINARY	Generate logical OR
	POW  1		 Evaluate both arguments and discard sign
	BIM  CADD	 generate ADD instruction
	POC  JCOR	 Generate 'JEQ  $+2',  'SETO R5'
	JUN  ACCRSL	 return accumulator pointer
*
EORGEN	EQU  $
	JSB  BINARY	Generate logical EOR
	POW  1		 Evaluate both arguments and discard sign
	BIM  CADD	 Generate ADD instruction
	POC  IANDK1	 Generate 'ANDI 1'
	JUN  ACCRSL	 return accumulator pointer
*
NOTGEN	EQU  $
	JSB  GENERA	Generate logical NOT
	JSB  LOADCH	 Generate argument evaluation (no conversion)
	POW  1		 ensure result in accumulator and
	POC  ISETST	  discard pointer.  Generate 'MOV R5,R5'.
	JUN  EQGEN1
*
EQGEN	EQU  $
	JSB  RELATO	Generate relational EQ
*
EQGEN1	EQU  $		After compare, move compare bit to R5
	POC  ISETEQ	 and return accumulator pointer
	JUN  ACCRSL
*
NEGEN	EQU  $
	JSB  RELATO	Generate relational NE
	POC  JCNE
	JUN  ACCRSL
*
LTGEN	EQU  $		Generate relational LT
	JSB  RELATO
	JAF  GTGEN1
*
LTGEN1	EQU  $		
	POC  JCLT
	JUN  ACCRSL
*
GTGEN	EQU  $		Generate relational GT
	JSB  RELATO
	JAF  LTGEN1
*
GTGEN1	EQU  $
	POC  JCGT
	JUN  ACCRSL
*
LEGEN	EQU  $		Generate relational LE
	JSB  RELATO
	JAF  GEGEN1
*
LEGEN1	EQU  $
	POC  JCLE
	JUN  ACCRSL
*
GEGEN	EQU  $		Generate relational GE
	JSB  RELATO
	JAF  LEGEN1
*
GEGEN1	EQU  $
	POC  JCGE
	JUN  ACCRSL
*
RELATO	EQU  $		Generate relational operation arg evaluation
	MOA  RPOLIS	 and comparison.
	JSB  BINARY
	JAT  COMPRG	Return answer TRUE if compare in specified
	JSB  COMPRG	 order.  Return answer FALSE if otherwise.
	JAT  EXITFA
	JUN  EXIT
*
COMPRG	EQU  $		Generate relational operand compare
	W2   SNEX	 if argument signs differ, change sign of
	POW  1		 R5
	JAF  $+4
	JSB  CHNGSI	Generate change sign
	BIM  CCOMPA	Generate compare
	W1   ZERX
	JOW  EXIT	Return answer false if both args
	JUN  C1EXFA      inverted (neg), else answer=true.
*
SUBGEN	EQU  $		Generate SUBTRACTION
	JSB  GENACO	 Evaluate right-hand argument
	FET  KMINUS	 invert its sign
	W2   PSPX	 generate as if addition
	JSB  BINAR1
	JUN  COMBIN
*
ADDGEN	EQU  $
	JSB  BINARY	Generate ADDITION
*
COMBIN	EQU  $
	W2   SNEX
	W2   ASPX
	JAT  COMBI1
	BIM  CADD
	JUN  ACCRSL
*
COMBI1	EQU  $
	BIM  CSUB
	JUN  ACCRSL
*
MULTGE	EQU  $		Arithmetic MULTIPLY
	JSB  BINARY
	W2   PSPX
	BIM  CMULT
	JUN  ACCRSL
*
DIVGEN	EQU  $		Arithmetic DIVIDE
	JSB  GENACO
	JSB  STOREC
	JSB  GENACO
	JSB  LOADCH
	POW  1
	W2   PSPX
	BIM  CDIV
*
ACCRSL	EQU  $		Return accumulator pointer
	W1   SWTX	 in place of driver
	ANP  KTAGFL
	ADP  PACCUM
	JUN  EXIT
*
CVNGEN	EQU  $		Generate type conversion w/o warning
	JSB  GENERA
	W2   STGX
	JAT  CVEGE1	 Execute evaluate expression
	JSB  LOADCH
	W2   ETAX	 Generate conversion if required
	JSB  CONVGE
	JUN  CVEGE1	 Return +sign and argument pointer
*
CVEGEN	EQU  $
	JSB  GENACO	Generate type conversion with warning
*
CVEGE1	EQU  $		 Evaluate expression
	W2   ASPX	 Generate conversion if required
	W1   SWTX	 Return +sign and argument pointer
	JUN  EXIT
*
IANDGE	EQU  $		IAND(I,J)
	JSB  EXPRGE
	JSB  STOREC
	JSB  EXPRGE
	JSB  LOADCH
	POW  1
	BIM  CAND
	FET  KPLUS
	JUN  ACCRSL
*
IIORGE	EQU  $		IOR(I,J)
	JSB  EXPRGE
	JSB  STOREC
	JSB  EXPRGE
	JSB  LOADCH
	POW  1
	BIM  CAOR
	FET  KPLUS
	JUN  ACCRSL
*
IEORGE	EQU  $		IEOR(I,J)
	JSB  EXPRGE
	JSB  STOREC
	JSB  EXPRGE
	JSB  LOADCH
	POW  1
	BIM  CAEOR
	FET  KPLUS
	JUN  ACCRSL
*
INOTGE	EQU  $		NOT(I)
	JSB  EXPRGE
	JSB  LOADCH		MOV @X,R5
	POC  IINVR5		INV R5
	CLA  KPLUS
	JUN  ACCRSL
*
IABSGE	EQU  $		IABS(I)
	JSB  EXPRGE
	JSB  LOADCH		MOV @X,R5
	POC  IABS		ABS R5
	CLA  KPLUS
	JUN  ACCRSL
*
JABSGE	EQU  $		JIABS(J)
	JSB  EXPRGE
	JSB  LOADCH		INTEGER *4 EXPRESSION
	POC  JABS
	CLA  KPLUS
	JUN  ACCRSL
*
EXPONG	EQU  $		Generate Exponentiation
	FET  PACCUM
	W1   ITAX
	W1   ZERX
	JSB  EXPRGE
	JSB  ARGCHE
	JSB  EXPRGE
	JSB  ARGCHE
	W1   SWTX
	W1   ETAX
	JSB  SETIND
	ADP  PEXPON		INDEX INTO EXPONENTATION STACK
	FRP  RUNG0
	ASK  VSYM1
	CLA  MBLANK
	ASK  VSYM2
	ASP  VSYM3
	REG  RGSPRO
	BIN  CCALL
	RSV  RPTRS
	MON  RPTRS
	MON  RPTRS
	FET  KTWO
	FET  KFOUR
	JUN  ARGLIS
*
UNMING	EQU  $
	POW  1
	JSB  GENERA
	FET  KMINUS
	W2   PSPX
	JUN  EXIT
*
SPROGG	EQU  $		Generate Sub-Program Link as part of
	FET  PACCUM	 arithmetic expression.
	W1   ITAX
	FET  KPLUS	Return + sign and accumulator pointer
	W2   SWTX
*
*  LINKGE : GENERATE SUBPROGRAM ARGUMENT EVALUATION AND SUBPROGRAM
*	    LINKAGE.
*
LINKGE	EQU  $
	RSV  RPTRS
	W0   EADX
	W1   ASKX	Extract # of arguments for sprogram driver
	CLA  KFOUR
	W1   FETX	Initialize keyword and keycount
*
LINKG1	EQU  $
	JOW  LINKG2	For each argument expression:
	JSB  EXPRGE	  Generate evaluation code
	JSB  ARGCHE	  ensure result is in storage
	MON  RPTRS	  save pointer to result
	JUN  LINKG1
*
LINKG2	EQU  $		Generate linkage to subprogram
	MOA  RPOLIS
	SOP  RLSPRO
	JAT  $+6  
	BIM  CCALL	 'CALL' if external subprogram
	JUN  $+6
	FRP  RUNG3	 'FUNCT' if statement function
	BIN  CFUNCT
*
*  ARGLIS :  GENERATE KEYWORDS AND ARGUMENTS FOR POINTERS ON
*	     THE RPTRS STACK
*
ARGLIS	EQU  $
	RSV  RCODE
	RSV  RTEMP
	ASP  VKEYCN	SET KEYWORD AND KEYCOUNT
	ASP  VKEYWD
	ZER  VARGCN
	MOA  RPTRS
	JAF  $+6	For each argument pointer:
	JSB  KEYLIS	  Generate appropriate keyword
	JUN  $-6	  and list entry.
*
	REL  RPTRS
*
KEYDON	EQU  $		After scanning argument list, return
	FET  KEIGHT	 keywords followed by argument list
	SUP  VKEYCN	 on code stack
	SCL  1
	ASK  VINDIR
	CLA  VKEYWD
	IND  SCLX	Left justify last keyword
	MON  RTEMP
	CNT  RTEMP	Generate 'M   DATA,N   Keywords'
	W0   FETX	  where M is the count of args
	ADP  VARGCN	  and keywords combined
	CFC  RTEMP
	MON  RCODE
	ADP  IDATA
	MON  RCODE	Follow by argument list
	CTC  RTEMP
	JUN  EXIT	EXIT
*
KEYLIS	EQU  $
	FET  VKEYCN	Generate keywords and argument list
	SLE  KSEVEN	 Entry:  new list item on work stack
	CLA  VKEYWD
	JAT  KEYLI1	 Return address or data instruction
	MON  RTEMP	        on RCODE.  Update keyword and
	ZER  VKEYWD	        keycount
	ZER  VKEYCN	 If keyword complete, move to TEMP
	JUN  KEYLI2		   stack and initialize new word
*
KEYLI1	EQU  $		 Else, shift keyword left 2
	SCL  2
	ASP  VKEYWD
*
KEYLI2	EQU  $
	TLY  VKEYCN	 RETURN 0 KEY IF NO ARGUMENT FOUND
	JOW  EXIT
	ADP  KONE	 ELSE, UPDATE ARGUMENT COUNT
	TLY  VARGCN
	JSB  ARGEVA	 Return, key=1 if integer constant
	SNE  KTWO
	JAT  KEYLI3	         key=2 if address
	ADP  VKEYWD
	ASP  VKEYWD		 key=3 if global or local dummy
	JUN  KEYLI4
*
KEYLI3	EQU  $		Return 3 key if global or local
	ADP  KONE	 dummy and build address instruction
	ADP  VKEYWD
	ASP  VKEYWD
	SOP  RFXCON	FIXED AND BYTE CONSTANTS ARE FORMED INLINE;
	JAT  KEYLI5	 SO RETURN 0 KEY FOR DIRECT
	SOP  RBYCON
	JAT  KEYLI5
	TLY  VKEYWD
*
KEYLI4	EQU  $		Return 1 key if integer constant and
	BIN  CADRL	 build data instruction
	JUN  EXIT
*
KEYLI5	EQU  $		else, return key=2, and build address
	FRP  RUNG0	 instruction
	BIN  CDATA
	JUN  EXIT
*
*   BINARY OPERATOR SETUP
*
*     Generate argument evaluations for both arguments of a binary
*     operator.  Generate any required conversion (higher of 2 types
*     given by tag field of driver on W0).
*
*     Returns:     1. answer true              2. answer false
*
*         W3             DRIVER                     DRIVER
*         W2          RH-ARG SIGN                LH-ARG SIGN
*         W1          RH-ARG PTR                 LH-ARG PTR
*         W0          LH-ARG SIGN                RH-ARG SIGN
*
*                    LH ARG IN R5               RH ARG IN R5
*
BINARY	EQU  $			GENERATE RH ARG EVAL
	JSB  GENACO
*
BINAR1	EQU  $
	SOP  RACCUM	IF RH-ARG IN R5, CHECK IF LH-ARG
	JAF  BINAR3	 MUST BE EVALUATED
	MOA  RPOLIS
	W0   EOPX
	SCL  6
	SLE  KMAXPT
	POW  1
	JAF  BINAR2	LH-ARG SINGLE VALUE OF PROPER
	W1   STGX	 TYPE -- NO EVALUATION REQUIRED
	JAF  BINAR2
	W1   ASKX
	CLA  KPLUS	RETURN ANSWER FALSE
	W2   SWTX
	JUN  EXITFA
*
BINAR2	EQU  $
	MON  RPOLIS	ELSE, GENERATE TEMP STORE OF RH-ARG
	JSB  STOREG	 ENSURE RESULT IN ACCUMULATOR
*				 RETURN ANSWER TRUE
BINAR3	EQU  $
	JSB  GENACO
	JSB  LOADCH
	JUN  CLR1EX
*
GENACO	EQU  $		GENERATE EXPRESSION AND CONVERT TO
	JSB  GENERA	 TYPE SPECIFIED ON W0 (IF NECESSARY)
	W2   STGX
	JAT  EXIT
	JSB  LOADCH
	W2   ETAX	CONVERSION -- SET MIXED MODE FLAG
	NOZ  FMXMOD	 & FETCH ORIGINAL W0 TAG
*
*  CONVGE:  THIS ROUTINE DETERMINES THE CONVERSION TYPE NEEDED
*	    (E.G. INTEGER *2 TO INTEGER *1 [0 TO 1], AND FORMS
*	    AN INSTRUCTION OF TYPE ICONVR, WITH THE LOW EIGHT
*	    BITS SET TO THE FROM AND TO CONVERSION TYPES.  FOR
*	    EXAMPLE, A CONVERSION CODE TO CONVERT FROM INTEGER*2
*	    TO INTEGER *1 WOULD BE:
*
*		NNXY: (7101)   WHERE:
*
*		NN:  IS THE ICONVR CONVERSION OPCODE
*		X:   IS THE INDEX FOR INTEGER *2
*		Y:   IS THE INDEX FOR INTEGER *1
*
*	    THIS GENERATED CODE IS MOVED ONTO THE CODE STACK, AND
*	    THE TOP OF THE WORK STACK TAG IS UPDATED TO SHOW THE
*	    NEW TYPE OF VALUE ON THE STACK (E.G. '0080'X FOR INTEGER *1).
*
*  ON ENTRY, THE WORK STACK CONTAINS:
*
*         W0 - HAS THE TYPE OF CONVERSION WANTED (E.G. 0080 for INT*1)
*         W1 - HAS THE CURRENT TYPE, AS A ACCUMULATOR POINTER
*
*
CONVGE	EQU  $
	JSB  SETIND	GENERATE CONVERSION FROM TYPE SPECIFIED
	ADP  ICONVR	 IN W1 POINTER TO TYPE SPECIFIED BY
	MON  RCODE	 W0 TAG.  RETURN WITH W0 PRUNED &
	FET  VTEMP1	 W0 TAG IN POINTER
	ANP  XF
	SCL  7
	ASP  VTEMP1	SAVE NORMAL TAG FIELD FOR CURRENT ACCUMULATOR
	ITA  VTEMP1	AND INSERT TAG INTO ACCUMULATOR POINTER
	JUN  EXIT
*
SETIND	EQU  $		SET DUAL TYPE INDEX VALUE FROM TAG
	SCL  8		 INDEX = 4*T(W0)+ W1
	SCL  1
	ASP  VTEMP1	 ON W0 AND POINTER ON W1.
	W0   ETAX
	SCL  8
	SCL  5
	ADP  VTEMP1	 RETURN INDEX IN PLACE OF W0 TAG
	JUN  EXIT
*
LOADCH	EQU  $		ENSURE EXPR RESULT IN ACCUMULATOR PTR
	SOP  RACCUM	  Y -- JUST EXIT; ELSE
	JAT  EXIT
*
LOADGE	EQU  $		GENERATE LOAD INSTRUCTION
	FET  PACCUM
	W1   ITAX	RETURN TAGGED ACCUMULATOR POINTER IN
	W1   SWTX	 PLACE OF STORAGE POINTER
	BIM  CLOAD
	JUN  EXIT
*
ARGCHE	EQU  $		INSURE ARG SUITABLE AS SUBR ARG
*
STOREC	EQU  $		INSURE EXPR RESULT IN STORAGE
	SOP  RACCUM	 Y -- JUST EXIT; ELSE
	JAF  EXIT
*
STOREG	EQU  $		GENERATE STORE IN TEMPORARY
	JSB  TEMPMK	 RETURN TAGGED TEMP POINTER IN
	BIM  CSTORE	 PLACE OF ACCUMULATOR POINTER
	JUN  EXIT
*
*  BIM -  BUILD INSTRUCTION BY MODE, INTERPRETIVE SUBROUTINE
*
BIMXX	EQU  $
	JSB  ARGEVA	CALL ARGEVA TO EVALUATE POINTER
	ADP  VINSTR
	MON  RCODE	MOVE INSTRUCTION AND POINTER ONTO
	MON  RCODE	 CODE STACK AND EXIT
	JUN  EXIT
*
KBIM 	EQU  BIMXX-POP/2
*
ARGEVA	EQU  $		EVALUATE ARGUMENT POINTER ON W0
	ZER  VTEMP1
	W0   EOPX	RETURN KEY ON WA
	SCL  6
	SLE  KMAXLC	  00 - DIRECTLY ADDRESSABLE ARG
	JAT  ARGEV3	  01 - INDIRECTLY ADDRESSABLE
	SLE  KMAXDM	  10 - UNUSED
	POW  1		  11 - UNUSED
	JAT  ARGEV1
	JML  ALDGRP
	SWA  RGDUMM
	JAF  ARGEV5	IF GLOBAL DUMMY, RETURN DUMMY
	TLY  VTEMP1	 POINTER IN PLACE OF W0 POINTER
	JUN  ARGEV2
*
ARGEV1	EQU  $		IF LOCAL DUMMY, RETURN CONTENTS OF
	TLY  VTEMP1	 RUNG 3 ON LOCAL DUMMY STACK
	SOP  RLDUMM	 (ADR TEMP) IN PLACE OF W0 POINTER
	JAF  ARGEV5
	W0   FETX
	FRP  RUNG3
*
ARGEV2	EQU  $
	W1   ITAX
	W1   ASKX
	CLA  VTEMP1
	JUN  EXIT
*
ARGEV3	EQU  $		IF DELTA POINTER, BUILD DELTA
	POW  1		 INSTRUCTION AND RETURN ARRAY
	SOP  RDELTA	 POINTER FROM DELTA STACK IN PLACE
	JAF  ARGEV5	 OF W0 POINTER.
	W0   FETX
	FRP  RUNG1
	BIN  CDELTA
	FRP  RUNG0
	JUN  ARGEV5
*
ARGEV5	EQU  $		ELSE, SIMPLY RETURN POINTER THAT
	FET  VTEMP1	 WAS PASSED
	JUN  EXIT
*
	TITL 'ALLOCATION - ALLOCATE THE VARIABLES USED'
	PAGE
*
ALLOC	EQU  $		ALLOCATE DATA AREAS AND OUTPUT TABLES
	FEX  ALLOCA	 FOR SECOND PASS
	SNZ  FEND
	JAT  $+10
	JSB  TEMPIN
	EAW  ECARRT
	ASP  VCURCH	GENERATE TERMINAL STOP IF NO END STATEMENT
	JSB  ENDGEN	 WAS SCANNED, THEN RECORD R.L. OF TAIL
	POC  IENDLG	 START FOR PASS 2.
	JML  ATAILS
*
LDOLOO	EQU  $		FOR ALL DOLOOPS STILL OPEN:
	MOA  RDOLOO
	JAF  LIF
	W0   FETX
	FRP  RUNG0	FLAG TARGET LABEL AS MISUSED
	ITA  TMISUS
	ARP  RUNG0
	REL  RDOLOO	DISCARD CLOSING CODE.
	JUN  LDOLOO
*
LIF	EQU  $
	MOA  RIF	DISCARD CODE FOR 'IF BLOCKS'
	JAF  LROLOU	 STILL OPEN
	REL  RIF
	JUN  LIF
*
LROLOU	EQU  $		OUTPUT STACKS WHICH DO NOT REQUIRE MODIFICATION
	CNT  RX3	 AND ARE NOT NEEDED FOR VARIABLE ALLOCATION
	MON  RCODE
	CTC  RX3
	JML  APUNCH
	NCC  RMODAD
	NCC  RLABEL	  PROGRAM LABELS
	POC  VCMLBL	  MADE LABELS
	JML  APUNCH
	NCC  RFXCON	  INTEGER CONSTANTS
	NCC  RBYCON	  * BYTE CONSTANTS
	NCC  RSPCON	  SINGLE-PRECISION CONSTANTS
	NCC  RDPCON	  DOUBLE-PRECISION CONSTANTS
	NCC  RI4CON	  * INTEGER *4 CONSTANTS
	NCC  RC8CON	  * COMPLEX *8 CONSTANTS
	NCC  RC6CON	  * COMPLEX *16 CONSTANTS
	NCC  RPROGR	  PROGRAMS REFERENCED
	JML  APUNCH
*
*  LCOMMO : ALLOCATE VARIABLES IN BLANK COMMON.  NOTE THAT VARIABLES
*	    ARE NOT SORTED ACCORDING TO TYPE HERE, THEY ARE ALLOCATED
*	    STRICTLY AS THEY COME.  MAKE SURE THAT EVEN SIZE ALLOCATED
*	    VARIABLES ARE FORCED TO EVEN WORD BOUNDRIES, NOT ODD BYTE
*	    BOUNDRIES.
*
LCOMMO	EQU  $
	FLP  RCOMMO	  AREA CODE = 0
	ZER  VDATA2	  FIRST ADDR = 0
	FET  KZERO
*
LCOM1	EQU  $		FOR EACH ITEM:
	LGA  RCOMMO
	JAF  LCOM2	  ALLOCATE AT CURRENT ADDRESS
	JSB  VARSIZ	  COMPUTE TOTAL ITEM SIZE
	ASK  VDATA3	  SAVE ALLOCATION ADDRESS IN VDATA3
	PGO  RALLOC
	ADP  VELEMS	  UPDATE CURRENT ADDRESS
	JUN  LCOM1
*
LCOM2	EQU  $
	ADP  KONE	MAKE SURE FINAL COMMON SIZE IS EVEN BYTES
	ANP  XFFFE
	ASK  VCSIZE	SAVE TOTAL COMMON SIZE
	FLP  RCMNAM
*
LCOM3	EQU  $		ALLOCATE ALL ITEMS EQUIVALENCED
	POW  1		 INTO COMMON
	JSB  LEQUIV
	NCC  RLSPRO	 LOCAL SUB-PROGRAMS
	NOG  RGSPRO	 EXTERNAL SUB-PROGRAMS
	MON  RCODE
	FLP  RGSPRO
*
LGSPRO	EQU  $		OUTPUT SUBPROGRAMS REFERENCED
	LGA  RGSPRO
	JAF  LBASE	IF DUMMY NAME, OUTPUT POINTER TO GLOBAL
	SWA  RGDUMM	 DUMMY STACK WITH TYPE TAG INSERTED
	JAT  $+4
	FET  KZERO
	JSB  TYPESE
	POC  VSYM1
	POC  VSYM2
	POC  VSYM3	OTHERWISE, SIMPLY OUTPUT TAG
	MON  RCODE
	JUN  LGSPRO
*
*  LBASE : ALLOCATE LOCAL DATA AREA REGION
*
LBASE	EQU  $
	NCC  REXTER	EXTERNAL NAMES
	NOG  RGDUMM	NUMBER OF SUBROUTINE/FUNCTION ARGUMENTS
	SCL  1		 (*2 FOR NUMBER OF BYTES)
	ADP  KFOUR	4 BYTES FOR EXECUTION TIME LINKAGE
	W0   POCX	ON CODE STACK
  	FET  VMATMP	GET # OF ADDRESS TEMPS GENERATED
	SCL  1		 *2 SINCE I NEED BYTE ALLOCATION
   	W1   ADPX	ADD TO PREVIOUS OFFSET
   	W0   POCX	AND SAVE
   	FET  VMTMPS	GET # OF NON-ADDRESS TEMPS GENERATED
	SCL  1		 *2 SINCE I NEED BYTE ALLOCATION
   	W1   ADPX	ADD TO PREVIOUS OFFSET
   	ASP  VDSIZE	AND SAVE
   	POW  2		TRIM WORK STACK
   	POC  VDSIZE
	NOG  RSCALE	OUTPUT R.L. OF FIRST NUMERIC TEMP
	MON  RCODE	 AND R.L. OF FIRST LOCAL VARIABLE
	NOG  RARRAY
	MON  RCODE	OUTPUT NUMBER OF SCALARS AND ARRAYS
	JML  APUNCH
*
LCMSOR	EQU  $		SORT PREVIOUSLY ALLOCATED COMMON
	SRD  RALLOC	 VARIABLES BY AREA, AND OUTPUT
	JAF  LISCLR	 THIER ALLOCATION GROUPS:
	RSV  RTEMP
	FET  PALLOC	   BYTES 1-6:   NAME
	FRP  RUNG4	   BYTES 7-8:   CLASS AND TYPE
	W0   FETX	   BYTES 9-10:  AREA CODE AND TYPE
	SNE  KZERO	   BYTES 11-12: RELATIVE LOCATION
	JAF  $+8
	ANP  KADRFL
	ADP  KTWO
	W1   SWTX
	FLP  RALLOC
*
LCMSR1	EQU  $		FOR EACH GROUP:
	LGA  RALLOC
	JAF  LCMSR2	 COMPUTE AREA CODE FROM COMMON POINTER
	SNE  VDATA2	 AND INSERT TAG.
	JAT  $+6
	JSB  LOUTPU
	JUN  LCMSR1
	PGO  RTEMP	MARK RSCALE OR RARRAY ENTRY AS ALREADY
	JUN  LCMSR1	 ALLOCATED
*
LCMSR2	EQU  $
	POW  1		SORT 1 REQUIRES PASS THROUGH ALLOCATION
	CLI  DALLOC	 STACK FOR EACH AREA
	CAR  RTEMP
	JUN  LCMSOR
*
*  THE FOLLOWING ALLOCATES ALL SCALARS IN THE PROGRAM.   THIS IS
*  DONE IN THE FOLLOWING ORDER:
*
*	INTEGER *1, LOGICAL *1
*	ADDRESS IS EVENED
*	INTEGER *2, LOGICAL *2, INTEGER *4
*	REAL *4, REAL *8
*	COMPLEX *8, COMPLEX *16
*
LISCLR	EQU  $		ALLOCATE LOCAL NON-EQUIVALENCED INTEGER
	POC  KZERO	 AND LOGICAL SCALARS
	NCC  RERRSY
	JML  APUNCH
	FET  TDBYTE
	ASP  VDATA4	SET INITIAL TYPE OF INTEGER *1
	FET  KONE
	ASP  VDATA5	SET INITIAL VARIABLE SIZE OF 1 BYTE
LISCL0	EQU  $
	ZER  VTEMP1	SET CELL SAYING I DIDN'T FIND ANY VARIABLES
	NOG  RSCALE	COUNT NUMBER OF GROUPS (VARIABLES) ON SCALAR STACK
*
LISCL1	EQU  $		GET RSCALE ENTRY
	JOW  LISC5A	TRY NEXT VARIABLE TYPE IF NOT RIGHT
	ADP  PSCLR0
	JML  ALDGRP
	SNZ  VSYM1	IGNORE IF ALREADY ALLOCATED
	JAF  LISCL5
	TLY  VTEMP1	SET CELL SAYING I FOUND A VARIABLE
	SWA  RGDUMM
	JAF  LISCL3	IF DUMMY ENTRY, DON'T ALLOCATE, BUT MARK
	JSB  TYPESE	 ENTRY AS ALLOCATED AND OUTPUT ALLOCATION
	ASP  VDATA2	 GROUP WITH RGDUMM POINTER + TAG IN PLACE
	ITA  VDATA2	 OF AREA CODE
	ASK  VDATA1
	FET  VDATA1
	JUN  LISCL4
*
LISCL3	EQU  $		IF EQUIVALENCED ENTRY, IGNORE FOR NOW
	SWA  REQUIV
	JAF  $+6  
	POW  1
	JUN  LISCL5
	JSB  TYPESE	IF NOT INTEGER OR LOGICAL ENTRY,
	STG  VDATA4	SAME TYPE OF TAG AS I AM DOING?
	JAF  LISCL5	BRIF NO, SKIP FOR NOW
	ASK  VDATA1	IT IS AN INTEGER *2 OR LOGICAL *2
	FET  KONE	SET LOCAL VARIABLE ALLOCATION (NOT COMMON)
	ASP  VDATA2	UPDATE LOCAL ENTRY OFFSET
	FET  VDATA5	GET VARIABLE ALLOCATION SIZE (IN BYTES)
	ADP  VDSIZE
	SWT  VDSIZE	 ALLOCATE ENTRY IN LOCAL DATA
	ASK  VDATA3
	CLA  VDATA1	 UPDATE LOCAL DATA SIZE BY ALLOCATION AMOUNT
*
LISCL4	EQU  $		OUTPUT ALLOCATION GROUP
	PGO  RCODE
	FET  KZERO
	ARP  RUNG0	 MARK ENTRY AS ALREADY ALLOCATED
*
LISCL5	EQU  $		REPEAT FOR NEXT ENTRY
	ANP  KADRFL
	JUN  LISCL1
*
LISC5A	EQU  $
	SNZ  VTEMP1	ARE ALL VARIABLES ALREADY ALLOCATED?
	JAF  LLCLEQ	BRIF YES, DON'T EXAMINE ANY MORE
	FET  VDATA4	GET OLD TAG TYPE
	STG  TDBYTE	DID I ALLOCATION INTEGER *1?
	JAF  LISCL7	BRIF NO
*
	POW  1
	JSB  MKEVEN	MAKE VDSIZE EVEN
	FET  TINTEG	NOW DO INTEGER *2
	ASP  VDATA4
	FET  KTWO	ALLOCATION SIZE IS TWO BYTES/VARIABLE
	ASP  VDATA5
	JUN  LISCL0
*
LISCL7	EQU  $
	STG  TINTEG	DID I ALLOCATE INTEGER *2?
	JAF  LISCL8	BRIF NO
	POW  1
	FET  TLOGIC	DO LOGICAL *2 NEXT
	ASP  VDATA4
	JUN  LISCL0
*
LISCL8	EQU  $
	STG  TLOGIC	DID I ALLOCATION LOGICAL *2?
	JAF  LISCL9	BRIF NO
	POW  1
	FET  TDINT4	ALLOCATION INTEGER *4
	ASP  VDATA4
	FET  KFOUR
	ASP  VDATA5	FOUR BYTES PER VARIABLE ALLOCATION
	JUN  LISCL0
*
LISCL9	EQU  $
	STG  TDINT4	DID I ALLOCATE INTEGER *4?
	JAF  LISCLA	BRIF NO
	POW  1
	FET  TSREAL	ALLOCATE REAL *4
	ASP  VDATA4
	JUN  LISCL0
*
LISCLA  EQU  $
	STG  TSREAL	DID I ALLOCATE REAL *4?
	JAF  LISCLB	BRIF NO, MUST HAVE BEEN REAL *8, SO EXIT
	POW  1
	FET  TDREAL
	ASP  VDATA4
	FET  KEIGHT
	ASP  VDATA5	EIGHT BYTES PER VARIABLE
	JUN  LISCL0
*
LISCLB	EQU  $
	STG  TDREAL	DID I ALLOCATE REAL *8?
	JAF  LISCLC	BRIF NO, MUST HAVE BEEN COMPLEX *8
	POW  1
	FET  TC8TYP
	ASP  VDATA4
	FET  KEIGHT
	ASP  VDATA5
	JUN  LISCL0
*
LISCLC	EQU  $
	STG  TC8TYP	DID I ALLOCATE COMPLEX *8?
	JAF  LISCLD	BRIF NO, MUST HAVE BEEN COMPLEX *16
	POW  1
	FET  TC6TYP
	ASP  VDATA4
	FET  KSXTEE
	ASP  VDATA5
	JUN  LISCL0
*
*  END OF LOCAL VARIABLE ALLOCATION
*
LISCLD	EQU  $
	POW  1		POP STACK (WORD CONTAINING LAST TAG USED)
*
*  NOW ALLOCATE THE LOCAL EQUIVALENCE AREA
*
LLCLEQ	EQU  $		ALLOCATE LOCAL EQUIVALENCE AREA
	JML  APUNCH
	JSB  MKEVEN	MAKE SURE STARTING ADDRESS IS EVEN
*
	FLP  REQUIV	LOCATE FIRST REMAINING EQUIV SET
	SRD  REQUIV     (MAY BE PRECEDED BY MARKERS FROM
	JAF  LARRAY	 EQUIVALENCED COMMON).
	LGA  REQUIV
	JAF  $-6
	FET  KLOCAL
	ASK  VDATA2
	ZER  VMINEQ	INITIALLY ALLOCATE SET AROUND ZERO
	ZER  VMAXEQ
*
LLCLE1	EQU  $		ALLOCATE EACH NAME IN THE SET RELATIVE
	CLA  KZERO	 TO THE OTHERS AS SPECIFIED, AND GENERATE
	SUP  VDATA1	 ALLOCATION GROUPS ON RALLOC
	JSB  EQVALL
	LGA  REQUIV
	JAT  LLCLE1
*
	SRD  REQUIV	IF ADDITIONAL ALLOCATION SETS REMAIN, CALL
	JAF  LLCLE2	 LEQUIV TO PROCESS ANY SETS WHICH EQUIVALENCE
	CLA  KMARKE	 THE CURRENT SET.
	ASK  VDATA1
	PGO  REQUIV
	FLP  REQUIV
	JSB  LEQUIV
*
LLCLE2	EQU  $		COMPUTE THE TOTAL SIZE OF EQUIVALENCE SET
	CLA  KLOCAL	 AND PROPER CENTER POINT AROUND WHICH SET
	FET  VDSIZE	 SHOULD BE ALLOCATE. & UPDATE VDSIZE.
	SUP  VMINEQ
	ASK  VDSIZE	TOTAL-SIZE = VMAXEQ - VMINEQ
	ADP  VMAXEQ	CNTR-POINT = VDSIZE(OLD)-VMINEQ
	SWT  VDSIZE
	FLP  RALLOC
*
LLCLE3	EQU  $		RE-ORG EACH NAME TO PROPER LOCATION
	LGA  RALLOC	 (=LOCN+CNTRPO)
	JAT  $+6  
	POW  2
	JUN  LLCLEQ	OUTPUT ALLOCATION GROUP FOR EACH
*
	SWT  VDATA3	MARK RSCALE OR RARRAY ENTRIES AS ALREADY
	ADP  VDATA3	 ALLOCATED
	SWT  VDATA3
	JSB  LOUTPU	REPEAT FOR NEXT INDEPENDENT EQUIVALENCE
	JUN  LLCLE3	 SET
*
*  LARRAY : ALLOCATE REMAINING ARRAYS (LOCAL DATA, NON-COMMON)
*
LARRAY	EQU  $		ALLOCATE REMAINING ARRAYS
	FLP  RARRAY
	FET  PARRAY	 IGNORE IF ALREADY ALLOCATED
*
LARRA1	EQU  $
	LGA  RARRAY	IF DUMMY ENTRY, DON'T ALLOCATE, BUT OUTPUT
	JAF  LENDLV	 ALLOCATION GROUP WITH RGDUMM POINTER AND
	SNZ  VSYM1	 TAG IN PLACE OF AREA CODE.
	JAF  LARRA3
	JSB  TYPESE
	SWA  RGDUMM
	JAT  LARRA2
	JSB  CALCSI	CALCULATE SIZE OF ARRAY ELEMENT
	FET  VELEMS	FETCH IT
	ANP  KONE	MASK OFF ODD/EVEN BIT
	JOW  LARR1A	IF EVEN, MUST MAKE SURE ALLOCATION POINTER
	POW  1		 IS ALSO EVEN.  IF ODD, DOESN'T MATTER.
	JUN  LARR1B
LARR1A	EQU  $
	JSB  MKEVEN
LARR1B	EQU  $
	FET  VDATA1
	FRP  RUNG0
	ASK  VINDIR
	CLA  VDATA1	OTHERWISE, ALLOCATE AT CURRENT LOCATION IN
	IND  FRPX	 LOCAL DATA, UPDATE VDSIZE BY TOTAL ARRAY
	ADP  VDSIZE	 SIZE (MULTIPLIER N+1) AND OUTPUT ALLOCATION
	SWT  VDSIZE	 GROUP.
	ASK  VDATA3
	CLA  KLOCAL
*
LARRA2	EQU  $		DISCARD RARRAY ENTRY
	W1   ITAX
	ASP  VDATA2
	ASK  VDATA1
	PGO  RCODE	REPEAT FOR NEXT ARRAY
*
LARRA3	EQU  $
	ADP  KONE
	JUN  LARRA1
*
*  LENDLV : TERMINATE VARIABLE ALLOCATION
*
LENDLV	EQU  $
	POC  KZERO
	NCC  RERRSY	OUTPUT END-VARIABLES MARKER AND LOCAL-
	JML  APUNCH	 ALLOCATION ERROR LIST
	CNT  RHOLVA
	MON  RCODE
	FLP  RHOLVA
*
LHOLVA	EQU  $
	MOA  RHOLVA	ALLOCATE HOLLERITH VARIABLES AT SUCCESSIVE
	JAF  LSTATS	 LOCATIONS IN THE LOCAL DATA REGION
	SCL  1		 * 2 FOR BYTE COUNT (INSTEAD OF WORD COUNT)
	SWT  VDSIZE
	W0   POCX
	ADP  VDSIZE	OUTPUT START LOCATION FOR EACH
	ASP  VDSIZE
	JUN  LHOLVA	UPDATE VDSIZE
*
LSTATS	EQU  $
	POC  VCSIZE	OUTPUT MISCELLANEOUS STATISTICS
	JSB  MKEVEN	 MAKE SURE LOCAL DATA SIZE IS EVEN
	POC  VDSIZE	 LOCAL DATA SIZE
	POC  VPROGN	 PROGRAM NAME
	POC  VPROGN+2
	POC  VPROGN+4
	POC  FEND	 END-CARD-IMAGE-SEEN FLAG
	POC  F1STPG	 1ST PROGRAM OF COMPILATION
	POC  FIO	 I DO I/O
	POC  FSPROG	 PROGRAM/SUBPROGRAM
	POC  FNW	 NW-OPTION
	POC  FMAP	 MS/ML OPTION
	POC  FIEEE	 IEEE OPTION
	POC  FOBJLS	 OB - OPTION FLAG
	POC  FBATCH	 MAP CONTROL FLAG
	POC  KZERO	 PAD WORD
	JML  AP2INI	INITIATE PASS 2!  I'M DONE!
*
LEQUIV	EQU  $
	SRD  REQUIV	
	JAF  EXIT
	FET  PALLOC
*
*   ALLOCATE EQUIVALENCED ITEMS
*
LEQUI1	EQU  $		ALLOCATE ALL ITEMS EQUIVALENCED TO
	JML  ALDGRP	 VARIABLES ON RALLOC
	JAF  CLR1EX	 (EXIT IF REQUIV IS EMPTY)
	SWA  REQUIV
	JAT  LEQUI2
	ADP  KONE
	JUN  LEQUI1
*
LEQUI2	EQU  $		FOR EACH VARIABLE ON RALLOC, SEARCH
	FET  VDATA2	 REQUIV. WHEN RALLOC IS EXHAUSTED, EXIT.
	SNE  KONE
	JAF  LEQUI3
	SNE  KZERO
	JAF  $+6  
	FRP  RUNG4
	JUN  $+4  
	CLA  VCSIZE
	ASK  VMAXEQ
	ZER  VMINEQ
*
LEQUI3	EQU  $		FOR EACH EQUIVALENCED RALLOC VARIABLE,
	W1   CLAX	 DETERMINE AREA AND LOCATION OF EQUIVALENCED
	FET  KZERO	 ELEMENT
	ARP  RUNG0
	W0   FETX
	FRP  RUNG3	IF VARIABLE ALLOCATED IN COMMON, INITIALIZE
	ADP  VDATA3	 VMINEQ AND VMAXEQ TO BOUNDARIES OF AREA
	W1   SWTX
*
LEQUI4	EQU  $
	SUP  KONE
	W0   FETX
	FRP  RUNG0
	SNE  KMARKE
	POW  1
	JAT  LEQUI4
*
LEQUI5	EQU  $
	ADP  KONE
	JML  ALDGRP
	FET  VSYM1
	JAF  LEQUI7
	SNE  KZERO
	JAF  LEQUI6
	SNE  KMARKE
	JAF  LEQUI7
	W2   CLAX
	SUP  VDATA1
	SWA  RALLOC
	JAT  $+6  
	JSB  EQVALL
	JUN  LEQUI6
	W0   FETX
	FRP  RUNG4
	SNE  VDATA2
	POW  1
	JAF  $+6  
	CLI  QEQARE
        JUN  $+10
	FRP  RUNG5
	W1   SNEX
        JAF  $+8
	CLI  QEQDIS
	ASK  VDATA1
	PGO  RERRSY
	POW  1
*
LEQUI6	EQU  $
	W1   CLAX
	FET  KMARKE
	ARP  RUNG0
	JUN  LEQUI5
*
LEQUI7	EQU  $
	POW  3
	JUN  LEQUI1
*
EQVALL	EQU  $
	ASK  VDATA3
	SLE  VMINEQ
	JAF  EQVAL1
	SNE  VMINEQ
	JAF  EQVAL1
	CLA  VDATA2
	SNE  KLOCAL
	JAF  $+6  
	CLI  QEQBAC
	JUN  EQVAL3
*
	CLA  VDATA3
	ASK  VMINEQ
*
EQVAL1	EQU  $
	JSB  VARSIZ
	ADP  VELEMS
	SLE  VMAXEQ
	JAT  EQVAL2
	SWT  VDATA2
	SOP  RCMARE
	SWT  VDATA2
	JAF  $+6  
	CLI  QCMFUL
	JUN  EQVAL3
*
	ASK  VMAXEQ
	SNZ  VDATA2
	JAT  EQVAL2
	ASK  VCSIZE
*
EQVAL2	EQU  $
	PGO  RALLOC
	JUN  EXIT
*
EQVAL3	EQU  $
	ASK  VDATA1
	PGO  RERRSY
	JUN  EXIT
*
LOUTPU	EQU  $
	W1   FETX
	ITA  VDATA1
	ASK  VDATA2
	PGO  RCODE
	CLA  VDATA1
	ANP  KOPFLD
	JOW  EXIT
	CLA  VDATA1
	FET  KZERO
	ARP  RUNG0
	JUN  EXIT
*
*  VARSIZ :  RETURN TOTAL VARIABLE SIZE IN VELEMS, AND MAKE SURE
*	     ALLOCATION POINTER ON W0 IS EVEN'D IF THIS VARIABLE
*	     IS AN EVEN NUMBER OF BYTES (E.G. INTEGER *2)
*
VARSIZ	EQU  $
	SWA  RSCALE	SCALAR?
	JAT  VARSI2	 BRIF YES
	SWA  RARRAY	ARRAY?
	JAF  VARSI1	 BRIF NO
	ASK  VDATA1
	FRP  RUNG3
	W0   FETX
	FRP  RUNG0
	ASP  VINDIR
	IND  FRPX	HAS ALLOCATION SIZE TOTAL
	ASK  VELEMS
	ANP  KONE	ODD OR EVEN?
	JOW  VARS0A	IF EVEN, MUST MAKE SURE ALLOCATION POINTER
	POW  1		 IS ALSO EVEN.  IF ODD, DOESN'T MATTER.
	JUN  VARS0B
VARS0A	EQU  $
	ADP  KONE	BUMP BY ONE
	ANP  XFFFE	MAKE SURE IT IS EVEN
VARS0B	EQU  $
	FET  VELEMS	RE-FETCH ELEMENT SIZE
	CLA  VDATA1
	JSB  TYPESE
	ASP  VDATA1
	JUN  EXIT
*
VARSI1	EQU  $
	FET  KZERO
*
VARSI2	EQU  $
	JSB  TYPESE	SET TYPE OF VARIABLE
	ASK  VDATA1
	JSB  CALCSI
	POW  1		POP OFF ELEMENT TYPE
	FET  VELEMS
	ANP  KONE	ODD OR EVEN ELEMENT SIZE?
	JOW  VARS2A	IF EVEN, MAKE SURE ALLOCATION POINTER IS
	POW  1		 ALSO EVEN.  IF ODD, DOESN'T MATTER
	JUN  VARS2B
VARS2A	EQU  $
	ADP  KONE	BUMP BY ONE
	ANP  XFFFE	MARE SURE IT IS EVEN
VARS2B	EQU  $
	JUN  EXIT
*
*  MKEVEN : MAKE ALLOCATION SIZE IN VDSIZE EVEN
*
MKEVEN	EQU  $
	FET  VDSIZE	GET ALLOCATION SIZE
	ADP  KONE	BUMP BY ONE
	ANP  XFFFE	MAKE SURE IT IS EVEN
	ASP  VDSIZE	 AND SAVE NEW SIZE
	JUN  EXIT
*
ZBSOVF	EQU  $
ALLOCA	EQU  $
	JML  AOVERF
FORT2E  EQU  $
        END
