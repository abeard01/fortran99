	TITL 'FORTRAN COMPILER, PART 1'
	IDT  'FORT1'
	DEF  FORT1
*
*  This first FORTRAN phase provides the following functions:
*
*    1.  Initialization
*    2.  Obtaining User Options
*    3.  Executing intermediate interpreter
*    4.  Producing an intermediate object file
*    5.  Producing an intermediate source code file
*    6.  Call the FORTRAN3 package to do code generation
*
*  Change History:
*
*  V3.0   06-July-1987   Many changes for version 3.0, including:
*			  o Changeover to tabbed cross-assembler version
*			  o Addition of Intrinsic Functions
*			  o Use new color preferences in MENU
*			  o Constant TRACE breakpoint added
*			  o Expanded Intrinsic Function Table based on
*			    routines supplied by Elmer Clausen.
*         10-August-1987  o Changed intrinsic table to encompass min/max
*			    routines, which can have 1 to 10 arguments.
*	  16-August-1987  o Added new interpretive debugger.  Added
*			    a new interpretive variable (VARGSA).
*
*
*  V3.1   30-August-1987  o Added OCTAL and BINARY conversion routines.
*			    Corrected overflow messages on INTEGER and
*			    Floating Point Conversions.  Added new quotes
*			    to support same.  Mangled the GENFLC routine
*			    to streamline it, and do integer conversions
*			    via the INTSCA routine (don't call the CFI
*			    routine which is slow).
*
*			    Enable interrupts while processing pass 3,
*			    and during options interrogation.
*
*         19-October-1987   Replace call to XMLLNK with own routine
*
*  V3.1.1 08-November-1987  Corrected "DFLOAT", last digit of M39 
*			    string wasn't found.
*
*  V4.0   04-December-1987  Start of MDOS compatible version
*
*			    MDOS calling sequence:
*
*			    FORTRAN /option<string> /option<string> input_file
*
*  V4.4   29-SEP-89         Add Stack checking as part of mini-debugger
*
*  v4.41  04-JAN-90         Changed copyright year.
*         07-JAN-90         Load Workspace & Enable Interrupts in GPL
*
	COPY "FORTPAR:"
*
	UNL
	IF   GENEVE
	COPY "EQUATES:MATH.EQ9"
	COPY "EQUATES:MEM.EQ9"
	ENDIF
*
	COPY "EQUATES:FORTIO.EQ9"
	COPY "EQUATES:FORTEX.EQ9"
	LIST
*
	DEF  SC1PAB		SCRATCH FILE 1 PAB
	DEF  SC2PAB		SCRATCH FILE 2 PAB
	DEF  FOPT		OPTIONS FLAGS
	DEF  IOABOR		I/O ABORT ROUTINE
	DEF  P1RETN		PASS 1 RETURN
	DEF  ILIST		LIST OR NOT
*
* REFERENCES (FROM MENU)
*
	IF   GENEVE
	REF  CTSCR$		TERSE SCREEN OUTPUT
	REF  CSCRO$		SCREEN OUTPUT (NON-TERSE)
	REF  CSCRI$		SCREEN INPUT
	REF  CIO$		INPUT/OUTPUT FILE SYSTEM
	REF  COPFI$		OPEN A FILE SYSTEM
	REF  CMENU$		MENU RETURN 
	REF  CMDST$		COMMAND STRING PARSE ROUTINE
	REF  INIT$		INITIALIZE I/O SUBSYSTEM 
	ENDIF
*
*  REFERENCES FROM FORTRAN 3
*
	REF  FORT3		FORTRAN3 entrance
	REF  ENDL3		FORTRAN3 data area end
*
*  REFERENCES FROM FORTRAN 4
*
	REF  FOPFIL		PRIVATE FORTRAN OPEN FILE ROUTINE
	REF  FIOC		PRIVATE FORTRAN I/O ROUTINE
*
*  References from debug (temporary)
*
	IF   GENEVE
	REF  VERSNO		VERSION NUMBER (FROM FORTRAN 7)
	REF  DEBUG$		DEBUGGER ENTRY POINT
	REF  FORT2		FORTRAN 2 START ADDRESS (MDOS VERSION)
	ELSE
*
*  Cursor Movement Macro
*
CURSOR  MACRO
	BYTE >1B,>3D,%1+>20,%2+>20
	ENDM
*
	ENDIF
*
*  entry into FORTRAN1.  Rorg'd start at 0.
*
	RORG 0
FORT1	EQU  $
	LWPI WSP		; LOAD MY WORKSPACE
	LIMI 2			; ENABLE INTERRUPTS
	IF   GENEVE
	LI   R5,DEBUG$		; IS DEBUGGER HERE?
	JEQ  BENTRY		BRIF NO
	BL   *R5		ELSE, GO TO IT
	ENDIF
BENTRY	EQU  $
	B    @ENTRY		ENTER ROUTINE
*
*  The following flag can be patched to one of the following
*  to execute the intermediate interpreter debugger:
*
*		 0   = NO DEBUG
*		<>0  = DEBUG
*
DEBENA  DATA 0			PSEUDO DEBUGGER ENABLED (1) OR NOT(0)
*
*  SYSGEN EQUATES:
*
	IF   GENEVE
MMOVES	EQU  128		# WORDS TO ALLOCATE PER ALLOCATION
SA1LEN	EQU  >1800		SCRATCH AREA 1 LENGTH (BYTES)
MAPEND	EQU  >EFFE		END OF MEMORY MAP
SIOBUF	EQU  >F400		START OF SCREEN I/O BUFFER IN RAM
NOIOTA	EQU  8			# FILES I CAN HAVE OPEN AT ONE TIME
SCRBUF	EQU  >100		SCREEN I/O BUFFER SIZE (BYTES)
IOTBUF	EQU  >200		I/O BUFFER SIZE (BYTES)
	ELSE
MMOVES	EQU  40			# WORDS TO ALLOCATE PER ALLOCATION
SUPERS	EQU  >6000		; SUPER SPACE CARTRIDGE START
MINIST	EQU  >7000		; MINI-MEMORY START
MINIEN	EQU  >7FFE		; MINI-MEMORY END
MAPSTA	EQU  >3000		; MAP AREA 1 START
SA1LEN	EQU  >0FFE		; SCRATCH AREA #1 LENGTH
MAPEND	EQU  >FFD4		; MAPPABLE MEMORY END
DBUGEN  EQU  >F6F0		; MAPPABLE MEMORY END W/DEBUGGER
	ENDIF
INFILE	EQU  1			DEVICE NUMBER FOR INPUT FILE
OBFILE  EQU  2			DEVICE NUMBER FOR OBJECT FILE
LIFILE	EQU  3			DEVICE NUMBER FOR LISTING FILE
S1FILE	EQU  4			DEVICE NUMBER FOR SCRATCH FILE 1
S2FILE	EQU  5			DEVICE NUMBER FOR SCRATCH FILE 2
CRFILE	EQU  6			DEVICE NUMBER FOR CRT
ICFILE	EQU  7			DEVICE NUMBER FOR INCLUDE FILE
*
S2BYTE	EQU  80			# BYTES IN SCRATCH FILE 2
*
OVFERR	EQU  8			OVERFLOW ERROR # (INTERNAL)
INTERR  EQU  9			INTERNAL ERROR
NOTTDO	EQU  10			NOTHING TO DO!  NO INPUT FILE SPECIFIED
BADOPT	EQU  11			BAD COMMAND LINE OPTION SPECIFIED
TOOLEN	EQU  12			OPTION TOO LONG
CRSERR	EQU  13			CANNOT RETRIEVE COMMAND STRING ERROR
OSTERR	EQU  14			COMMAND OPTION SPECIFIED TWICE
MEMERR	EQU  15			ERROR GETTING MEMORY (XOP-GENEVE)
*
MINIFL	EQU  >1234		MINI-MEMORY HERE FLAG
*
*  REGISTER USAGE EQUATES
*
RVP	EQU  7			WORK POINTER
RBW	EQU  8			RBWORK POINTER
RET	EQU  9			INTERPRETER RETURN POINTER
*
PASS1	EQU  1
	COPY "FORTRAN5.A99"
*
*  EQUATES TO MEMORY MANAGER
*
	IF   GENEVE
DMATXP	DATA MATXOP		* MATH XOP NUMBER
DMEMXP	DATA MEMXOP		* MEMORY MANAGER XOP
MAPADR	DATA 0,0,0,0		* MY 64K MEMORY MAP
FAC	DATA 0,0,0,0		* FAKE FAC
	ENDIF
*
*  INITIAL VALUES OF FIRST FOUR STACKS:
*
RTF	DATA EXPNAM		REXPNA (EXPONENTIAL NAMES)
	DATA INTRIN		RINTRI (INTRINSIC NAMES)
	DATA INTRI1		RINTR1 (INTRINSIC OVERFLOW TABLE)
	DATA OPTION		ROPTIO (OPTIONS)
*
RBF	DATA 0			REXPNA (EXPONENTIAL NAMES)
	DATA INTRNE		RINTRI (INSTRISIC NAMES)
	DATA INTRE1		RINTRE (END POINTER)
	DATA OPTSEN		ROPTIO (OPTIONS)
*
*  CONSTANTS:
*
KNF 	DATA >FFF0		A CONSTANT
KSIGN 	DATA >8000		A CONSTANT
K10	DATA 10			A CONSTANT
K14	DATA 14			A CONSTANT
K39	DATA 39			A CONSTANT
K6	DATA 6			A CONSTANT
*
*  ASCII CHARACTERS USED IN PARSING:
*
KQTEND	BYTE 0
ASCAST	TEXT '*'
*
ASCFIV	TEXT '5'		ASCII FIVE
EXCLA	TEXT '!'		EXCLAMATION
ASCEQU  TEXT '='		EQUALS SIGN
ASCSMA  TEXT 'a'		SMALL 'A'
ASCSMZ	TEXT 'z'		SMALL 'Z'
ASCONE	TEXT '1'		ASCII ONE
COMMST	EQU  $			COMPARES FOR COMMENT LINE
	TEXT 'Cc*Dd'
CTABLE	EQU  $			CONVERSION TABLE FOR MOD39 SUBR
	TEXT '_$ '
CTABL1  EQU  $
ASC0    EQU  $
	TEXT '09AZ'
CDIGIT  EQU  $			TABLE FOR HEX/OCTAL CONVERT
	TEXT '0:AF'
ODIGIT  EQU  $
	TEXT '07'		OCTAL DIGIT CONVERSION
IDIGIT  EQU  $
	TEXT '09'
KDEC    EQU  $
	TEXT '.'
KLETD   EQU  $
	TEXT 'D'
KLETE	EQU  $
	TEXT 'E'
ADIGIT  EQU  $
	TEXT 'AZDE'
EMINUS  EQU  $
	TEXT '-+'
ESLASH	EQU  $
	TEXT '/'
*
*  COMMAND LIST FOR DEBUGGER
*
MYCOMM	EQU  $
	TEXT 'BIDTQ'
	BYTE 0
	EVEN
EHIBLN	EQU  $
ASCBL	EQU  $
BLANK 	DATA >2000		HIGH BLANK
LOBLAN	DATA >0020		LOW BLANK
ECARRN	DATA >000D		ASCII CARRIAGE RETURN
*
*  MINIMUM - MAXIMUM LETTER AREAS
*
KMINLT	EQU  $
SCKMIN	BYTE 0			LETTER
	TEXT 'A'
	BYTE 0			DIGIT
LETTE0	TEXT '0'
	BYTE 0			HEX LETTER
	TEXT 'A'
KMAXLT	EQU  $
SCKMAX	BYTE 0			LETTER
	TEXT '['
	BYTE 0			DIGIT
	TEXT ':'
	BYTE 0			HEX LETTER
	TEXT 'G'
*
	EVEN
KMOVES	DATA MMOVES		40 BYTES PER ALLOCATION
*
*  The following table is used by the options parser (GENEVE only).
*  It specifies the command letter (-option) needed, and the resulting
*  string address for the option.
*
	UNL
	IF   GENEVE
	LIST
PARADR  EQU  $
	DATA '> ',CRTFIL	diagnostic output
	DATA 0,INPFIL
	DATA 'L ',LISFIL	listing file (-l)
	DATA 'l ',LISFIL
	DATA 'O ',OBJFIL	object file (-o)
	DATA 'o ',OBJFIL
	DATA 'P ',OPTFIL	options file (-p)
	DATA 'p ',OPTFIL
	DATA -1
	ENDIF
	LIST
*
INCLOP	DATA 7			INCLUDE FILE READ NUMBER
*
*  TEXT MESSAGES (FOR SCREEN)
*
HELL1	EQU  $
	UNL
	IFEQ  GENEVE
	LIST
	BYTE >0C
	CURSOR 1,7
	TEXT '99 FORTRAN Compiler'
        CURSOR 2,11
        TEXT 'Version 4.41'
	ELSE
	LIST
	TEXT '9640 FORTRAN Compiler'
	TEXT ' / Copyright 1990 by LGMA Products'
	BYTE >0D
	ENDIF
	BYTE >FF
*
	UNL
	IFEQ  GENEVE
	LIST
HELL2	EQU  $
	CURSOR 4,1
	TEXT 'Input File Name?'
	CURSOR 5,1
	BYTE >FF
*
REQOBJ	EQU  $
	CURSOR 7,1
	TEXT 'Object File Name?'
	CURSOR 8,1
	BYTE >FF
*
REQLIS	EQU  $
	CURSOR 10,1
	TEXT 'Listing File Name?'
	CURSOR 11,1
	BYTE >FF
*
REQSCR	EQU  $
	CURSOR 13,1
	TEXT 'Scratch Disk Number (1-5)?'
	CURSOR 14,1
	TEXT '1'
	CURSOR 14,1
	BYTE >FF
*
REQOPT	EQU  $
	CURSOR 16,1
	TEXT 'Compilation Options?'
	CURSOR 17,1
	BYTE >FF
	ENDIF
	LIST
*
COMPIN	EQU  $
	BYTE >0D
	TEXT 'Compilation in Progress'
	BYTE >0D,>FF
*
COMPCO	BYTE >0D
	TEXT 'Compilation Complete'
	BYTE >0D,>FF
*
*  ABORT TYPE ERROR MESSAGES (ON SCREEN):
*
	EVEN
ERRMSG	DATA ERR00,ERR01,ERR02,ERR03
	DATA ERR04,ERR05,ERR06,ERR07
	DATA ERR08,ERR09
*
*  ADDITIONAL ERROR MESSAGES (GENEVE ONLY)
*
	UNL
	IF   GENEVE
	LIST
	DATA ERR10,ERR11,ERR12,ERR13
	DATA ERR14,ERR15
	ENDIF
	LIST
*
ERR00	TEXT 'I/O Error/Bad Device Name'
	BYTE >0D,>FF
ERR01	TEXT 'I/O Error/Write Protected'
	BYTE >0D,>FF
ERR02	TEXT 'I/O Error/Bad Open Attribute'
	BYTE >0D,>FF
ERR03	TEXT 'I/O Error/Illegal Operation'
	BYTE >0D,>FF
ERR04	TEXT 'I/O Error/No Buffer Space'
	BYTE >0D,>FF
ERR05	TEXT 'I/O Error/Read Past End of File'
	BYTE >0D,>FF
ERR06	TEXT 'I/O Error/Device Error'
	BYTE >0D,>FF
ERR07	TEXT 'I/O Error/File Error'
	BYTE >0D,>FF
ERR08	TEXT 'OVF Error/Internal Overflow'
	BYTE >0D,>FF
ERR09	TEXT 'INT Error/Compiler Fault'
	BYTE >0D,>FF
	UNL
	IF   GENEVE
	LIST
ERR10	TEXT 'NOP Error/Nothing to DO!'
	BYTE >0D,>FF
ERR11	TEXT 'BCM Error/Bad Command Line Option Specified (/O, /L, /P)'
	BYTE >0D,>FF
ERR12	TEXT 'OTL Error/Option too long'
	BYTE >0D,>FF
ERR13	TEXT 'CRS Error/Cannot Retrieve Command String'
	BYTE >0D,>FF
ERR14	TEXT 'OST Error/Command Line Option Specified Twice'
	BYTE >0D,>FF
ERR15	TEXT 'MEM Error/Cannot Get Memory, Error= ',
ERR15D	TEXT ' '
	BYTE >0D,>FF
ERRUS	TEXT 'Usage:  F9640 [/Llist_file] [/Poptions] [/Oobject_file] '
	TEXT 'filename'
	BYTE >0D,>FF
	ENDIF
	LIST
EXTERR	BYTE >0D
	TEXT 'File: '
	BYTE >FF
*
*  DEBUGGER TYPE MESSAGES
*
MINDEB	EQU  $
	BYTE 14
	TEXT ' Mini-Debugger'
*
STAERR	EQU  $
	BYTE  12
	TEXT ' Stack Error'
*
WHAT    EQU  $
	BYTE 23
	TEXT ' Commands are B,I,D,T,Q'
*
STLOCR	EQU  $			just a carriage return/line feed
	BYTE 1
	TEXT ' '
*
*  DEBUG ONLY, DISPLAY OF EXECUTING LOCATION
*
STLONW	EQU  $
	BYTE 6
	TEXT '+ '
STLONN	BYTE 0,0,0,0
	EVEN
*
* PERIPHERAL ACCESS BLOCKS
*
*		 FILE #4 - SCRATCH FILE 1
*
SC1PAB	BYTE 0,>12		VARIABLE,DISPLAY,OUTPUT,SEQUENTIAL
	DATA 0
	BYTE 80,0,0,0,0,13
	TEXT 'DSK'
DISKN1	EQU  $
	TEXT '1'
	TEXT '.SC$1FIL$'
	EVEN
*
* 		FILE #5 - SCRATCH FILE 2
*
SC2PAB	BYTE 0,>03		FIXED,DISPLAY,OUTPUT,RELATIVE
	DATA 0
	BYTE S2BYTE,0,0,0,0,13
	TEXT 'DSK'
DISKN2	EQU  $
	TEXT '1'
	TEXT '.SC$2FIL$'
	EVEN
*
* PAB SETUPS, ORDER CODE & BYTE SIZE
*
INPSET	EQU  $			INPUT FILE 1
	DATA >0014,80
OBJSET	EQU  $
	DATA >0002,80		OBJECT FILE 2
LISSET	EQU  $
	DATA >0012,120		LISTING FILE 3
CRTSET  EQU  $
	DATA >0012,80		CRT (DIAGNOSTIC OUTPUT)
CRTSTR	EQU  $			Name of the CRT device
	BYTE >02
	TEXT 'CR'
	EVEN
*
* USER I/O COMMAND STACKS
*
SIREAD	DATA REAOPC		READ ASCII
SIOPLB	DATA INFILE		INPUT FILE
PSIBUF	DATA 0			TO INPUT STACK
K80	EQU  $
	DATA 80			80 BYTES
	DATA 0
*
LIWRIT	DATA WRAOPC		WRITE BINARY
	DATA LIFILE		LISTING FILE
LIADRE	DATA 0			FROM ADDRESS
LIBYTE	DATA 0			BYTE LENGTH
*
S1WRIT	DATA WRAOPC		WRITE ASCII
	DATA S1FILE		SCRATCH FILE 1
PS1BUF	DATA 0			FROM INPUT STACK
	DATA 80
	DATA 0
*
S2PUNC	DATA WRBOPC+>0800	WRITE RANDOM BINARY
	DATA S2FILE		SCRATCH FILE 2
PS2BUF	DATA 0			FROM BUFFER STACK
VS2BYT	DATA 0			ONE RECORD
PS2	DATA 0			RECORD #
*
S1READ	DATA REAOPC		READ ASCII SCRATCH FILE 1
	DATA S1FILE
	DATA 0
	DATA 80
*
* SPECIAL COMMAND STACK TO CLOSE FILES FOR ABORT ROUTINE
*
ALCLOS	DATA CLOOPC		CLOSE A FILE
ALNUMB	DATA 0			FILE #
*
ALDELE	DATA DELOPC		DELETE A FILE
DENUMB	DATA 0
*
* LENGTH CODES FOR DIFFERENT TYPES OF NUMBER CONVERSIONS
*
HEXMAP	EQU  $
	DATA 3,5,9
BITMAP	EQU  $
	DATA 9,17,33
OCTMAP	EQU  $
	DATA 3,6,11
	TITL 'FORTRAN COMPILER INITIAL ENTRY'
	PAGE
*
*  This module starts the FORTRAN compiler.  It performs:
*
*     1.  Initial Entry
*     2.  Screen Setup (to 40 column mode)
*     3.  Solicits inputs for:
*	    o Input File Name
*	    o Object File Name
*	    o Listing File Name
*	    o Scratch Disk Number
*	    o Compilation Options
*     4.  Compiler Initialization
*
ENTRY	EQU  $
	UNL
	IF   GENEVE
	LIST
EINIT	EQU  $			; INITIALIZE ROUTINE
	LI   R1,1		; GET ONE PAGE
	LI   R2,7		; STARTING AT PAGE 7
	BL   @LGETME		; GET THE MEMORY
	JNE  BMDOS		; CAN'T GET IT, JUST ABORT
*
	BLWP @INIT$		; MY FORTRAN UTILITIES INIT
	DATA SIOBUF		; START I/O BUFFER
	DATA SCRBUF		; SCREEN BUFFER SIZE
	DATA IOTBUF		; I/O BUFFER SIZE
	DATA NOIOTA		; NUMBER OF I/O TABLES
*
	LI   R1,4		; # OF PAGES TO GET
	LI   R2,4		; LOCAL PAGE ADDRESS TO GET
	BL   @LGETME		; GET THE MEMORY
	JNE  DERR15		; BRIF ERROR GETTING MEMORY
*
	LI   R1,CMDADR		GET COMMAND STRING ADDRESS
	LI   R2,120		120 BYTES TO GET
	SLA  R2,8
	MOVB R2,*R1+		MOVE TO STRING
	BLWP @CMDST$
	JEQ  ENTR1		BRIF GOT IT
*
*  ERROR GETTING COMMAND LINE, ANNUNCIATE IT
*
	LI   R0,CRSERR		ELSE, COMMAND RETRIEVAL ERROR
	B    @ABORTE		ABORT
*
*  ERROR GETTING MEMORY TO RUN
*
DERR15	EQU  $			ERROR GETTING MEMORY
	ANDI R0,>F		MASK ERROR NUMBER
	AI   R0,>0030
	SWPB R0
	MOVB R0,@ERR15D		; SPECIFY ERROR
	LI   R0,MEMERR		; ERROR GETTING MEMORY
	B    @ABORTE
BMDOS	EQU  $
	LIMI 2
	BLWP @0			; RETURN TO MDOS, CAN'T DO IT
	JMP  BMDOS
*
*  LGETME - LOCAL GET MEMORY.  THE FOLLOWING ROUTINE CALLS THE
*	    MDOS MEMORY MANAGER TO GET THE NUMBER OF PAGES AND
*	    STARTING AT PAGE NUMBER SPECIFIED IN R1, AND THE
*	    NUMBER OF PAGES SPECIFIED IN R2.
*
LGETME	EQU  $
	LI   R0,GETLCP		; GET LOCAL PAGE OPCODE
	CLR  R3			; GET SLOW RAM
	XOP  @DMEMXP,0		; GET THE MEMORY
	MOV  R0,R0		; ANY ERROR?
	JNE  LGETMR		; BRIF YES
	LI   R0,GETMAP		; GET THE MEMORY MAP
	LI   R1,MAPADR		; MAP ADDRESS
	LI   R2,8		; SIZE OF AREA FOR MAP
	XOP  @DMEMXP,0		; GET THE MAP
	MOV  R0,R0
	JNE  LGETMR		; BRIF ERROR GETTING MAP
	LI   R1,MAPADR+1	; MOVE MAP TO MAPPER REGISTERS
	LI   R2,MMRREG+1
	MOVB *R1+,*R2+		; PAGE 2
	MOV  *R1+,*R2+		; PAGE 3,4
	MOV  *R1+,*R2+		; PAGE 5,6
	MOV  *R1+,*R2+		; PAGE 7,8
	CLR  R0
LGETMR	EQU  $
	MOV  R0,R0
	B    *R11
*
ENTR1	EQU  $
	ELSE
	LIST
	LI   R0,>3500		; OPEN 5 FILES MAXIMUM
	BLWP @CFILE$
	ENDIF
*
*  The following code makes the decisions where the scratch areas
*  reside.  There are three different scenerios:
*
*   1. GENEVE : in this case, scratch area #1 starts at the end
*		of FORTRAN5.  The second scratch area is contiguous
*		and resides >1800 bytes after the first.
*
*   2. TI-99/MINI: in this case, scratch area #1 starts at location
*		>3000, and runs for >FFE bytes.  Scratch area #2
*		is split into two parts.  Part A (file 4 cache)
*		runs from memory >7000 to >7FFF.  Part B (file 5
*		cache) runs from end of FORTRAN5 til end of memory.
*
*   2. TI-99/SUPER: in this case, scratch area #1 starts at location
*		>3000 and runs for >ffe bytes.  Scratch area #2
*		is split into two parts.  Part A (file 4 cache)
*		runs from meory >6000 to >7FFF.  Part B (file 5
*		cache) runs from end of FORTRAN5 til end of memory.
*
*   3. TI-99: in this case, scratch area #1 starts at location >3000,
*		and runs for >FFE bytes.  Scratch area #2 is contiguous
*		and runs from end of FORTRAN 5 til end of memory.
*
*  First, determine where FORTRAN5 ends.  Since FORTRAN5 contains
*  overlapped memory for FORTRAN1/FORTRAN3 data areas, pick the
*  larger of the two areas to determine where it ends.
*
	LI   R5,ENDL1		DETERMINE START OF SCRATCH AREAS
	CI   R5,ENDL3		WHICH AREA EXTENDS LARGER
	JH   NOSWIT		BRIF AREA 1 IS HIGHER
	LI   R5,ENDL3		
NOSWIT	EQU  $
	INCT R5			SKIP A WORD JUST IN CASE
	UNL
	IF   GENEVE
	LIST
	MOV  R5,@SA1ADS		PUT IT IN SCRATCH AREA 1 START
	AI   R5,SA1LEN		ADD LENGTH OF SCRATCH AREA #1
	MOV  R5,@SA1ADE		AND SAVE IT
	INCT R5			SCRATCH AREA #2 FOLLOWS
	MOV  R5,@SA2ADS		START OF AREA
	LI   R5,MAPEND		END OF MAPPABLE SPACE
	MOV  R5,@SA2ADE
	ELSE
	LIST
	MOV  R5,@SA2ADS		SCRATCH AREA #2 START
	LI   R5,MAPEND		END OF MAPPABLE SPACE
	MOV  R5,@SA2ADE		AS SCRATCH AREA #2 END
	LI   R5,MAPSTA		MAP START
	MOV  R5,@SA1ADS		AS AREA #1 START
	AI   R5,SA1LEN
	MOV  R5,@SA1ADE		AS AREA #1 END
	ENDIF
*
*  The memory cells SA1ADS, SA1ADE, SA2ADS, SA2ADE now contain the
*  start and end of the two scratch areas.
*
*  Now determine where files 4 and 5 (the two scratch files) reside
*  within the scratch area #2.
*
	UNL
	IFEQ GENEVE
	LIST
	MOV  @MEMTYP,R5		GET MEMORY TYPE (0=E/A; 1=MINI; 2=SUPER)
	JEQ  NOMINI		BRIF E/A TYPE
	CI   R5,1		IS IT MINI MEMORY?
	JEQ  DOMINI		BRIF YES
	LI   R5,SUPERS+2	SUPERSPACE MEMORY START
	JMP  DOMIN0
DOMINI	EQU  $
	LI   R5,MINIST+2	MINI-MEMORY START
DOMIN0	EQU  $
	MOV  R5,@F4LOW		USE MINI-MEM FOR HIGH/LOW
	LI   R5,MINIEN
	MOV  R5,@F4HIGH
	JMP  SKMINI
	ENDIF
	LIST
NOMINI	EQU  $
	MOV  @SA2ADS,@F4LOW	CONTIGUOUS SCRATCH SPACE, SET F4 START
	MOV  @SA2ADE,@F4HIGH
SKMINI	EQU  $	
	MOV  @SA2ADS,@F5LOW	SET FILE 5 LOW/HIGH
	MOV  @SA2ADE,@F5HIGH
*
*  File 4 & 5 cache spaces are now set up.  Final step is to
*  initialize my stack areas.
*
	MOV  @SA1ADS,R5		SET MY SCRATCH AREA CPU POINTERS
	DECT R5
	MOV  R5,@RAINPU
	MOV  @SA1ADE,@RFLAST	END OF STACK AREA
	MOV  @RAINPU,@RTINPU
*				INITIALIZE INPUT STACK TO 40 WORDS
*				AT TOP OF STACK MEMORY
	MOV  @RAINPU,R5
	AI   R5,80
	MOV  R5,@RBINPU
*
*  ANNOUNCE MYSELF TO USER, AND SHOW VERSION NUMBER
*
	BLWP @CTSCR$
	DATA HELL1		CLEAR SCREEN & WRITE HEADER
*
	UNL
	IF   GENEVE
	LIST
	BLWP @CTSCR$
	DATA VERSNO		DISPLAY VERSION NUMBER
*
	BL   @PARFIL		PARSE FILE
	ELSE
	LIST
	BL   @GETOPT		GET OPTIONS
	ENDIF
*
	LI   R2,OPTFIL
	MOV  @RAINPU,R5
	INCT R5
	LI   R6,80
BLALOP	EQU  $
	MOV  @KBLANS,*R5+ 	CLEAR FIRST OPTION LINE
	DECT R6
	JNE  BLALOP
	AI   R5,-78		START OF OPTIONS
	CLR  R1
	MOVB *R2+,R1		GET STRING LENGTH OF OPTIONS
	JEQ  LOPEXI		BRIF NOTHING SPECIFIED
	SWPB R1
LOPC	EQU  $
	MOVB *R2+,*R5+    	MOVE A LETTER
	DEC  R1
	JNE  LOPC
LOPEXI	EQU  $
	CLR  @VLINES
	LI   R2,-18
LOPOP	CLR  @FOPTIO(R2)  	CLEAR LOOP FOR FLAGS
	INCT R2
	JNE  LOPOP
	SETO @PLOCN		SET POPS LOCATION COUNTER TO
*				SCAN OPTIONS BUFFER
	SETO @FX1		SET SCRATCH FILE 1 <> INPUT FILE
	LI   R1,S2BYTE  	GET SCRATCH FILE 2 RECORD SIZE
	MOV  R1,@VS2BYT
	MOV  R1,@VX2SIZ
	JMP  INITIA
*
*  RETURN ENTRY FROM PASS 2
*
P1RETN	EQU  $
	CLR  @PLOCN		START OF OPTION SCAN
*				IN LOCATION COUNTER
	MOV  @RFLAST,@RFINPU
	CLR  @VLINES		INITIALIZE LINE COUNTER TO 0
	MOV  @FEOD,R5		IF NO EOD ENCOUNTERED, BEGIN
	JEQ  P2RET1		INITIALIZATION FOR NEXT PROGRAM
*
*  TERMINATE COMPILATION
*
	BLWP @CTSCR$
	DATA COMPCO		OUTPUT 'COMPILATION COMPLETE'
LABORT	EQU  $
	BL   @CLOSAL
	LIMI 2			MAKE SURE INTERRUPTS ENABLED
	IFEQ GENEVE
	BLWP @CWAIT$		WAIT FOR KEY
	ENDIF
	B    @CMENU$
*
P2RET1	EQU  $			ANOTHER MODULE IS TO BE PROCESSED
	MOV  @RAINPU,R5
	INCT R5
	MOV  R5,@S1READ+4
	LI   R4,S1READ  	READ TAIL RECORD FROM S1FILE
	BLWP @FIOC
	JNE  BIOABR		BRIF I/O ERROR
	LI   R4,ALDELE  	DELETE S1FILE
	LI   R5,S1FILE
	MOV  R5,@ALDELE+2
	BLWP @FIOC
	JNE  BIOABR
	LI   R5,S2FILE		DELETE S2FILE
	MOV  R5,@ALDELE+2
	LI   R4,ALDELE
	BLWP @FIOC
	JNE  BIOABR
	BL   @OPEN45		OPEN FILES 4 & 5 FOR WRITE ACCESS
	MOV  @RAINPU,R5
	INCT R5
	MOV  R5,@PS1BUF 	OTHERWISE, REOPEN SCRATCH FILE 1
	LI   R4,S1WRIT		AND ECHO FIRST LINE NEW PROGRAM TO 1
	BLWP @FIOC
	JEQ  INITIA
BIOABR	EQU  $
	B    @IOABOR
*
*  CONTINUE INITIALIZATION
*
INITIA	EQU  $
	UNL
	IF   GENEVE
	LIST
	LI   R0,FORT2		FORTRAN 2 START (IN CPU RAM)
	LI   R1,AF2LEN
	LI   R2,18
INITI1	EQU  $
	MOV  *R0+,*R1+
	DECT R2
	JNE  INITI1
	ELSE
	LIST
	LI   R0,F2SADR		FORTRAN 2 START (IN VDP)
	LI   R1,AF2LEN  	GET OFFSETS
	LI   R2,18
	BLWP @CVMBR$		GET THEM
	ENDIF
	LI   R1,POP		POP ADDRESS
	MOV  *R1,R2		SAVE IT
	IF   GENEVE
	AI   R2,FORT2
	ELSE
	AI   R2,F2SADR
	ENDIF
	MOV  R2,*R1		SAVE IT
	LI   R3,-8		8 FLAGS TO SET
LOPPOP	EQU  $
	INC  R3	    		NEXT OPTION
	JEQ  LOEXIT		BRIF DONE
	INCT R1	    		NEXT POINTER
	MOV  *R1,R4
	SLA  R4,1		TIMES 2
	A    R2,R4		STARTING POP+OFFSET
	MOV  R4,*R1
	JMP  LOPPOP
LOEXIT	EQU  $
	MOV  @PLOCN,R5  	GET LOCATION TO START
	JNE  SETOPT		BRIF 1ST PROGRAM OF COMPILATION
	MOV  @START,@PLOCN  	ELSE, START AT FORTRAN SOURCE
	JMP  SETOP1
SETOPT	EQU  $
	MOV  @OPTSCA,@PLOCN
SETOP1	EQU  $
	MOV  @RFLAST,R0
	LI   R1,RINPUT+2-ROLLS	- # OF STACKS
INILSP	MOV  R0,@RALSP1(R1)
	MOV  R0,@RTLSP1(R1)
	MOV  R0,@RBLSP1(R1)
	INCT R1
	JNE  INILSP
*
*  INITIALIZE BASE VALUES (FIRST FOUR HARD-CODED STACKS)
*
	LI   R0,RA
	LI   R1,RTF
	LI   R2,RT
	LI   R3,RBF
	LI   R4,RB
	LI   R5,-4
*
RTLOP	EQU  $
	CLR  *R0+		CLEAR STACK ANCHOR
	MOV  *R1+,*R2+		SET STACK TOP
	MOV  *R3+,*R4+		SET STACK BOTTOM
	INC  R5
	JNE  RTLOP
	LI   R2,ZERDTS
INILP1	CLR  @VSYM1(R2)
	INCT R2
	JNE  INILP1
	CLR  @FEOD		END OF FILE FLAG
	CLR  @PS2		FILE POINTER
*				INIT READ FILE NUMBER
	LI   R5,INFILE
	MOV  R5,@SIOPLB
	ABS  @DEBENA		IS DEBUGGER ENABLED
	JEQ  NODEB		BRIF NO
	BL   @MININI		YES, CALL DEBUGGER INITIALIZATION
NODEB	EQU  $
	B    @STMTIN		START STATEMENT SCANNING
	UNL
	IF   GENEVE
	TITL 'PARSE FILE OPTIONS'
	LIST
*
*  PARFIL - PARSE FILE OPTIONS
*
*  THIS SUBROUTINE PARSES THE FILE OPTIONS FROM THE COMMAND LINE.
*  THE COMMAND LINE IS PASSED AS:
*
* FORTRAN >diagnostic_file /Llisting_file /Oobject_file /Poptions input_file
*
PARFIL	EQU  $
	MOV  R11,R10		SAVE RETURN
	CLR  R5			CLEAR LENGTHS OF INPUT STRINGS
	MOVB R5,@INPFIL		INPUT FILE
	MOVB R5,@OBJFIL		OBJECT FILE
	MOVB R5,@LISFIL		LISTING FILE
	MOVB R5,@SCRFIL		SCRATCH FILES
	MOVB R5,@OPTFIL		OPTION STRING
	MOVB R5,@CRTFIL		DIAGNOSTIC (CRT) OUTPUT
*
	LI   R5,CMDADR		GET COMMAND STRING ADDRESS
	CLR  R6
	MOVB *R5+,R6		GET COMMAND STRING LENGTH
	SWPB R6
	JNE  PARFI1		BRIF SOMETHING HERE
ENOTTO	EQU  $
	LI   R0,NOTTDO		NOTHING TO DO!  NO INPUT FILE
	B    @ABORTE
*
*  Start parsing the command line.  If the next character is a dash
*  (-), then this is an option string.  If the next character is
*  not a dash, then this better be the input file name.
*
PARFI1	EQU  $
	LI   R7,PARADR
	BL   @MOVNAM		move name
	JNE  PARFI1		brif more
*
*  Coming out of above loop, all of the strings which were specified
*  have something in them.  Make sure the input file was specified.
*
	MOVB @INPFIL,R5		get size of input file string
	JEQ  ENOTTO		brif nothing specified (nothing to do!)
*
*  If CRT option (>) not chosen, then move CRT to PAB.
*
	MOVB @CRTFIL,R5		anything here?
	JNE  PARFI4		brif yes, skip it
	LI   R0,CRTSTR		move string
	LI   R1,CRTFIL
	LI   R2,4
PARFI3	EQU  $			move string to PAB file name
	MOVB *R0+,*R1+
	DEC  R2
	JNE  PARFI3
*
PARFI4	EQU  $
	BL   @STAPAB		INPUT FILE
	DATA INPSET
	DATA INPPAB
	DATA INFILE			
*
	BL   @STAPAB		OBJECT FILE
	DATA OBJSET		SETUP PARAMETERS
	DATA OBJPAB		PAB START ( CPU RAM )
	DATA OBFILE		FILE #
*
	BL   @STAPAB		LISTING FILE
	DATA LISSET
	DATA LISPAB
	DATA LIFILE
*
	BL   @STAPAB		CRT FILE
	DATA CRTSET
	DATA CRTPAB
	DATA CRFILE
*
	MOVB @ASCFIV,@DISKN1	OPEN SCRATCH UNITS 4 & 5
	MOVB @ASCFIV,@DISKN2
	BL   @OPEN45
	BLWP @CTSCR$		Output 'compilation in progress'
	DATA COMPIN
	B    *R10		RETURN	
*
*  MOVNAM - Moves a single name from the command string to the
*	    file name area specified.  The file name is pointed to
*	    by *R11.  The command string is pointed to by R5 (address)
*	    and R6 (length).
*
*	    On exit, R8 has the terminating character
*
MOVNAM	EQU  $
	CLR  R8			COUNT OF CHARACTERS
MOVNA1	EQU  $			SKIP LEADING BLANKS
	CB   *R5,@KBLANS	IS THIS A BLANK?
	JNE  MOVNA2		BRIF NO
	INC  R5
	DEC  R6
	JNE  MOVNA1		MORE CHARS
	JMP  MOVNA5		NO MORE, SKIP TIL END
*
MOVNA2	EQU  $
	CLR  R9			Clear option letter
	CB   *R5,*R7		Is this a caret (>)
	JNE  MOVN2A
	MOVB *R5+,R9		yes, save the caret
	DEC  R6
	JEQ  MOVERR
	JMP  MOVNA4
*
MOVN2A	EQU  $			not a caret, try a dash
	INCT R7			skip caret words
	INCT R7
	CB   *R5,@ESLASH	Is this a slash (option letter)
	JNE  MOVNA3		brif no
	INC  R5
	DEC  R6
	JEQ  MOVERR		Error, no more
	MOVB *R5+,R9		save the option letter
	DEC  R6
	JEQ  MOVERR
*
MOVNA3	EQU  $			option letter parsed, now find string address
	CB   *R7,@XFF00		is this the end of the list
	JEQ  MOVERR		brif yes, unrecognized letter
	CB   *R7,R9		right option?
	JEQ  MOVNA4		brif yes, get string address
	INCT R7
	INCT R7
	JMP  MOVNA3
*
MOVNA4	EQU  $			got right string, now get address
	INCT R7
	MOV  *R7,R7		string address
	MOV  R7,R0		save length byte address
	CB   *R7+,@KZERO	is string already blank?
	JEQ  MOVNA5		brif yes, no error
	LI   R0,OSTERR		option specified twice error
	B    @ABORTE
*
MOVNA5	EQU  $
	CB   *R5,@KBLANS	Is next character a blank?
	JEQ  MOVNA6
	MOVB *R5+,*R7+		else, move character to output string
	INC  R8			INC # OF CHARACTERS MOVED
	CI   R8,CHAFIL		MORE THAN CHAFIL CHARS, ERROR
	JEQ  MOVNTL		BRIF ERROR
	DEC  R6			ANY MORE CHARACTERS?
	JNE  MOVNA5
	JMP  MOVNA6		ELSE, DONE.  RETURN
*
MOVERR  EQU  $			PARSING ERROR ON OPTION
	LI   R0,BADOPT
	B    @ABORTE
MOVNTL	EQU  $			GENERATE ERROR, NAME TOO LONG
	LI   R0,TOOLEN		LENGTH TOO LONG
	B    @ABORTE
*
MOVNA6	EQU  $			BLANK TERMINATOR, SKIP BLANKS
	SWPB R8			# BYTES MOVED
	MOVB R8,*R0		SAVE IN BUFFER
	MOV  R6,R6
	B    *R11		RETURN
	ELSE
	LIST
*
* GET OPTIONS ROUTINE
*
* SOLICIT USER INPUTS, INCLUDING:
*
*  		1.  INPUT FILE NAME
*  		2.  OBJECT FILE NAME
*  		3.  LISTING FILE NAME
*  		4.  SCRATCH DISK NUMBER
*  		5.  COMPILATION OPTIONS
*
GETOPT	EQU  $
	MOV  R11,R10		SAVE RETURN
*
	LI   R0,CRTSTR		move string
	LI   R1,CRTFIL
	LI   R2,4
PARFI3	EQU  $			move string to PAB file name
	MOVB *R0+,*R1+
	DEC  R2
	JNE  PARFI3
	BL   @STAPAB		CRT FILE
	DATA CRTSET
	DATA CRTPAB
	DATA CRFILE
*
GETOP1	EQU  $
	BL   @SCRIO		GET INPUT FILE NAME
	DATA HELL2		PROMPT
	DATA INPFIL		INPUT FILE HOLDER
	CLR  R1	    		ENSURE SOMETHING WAS SPECIFIED
	MOVB @INPFIL,R1
	JEQ  GETOP1
*
	BL   @STAPAB		START PAB SETUP
	DATA INPSET
	DATA INPPAB
	DATA INFILE		FILE #
*
* REQUEST OBJECT FILE NAME
*
	BL   @SCRIO		GET OBJECT FILE NAME
	DATA REQOBJ		PROMPT
	DATA OBJFIL		OBJECT FILE NAME
*
	BL   @STAPAB
	DATA OBJSET		SETUP PARAMETERS
	DATA OBJPAB		PAB START ( CPU RAM )
	DATA OBFILE		FILE #
*
* REQUEST LISTING FILE NAME
*
NOAB8 	EQU  $
	BL   @SCRIO		GET LISTING FILE NAME
	DATA REQLIS		PROMPT
	DATA LISFIL		LISTING FILE
*
	BL   @STAPAB
	DATA LISSET
	DATA LISPAB
	DATA LIFILE
*
* REQUEST SCRATCH DISK #
*
GETSCA	EQU  $
	BLWP @CTSCR$
	DATA REQSCR
	LI   R3,2
	LI   R4,SCRFIL
	BLWP @CSCRI$
	JNE  ABORT
NOAB4	LI   R2,SCRFIL
	CLR  R1
	MOVB *R2+,R1		GET NUMBER ENTERED
	JEQ  SETONE		BRIF NOTHING ENTERED, USE 1
	MOVB *R2,@DISKN1
	MOVB *R2,@DISKN2
	JMP  SETON1
SETONE	EQU  $
	MOVB @ASCONE,@DISKN1
	MOVB @ASCONE,@DISKN2
*
* OPEN FILES 4 & 5, SCRATCH FILES
*
SETON1	EQU  $
	BL   @OPEN45
*
* REQUEST COMPILATION OPTIONS
*
	BL   @SCRIO		GET COMPILATION OPTIONS
	DATA REQOPT
	DATA OPTFIL
	LI   R0,6		Open dummy pab for screen
	LI   R1,CRTPAB
	BLWP @COPFI$
	BLWP @CWAIT$		Request Continuation
	BLWP @CTSCR$		Output 'compilation in progress'
	DATA COMPIN
	B    *R10
	ENDIF
*
* IOABOR - I/O ERROR HAS OCCURRED.  Error # in register R1.
*
IOABOR	EQU  $			I/O ABORT ROUTINE
	DEC  R1			DECREMENT ERROR MESSAGE TO TRUE TI-99 ERROR
	JMP  IOCON2			(INCLUDING 0)
ABORTE	EQU  $			ERROR ENTRANCE WHERE ERROR IN R0
	MOV  R0,R1
IOCON2	EQU  $
	MOV  R1,R8	 	SAVE ERROR #
	MOV  R2,R9	 	SAVE FILE PAB ADDRESS
	SLA  R1,1
	AI   R1,ERRMSG		ERROR # IN HIGH
	MOV  *R1,R4		GET ERR MSG ADDRESS
	BLWP @CSCRO$		TELL USER ABOUT IT
	CI   R8,7		IS IT AN I/O ERROR ?
	JGT  ABORT		BRIF NO
	MOV  R9,R0		RESTORE FILE NAME ADDRESS
	CLR  R1
	IF   GENEVE
	MOVB *R0,R1
	ELSE
	BLWP @CVSBR$		GET FILE LENGTH
	ENDIF
	MOV  R1,R1
	JEQ  ABORT		BRIF NO FILE HERE
	SWPB R1
	MOV  R1,R2		# BYTES TO READ
	INC  R0
	LI   R1,EXFILE  	IN ERROR MSG
	UNL
	IF   GENEVE
	LIST
IOABO1	EQU  $
	MOVB *R0+,*R1+		MOVE FROM CPU RAM
	DEC  R2
	JNE  IOABO1
	ELSE
	LIST
	BLWP @CVMBR$		READ FILE ID
	A    R2,R1		SET EOF
	ENDIF
	LI   R2,>0DFF
	MOVB R2,*R1+
	SWPB R2
	MOVB R2,*R1		SET TERMINATOR
	BLWP @CTSCR$
	DATA EXTERR
	BLWP @CTSCR$
	DATA EXFILE		PRINT FILE NAME IN TROUBLE
	B    @LABORT
ABORT 	EQU  $
	IF   GENEVE
	BLWP @CTSCR$		SHOW PROPER USAGE
	DATA ERRUS
	ENDIF
	B    @LABORT
*
*  CLOSAL - CLOSE ALL FILES (& DELETE TEMPORARIES)
*
CLOSAL	EQU  $
	MOV  R11,R7		SAVE RETURN
	LI   R8,ALNUMB
	LI   R0,1
	MOV  R0,*R8
ABLOOP	LI   R4,ALCLOS   	GET GENERAL CLOSE FILE STACK
	MOV  *R8,R0
	CI   R0,4		DELETE FILES 4 & 5
	JEQ  DODEL1
	CI   R0,5		CLOSE ALL OTHERS
	JNE  ALDEL1
DODEL1	EQU  $
	MOV  R0,@DENUMB
	LI   R4,ALDELE  	DELETE A FILE
ALDEL1	EQU  $
	BLWP @FIOC		CLOSE A FILE
	INC  *R8
	MOV  *R8,R0
	CI   R0,8		AM I DONE ?
	JNE  ABLOOP		BRIF NO
	B    *R7		RETURN
	UNL
	IFEQ  GENEVE
	LIST
*
*  SCRIO - PROMPTS THE USER FOR SOMETHING, AND THEN INPUTS THE STRING
*
SCRIO 	EQU  $
	MOV  R11,R9		SAVE RETURN
	MOV  *R9+,R4		GET PROMPT STRING ADDRESS
	BLWP @CSCRO$		& DO IT
	MOV  *R9+,R4		GET INPUT STRING ADDRESS
	LI   R3,CHAFIL		LENGTH OF ITEM
	BLWP @CSCRI$
	JNE  ABORT		IF BACK OR REDO, ABORT
	B    *R9
	ENDIF
	LIST
*
*  OPEN45 - OPEN FILES 4 & 5 FOR ACCESS
*
*  OPEN FILE 4 -  SCRATCH FILE #1
*
OPEN45	EQU  $
	MOV  R11,R9		SAVE RETURN
	LI   R1,SC1PAB  	OPEN SCRATCH 4
	LI   R0,>12
	MOV  R0,*R1
	LI   R0,S1FILE		FILE #
	BLWP @FOPFIL
	JNE  BIOAB2
*
* OPEN FILE 5 -  SCRATCH FILE #2
*
	LI   R1,SC2PAB
	LI   R0,3
	MOV  R0,*R1
	LI   R0,S2FILE		FILE #
	BLWP @FOPFIL
	JNE  BIOAB2		BRIF ERROR
	B    *R9
*
*  STAPAB - SETUP PAB FOR READ/WRITE
*
STAPAB	EQU  $
	MOV  *R11+,R0		SETUP PARAMETERS
	MOV  *R11,R1		PAB START
	MOV  *R0+,*R1+  	SET ORDER CODE
	CLR  *R1+
	CLR  R5
	MOV  *R0,R5
	SWPB R5
	MOV  R5,*R1+		BYTE COUNT
	CLR  *R1+
	CLR  R5
	MOVB R5,*R1+
	MOV  *R11+,R1		GET PAB ADDRESS AGAIN
	MOV  *R11+,R0		GET FILE #
	MOV  R11,R9
DOOPE5	EQU  $
	BLWP @COPFI$		OPEN THE FILE
	JNE  BIOAB2		BRIF OPEN ERROR
	B    *R9		ELSE, JUST RETURN
BIOAB2	B    @IOABOR
*
	TITL 'STATEMENT INITIALIZATION'
	PAGE
*
*    1.  Statement Initialization
*    2.  Scanning Control
*    3.  Miscellaneous support routines
*
STMTIN	EQU  $
	MOV  @KONE,@PCURCH 	INITIALIZE FOR 1ST STATEMENT
	MOV  @K80,@PRECCH	(1ST RECORD ALREADY READ)
*	MOV  @K72,@PRECCH  	(1ST RECORD ALREADY READ)
	CLR  @PLSTCH		INITIALIZE CHARACTER POINTERS
	CLR  @VRCDCN
	CLR  @PERRMS		INITIALIZE ERROR MESSAGE PTR AND
	CLR  @FLONGN		WARNING FLAGS
	CLR  @FMXMOD
	CLR  @FTRUNC
*
STINI1	EQU  $
	BL   @READ		READ ALL RECORDS OF INPUT STMT
*				 ONTO INPUT STACK.
	INC  @VRCDCN
	MOV  @PSIBUF,R2 	READ UNTIL NON-CONTINUATION
	BL   @CONTNC		 CARD IMAGE ENCOUNTERED
	JNE  STINI1		BRIF CONTINUATION LINE
	LI   R2,RCODE		RESERVE 3 WORDS AT END OF CODE
	BL   @PUTONB
	LI   R2,RCODE
	BL   @PUTONB
	LI   R2,RCODE
	BL   @PUTONB
	MOV  @RBCODE,R5 	MOVE NEW 'CODE' ONTO
	MOV  R5,@RTCODE 	BUFFER BY MOVING RBUFFER
	MOV  R5,@RFBUFF 	FLOOR POINTER
	MOV  R5,@RBBUFF
	MOV  R5,@RTBUFF
*
*  EXTRACT FIRST CHARACTER FROM INPUT LINE.  CHECK AGAINST VALID
*  COMMENT AND CONDITIONAL COMPILATION SPECIAL CHARACTERS (E.G. C)
*
	MOV  @RTINPU,R6
	INCT R6	    		CLEAR R2
	CLR  R5	    		SET FOR MOVE BYTE
	MOVB *R6,R5		GET 1ST CHAR
	SWPB R5
	MOV  R5,@VCURCH 	SAVE CURRENT CHAR
	SWPB R5
	LI   R6,COMMST		CHECK 1ST CHARACTER AGAINST COMMENT CHARS
	CB   R5,*R6+
	JEQ  NEXTST		BRIF IT IS A 'C'
	CB   R5,*R6+
	JEQ  NEXTST		BRIF IT IS A 'c'
	CB   R5,*R6+
	JEQ  NEXTST		BRIF IT IS A '*'
	CB   R5,*R6+
	JEQ  CHKDMO		BRIF IT IS A 'D'
	CB   R5,*R6+
	JNE  NOTCO4		BRIF IT IS NOT A 'd'
*
*  IT IS A 'D' or 'd'.  CHECK IF COMPILING IN D MODE.  IF SO, THEN
*  STATEMENT IS NOT A COMMENT, OTHERWISE IT IS A COMMENT.
*
CHKDMO	EQU  $
	MOV  @FDMODE,R6 	COMPILING IN D MODE ?
	JEQ  NEXTST		BRIF YES, IS A COMMENT
	MOV  @LOBLAN,@VCURCH	OTHERWISE, BLANK THE 'D'
*
*  THE FOLLOWING IS FOR PROCESSING A VALID STATEMENT.  CHECK FOR AN
*  ALL BLANK LINE.  IF FOUND, THEN TREAT THE LINE AS A COMMENT LINE.
*
NOTCO4	EQU  $
	LI   R3,40		CHECK 40 CHARACTERS
	LI   R5,'  '		AGAINST BLANKS
	MOV  @RTINPU,R6		GET BASE OF STATEMENT AGAIN
	INCT R6
BLALO4	EQU  $
	C    *R6+,R5		ARE THESE TWO CHARACTERS BLANK?
	JNE  STATUE		BRIF NO, PROCESS STATEMENT
	DEC  R3
	JNE  BLALO4		CHECK NEXT
*
	C    @VLINES,@KONE	MAKE SURE NOT FIRST LINE (OPTIONS)
	JGT  NEXTST		IF WHOLE LINE BLANK, SKIP STATEMENT
*
*  STATUE - SAVE CURRENT STACK STATUS & POINTERS
*
STATUE	EQU  $
	BL   @SAVPTR		SAVE CURRENT CHARACTER & POINTERS
	DATA VSTATC		STARTING AT VSTATC
	LI   R2,RINPUT
STATLP	EQU  $
	INCT R2	    		STACK UP DISPLACEMENTS FROM
	MOV  @RT(R2),R5
	S    @RA(R2),R5
	LI   R3,-RINPUT
	AI   R3,RTSV
	DECT R3
	A    R2,R3
	MOV  R5,*R3
	MOV  @RB(R2),R5
	S    @RA(R2),R5
	LI   R3,-RINPUT
	AI   R3,RBSV
	DECT R3
	A    R2,R3
	MOV  R5,*R3
	MOV  R2,R5
	AI   R5,-RLAST
	JLT  STATLP
	BL   @SETREG		SET REGISTERS ACCORDING TO TRACE FLAG
	B    @INTER1
*
*  NEXTSTMT -
*
*  THIS MODULE ADVANCES TO THE NEXT STATEMENT TO BE SCANNED.
*
NEXTST	EQU  $
	LI   R2,-4
	MOV  @VRCDCN,R5
	AI   R5,CBOS		FILL IN BEGINNING OF STATEMENT
	MOV  @RFBUFF,R6 	INFORMATION IN RESERVED WORDS
	A    R2,R6		AT END OF CODE BUFFER
	MOV  R5,*R6
	CLR  R5
	MOV  @FTRUNC,R6
	JEQ  NOTRUN
	LI   R5,4
NOTRUN	MOV  R5,R4
	MOV  @FMXMOD,R6
	C    R6,R5		WORD 1: BOS PSEUDO LINE COUNT
	JEQ  NOMXMO
	AI   R4,2
NOMXMO	MOV  @FLONGN,R6  	WORD 2: WARNINGS AND ERRORS
	JEQ  NOLONG
	INC  R4
NOLONG	MOV  @PERRMS,R5
	SWPB R5	    		WORD 3: ERROR CHAR POINTER
	A    R4,R5
	MOV  @KONE,R4
	MOV  @RFBUFF,R6
	INCT R2
	A    R2,R6
	MOV  R5,*R6
	MOV  @RFBUFF,R6
	MOV  @PERRCH,*R6
*
	BL   @PUNCH
	LI   R5,80
	A    @RAINPU,R5
	INCT R5
	MOV  R5,@PTRANS 	DISCARD JUST PROCESSED STATEMENT
	INCT @RBINPU		TEXT FROM INPUT STACK
	MOV  @VINOPL,R5 	PROCESS INCLUDE FILE SPEC ?
	JEQ  NOINCL		BRIF NO
	MOV  @RBINPU,R6
	LI   R5,VSAVBU  	SAVE BUFFER FOR INCLUDE
	LI   R2,-80		80 BYTES TO MOVE
	A    R2,R6
INLOP1	EQU  $
	MOV  *R6+,*R5+  	SAVE RECORD
	INCT R2
	JNE  INLOP1
	CLR  @VINOPL		CLEAR OPLABEL READ FLAG
	SETO @FINCL		SET INCLUDE FLAG
	LI   R1,VPAB+9  	PAB DESCRIPTOR
	CLR  R2
	MOVB *R1,R2		GET DESCRIPTOR LENGTH
	SWPB R2
	SLA  R2,1		CONVERT TO BYTES
	A    R2,R1
	CB   *R1,@BLANK 	IS ENDING CHAR A BLANK?
	JNE  INOPL5		BRIF NO
	DEC  R2	    		YES, DECR BYTE COUNT
INOPL5	EQU  $
	SWPB R2
	MOVB R2,@VPAB+9 	DECR FILE LENGTH
	BL   @STAPAB		OPEN FILE 7 AS INCLUDE FILE
	DATA INPSET		INPUT FILE PARAMETERS
	DATA VPAB		PAB START
	DATA 7			FILE 7
	BL   @READRE		READ RECORD
*
NOINCL	EQU  $
	MOV  @RBINPU,R5 	TRANSFER FIRST RECORD OF NEXT
	MOV  @PTRANS,R6 	STATEMENT TO INPUT STACK
	LI   R2,80
	S    R2,R5
	S    R2,R6
NOINC1	EQU  $
	MOV  *R5+,*R6+
	DECT R2
	JNE  NOINC1
*
	MOV  @RAINPU,R5 	UPDATE STACK BOTTOM POINTER
	AI   R5,80
	MOV  R5,@RBINPU
*
	MOV  @FEND,R5		CHECK FOR END OF PROGRAM
	A    @FEOD,R5
	JNE  NOSTMI
	B    @STMTIN		N - INIT FOR NEXT STATEMENT
NOSTMI	EQU  $
	MOV  @SIOPLB,R5 	DETERMINE IF END OF FILE
	CI   R5,INFILE		FROM INSERT FILE
	JNE  DONEIN		BRIF YES
	MOV  @FEOD,@FPRGEN NO
	MOV  @PSIBUF,@PS1BUF
	LI   R4,S1WRIT  	WRITE LAST RECORD TO SCRATCH FILE 1
	BLWP @FIOC
	JNE  BIOAB4
	MOV  @ALLOC,R5  	Y - ENTER ALLOCATION PHASE
	BL   @SETREG		SET REGISTERS ACCORDING TO TRACE FLAG
	B    @INTERP
BIOAB4	B    @IOABOR		I/O ABORT PATH
*
DONEIN	EQU  $			DONE W/INCLUDE
	LI   R0,VSAVBU  	RESTORE STATEMENT ON INPUT STACK
	MOV  @PTRANS,R1  	TO STATE BEFORE INCLUDE
	LI   R2,-80
	A    R2,R1
INLOP3	EQU  $
	MOV  *R0+,*R1+
	INCT R2
	JNE  INLOP3
	MOV  @RAINPU,R5 	UPDATE STACK BOTTOM POINTER
	INCT R5
	MOV  R5,@PS1BUF
	AI   R5,78
	MOV  R5,@RBINPU
	MOV  @FSAVEO,@FEOD
	CLR  @FINCL
	MOV  @ILIST,R5  	OUTPUT 'LIST' ENTRY ON RCODE
	LI   R2,RCODE
	BL   @PUTONB		PUSH ON STACK
	LI   R5,ICFILE		USE INCLUDE FILE DEVICE NUMBER
	MOV  R5,@ALNUMB
	LI   R4,ALCLOS
	BLWP @FIOC		CLOSE THE INCLUDED FILE
	B    @STMTIN
*
*  FAIL - FAILURE OF SCAN HAS OCCURRED
*
FAIL	EQU  $			RESTORE SAVED COMPILER STATUS
	BL   @RESPTR		RESTORE POINTERS
	DATA VSTATC		STARTING W/VSTATC
	LI   R2,RINPUT
*
FAILLP	EQU  $
	INCT R2	    		STACK TOP DISPLACEMENTS FROM THIER
	LI   R3,-RINPUT  	CORRESPONDING ANCHORS
	AI   R3,RTSV
	DECT R3
	A    R2,R3
	MOV  *R3,R5
	A    @RA(R2),R5
	MOV  R5,@RT(R2)
	LI   R3,-RINPUT
	AI   R3,RBSV
	DECT R3
	A    R2,R3
	MOV  *R3,R5
	A    @RA(R2),R5
	MOV  R5,@RB(R2)
	MOV  R2,R5
	AI   R5,-RLAST
	JLT  FAILLP
	MOV  @PFAILE,R5		TAKE FAIL EXIT
	B    @INTERP
*
*  READ -
*
*  THIS ROUTINE READS A RECORD FROM THE INPUT FILE AND PLACES IT
*  ON THE INPUT STACK.
*
READ	EQU  $
	MOV  R11,@VREADR	SAVE RETURN
	MOV  @RBINPU,R5
	INCT R5
	MOV  R5,@PSIBUF
	MOV  R5,@PS1BUF
	AI   R5,78		SET POINTERS TO IR BOTTOM +1
	C    R5,@RFINPU
	JLT  RDCRD1		BRIF SUFFICIENT ROOM AVAILABLE
	BL   @PRESSM		ELSE, PRESS MEMORY TO MAKE ROOM
	MOV  @RBINPU,R5 	RECHECK, IF STILL TOO LITTLE
	AI   R5,80		ROOM, ABORT
	C    R5,@RFINPU
	JLT  RDCRD1		BRIF ENUF ROOM
*
RMOVFL	EQU  $
OVERFX	EQU  $
	LI   R0,8		ERROR CODE FOR RM OVERFLOW
	B    @ABORTE		ABORT COMPILATION
*
READRE	EQU  $			INCLUDE READ RECORD ENTRY
	MOV  R11,@VREADR 	SAVE RETURN
	JMP  RDCR1A
RDCRD1	EQU  $
	MOV  R5,@RBINPU  	UPDATE IR BOTTOM POINTER
RDCR1A	EQU  $
	MOV  @FINCL,R5  	READING FROM INCLUDE FILE?
	JEQ  RDCR1B		BRIF NO
	LI   R1,ICFILE		INCLUDE DEVICE NUMBER
	JMP  RDCR1C
RDCR1B	EQU  $
	LI   R1,INFILE		NORMAL FILE NUMBER
RDCR1C	EQU  $
	MOV  R1,@SIREAD+2
	LI   R4,SIREAD
	BLWP @CIO$
	MOV  R1,@FEOD		SAVE RETURN I/O STATUS
	JEQ  NOIOER		BRIF OK
	MOV  @FINCL,R1  	PART OF INCLUDE?
	JNE  NOS1WR		YES, DON'T WRITE IT
NOIOER	EQU  $
	MOV  @VLINES,R5 	GET LINE # BEING PROCESSED
	JEQ  NOS1WR		BRIF FIRST LINE, SKIP IT
	MOV  @PSIBUF,R4 	GET BUFFER POINTER
	MOV  @FINCL,R1  	PROCESSING INCLUDE FILE SPEC?
	JNE  NOADJU		BRIF YES
	AI   R4,-80
NOADJU	EQU  $
	MOV  R4,@PS1BUF 	SAVE POINTER TO S1 RECORD
	LI   R4,S1WRIT
	BLWP @FIOC	 	WRITE THE RECORD
	JNE  RIOER	 	BRIF ERROR
NOS1WR	EQU  $
	MOV  @FEOD,R1		GET ERROR CODE BACK
	JEQ  NOEOF
	CI   R1,6		END OF FILE ?
	JNE  RIOER		BRIF NO
	MOV  @VLINES,@FEOD	IF FIRST CARD, JUST EXIT
	JMP  JUSTRE		JUST EXIT, ELSE SET FLAG
NOEOF 	EQU  $
	INC  @VLINES		INCREMENT LINE NUMBER
JUSTRE	EQU  $
	MOV  @VREADR,R11  	RETURN
	B    *R11
*
RIOER 	EQU  $
	B    @IOABOR		ABORT COMPILATION
*
*  PUNCH - IS CALLED TO PUNCH A RECORD TO SCRATCH FILE 2.
*
PUNCH 	EQU  $
	MOV  R11,@VREADR  	SAVE RETURN
	MOV  @RBCODE,R5
	MOV  R5,@RTCODE
	MOV  R5,@RTBUFF
	MOV  R5,@RBBUFF   	MOVE RBUFFE FLOOR POINTER
	MOV  R5,@RFBUFF   	(=RCODE ANCHOR) SO THAT CODE
	S    @RABUFF,R5   	IS TRANSFERRED TO RBUFFE
	CLR  R4
	DIV  @VX2SIZ,R4
	MOV  R4,R4
	JEQ  BPNCHX
	MOV  R5,@VEXCES
	NEG  R4	    		IF RBUFFE CONTAINS MORE THAN 1
	MOV  R4,@VX2CNT 	RECORD OF DATA, OUTPUT EVEN #
	MOV  @RABUFF,R5 	RECORDS TO THE 2ND SCRATCH FILE
	INCT R5
*
PUNCH1	EQU  $
	MOV  R5,@PS2BUF 	SET MEMORY ADDRESS OF DATA
	LI   R4,S2PUNC
	BLWP @FIOC		WRITE RECORD
	JNE  PIOER		BRIF I/O ERROR
	MOV  @PS2BUF,R5
	A    @VX2SIZ,R5
	INC  @PS2		INCREMENT RECORD #
	INC  @VX2CNT
	JNE  PUNCH1		REPEAT FOR EACH ADDL RECORD
*
	MOV  @VEXCES,R5
	JEQ  PUNCH2
	MOV  R5,R2		SAVE VEXCES
	MOV  @RABUFF,R3 	SETUP FOR MOVE LOOP
	INCT R3
	MOV  @RFBUFF,R4
	S    R2,R4
	INCT R4
LOPTR4	EQU  $
	MOV  *R4+,*R3+  	MOVE CODE WORD
	DECT R2
	JNE  LOPTR4		LOOP UNTIL ALL EXCESS MOVED
*
PUNCH2	EQU  $
	A    @RABUFF,R5
	MOV  R5,@RTBUFF
	MOV  R5,@RBBUFF
	MOV  R5,@RFBUFF
	MOV  R5,@RTCODE 	RBCODE=RTCODE=RACODE
	MOV  R5,@RBCODE		=RABUFF+VEXCES
BPNCHX	MOV  @VREADR,R11
	B    *R11		RETURN
*
PIOER 	EQU  $
	B    @IOABOR
*
*  PRESSM - PRESS MEMORY TO MAKE ROOM.
*
PRESSM	EQU  $
	LI   R2,RLAST		LAST STACK #
OUTERL	EQU  $
	MOV  @RF(R2),R1		FOR EACH STACK, STARTING WITH THE
	S    @RB(R2),R1 	HIGHEST NUMBERED STACK, INCREMENT
	JEQ  SKIPPM		ANCHOR, TOP, AND BOTTOM SO THAT
	A    R1,@RA(R2)		bias offset anchors specified number of bytes
	A    R1,@RT(R2)		bias offset tops specified number of bytes
	MOV  @RB(R2),R6		save old roll bottom
	A    R1,@RB(R2)		bias offset bottoms specified number of bytes
	MOV  @RB(R2),R5		get new roll bottom in R4
	MOV  R5,R4		save for loop
	S    @RA(R2),R5 	FOR EACH STACK WHOSE STATISTICS ARE
	JEQ  SKIPPM		ALTERED, MOVE ALL STACK	DATA BY
	MOV  R5,R1		THE INCREMENTAL DISTANCE. IF STACK
	SRA  R1,1		IS EMPTY, SKIP TO NEXT.
	INV  R1
*
INNERL	EQU  $
	MOV  *R6,*R4		MOVE OLD TO NEW LOCATION
	DECT R6
	DECT R4
	INC  R1
	JNE  INNERL
*				WHEN ALL DATA HAS BEEN MOVED, DECREMENT
SKIPPM	EQU  $			STACK# (IN R2), AND REPEAT UNTIL INPUT
	DECT R2	    		INPUT STACK IS REACHED. DO NOT MOD-
	CI   R2,RINPUT		IF INPUT STACK.
	JNE  OUTERL
	B    *R11	 	& RETURN
*
*  STASET - Stack Setup Routine
*
STASET	EQU  $
	MOV  RVP,R2		Initialize group size & pointer
	SLA  R2,1
STASE2	EQU  $
	MOV  @RC(R2),R5  	FIRST WORD IN CENTRAL FROM STACK
	ANDI R5,>1F		CODES TABLE
	MOV  R5,@VMGPSI 	EMPTY - R1 HOLDS RETURN POINTER
	MOV  @RC(R2),R5		RVP HOLDS STACK #
	SRC  R5,5
	ANDI R5,>1F		CONVERT TO BYTE COUNT (EVEN ONLY)
	AI   R5,CENTRA
	MOV  R5,@PCENTR
	B    *R11
*
*  PUTARG - PUT ARG ON RVP ON BOTTOM OF STACK
*  PUTONB - PUT ARG ON BOTTOM OF STACK ROUTINE
*
PUTARG	EQU  $
	MOV  RVP,R2		PUSH R5 ON ARG STACK BOTTOM
	SLA  R2,1
PUTONB	EQU  $
	MOV  R5,@VARG		PUSH R5 ON R2 STACK BOTTOM
	MOV  R11,R12		SAVE RETURN
	MOV  @RB(R2),R5
	S    @RF(R2),R5 	CHECK FOR ROOM ON STACK
	JLT  PUTON		Y -- JUST ADD
*
	MOV  R2,@VSTACN	 	MAKE ROOM FOR STACK (REASSIGN)
	MOV  @RFINPU,R5		CHECK FOR FREE SPACE ON INPUT
	S    @RBINPU,R5  	STACK
	C    R5,@KMOVES
	JLT  CALLPR		N -- SQUEEZE MEMORY TO MAKE ROOM
*
PRESSR	EQU  $
	MOV  @RFINPU,R5  	TRANSFER ALL DATA, BETWEEN THE
	MOV  R5,R6	 	 FLOOR OF THE INPUT STACK AND
	S    @KMOVES,R5  	 THE BOTTOM OF THE TARGET STACK,
	MOV  R5,R3	 	 TOWARD THE BOTTOM OF THE INPUT
	MOV  @VSTACN,R2  	 STACK.
	MOV  @RFINPU,R5
	S    @RB(R2),R5  	TRANSFER DISTANCE = KMOVES
	JEQ  INCSTA
	INCT R6
	INCT R3
*
SHIFTL	MOV  *R6+,*R3+
	INCT R5
	JNE  SHIFTL
*
INCSTA	EQU  $
	MOV  @KMOVES,R1   	UPDATE STATISTICS OF ALL STACKS
*			 	INVOLVED (SUB KMOVES FROM R5)
	NEG  R1
	LI   R2,RINPUT		FIRST STACK = INPUT STACK +2
INCST1	EQU  $
	INCT R2
	A    R1,@RA(R2)		bias offset anchors specified number of bytes
	A    R1,@RT(R2)		bias offset tops specified number of bytes
	A    R1,@RB(R2)		bias offset bottoms specified number of bytes
	C    @VSTACN,R2		is this my stack?
	JNE  INCST1		brif no
*
PUTON 	EQU  $
	INCT @RB(R2)		PUT ARG ON TARGET STACK
	MOV  @RB(R2),R2
	MOV  @VARG,*R2		OTHER ROUTINES NEED VARG
	B    *R12		RETURN
*
CALLPR	BL   @PRESSM		LINK TO PRESS MEMORY ROUTINE
	MOV  @RBINPU,R5  	ON RETURN, INSURE THAT SUFFICIENT
	A    @KMOVES,R5  	MEMORY SPACE WAS FOUND
	S    @RFINPU,R5
	JLT  PRESSR		Y - RETURN AT PRESSR
	B    @RMOVFL		N - ABORT, RM OVERFL
*
*  SETREG - SET REGISTERS ACCORDING TO DEBUG FLAG.
*
*    DEBENA - DEBUGGER ENABLED FLAG
*
*    IF DEBENA<>0       RET IS DEBUG
*    IF DEBENA=0        RET IS FAST ADVANCE LOCATION ENTRY
*
SETREG	EQU  $
	LI   RBW,RBWORK
	LI   RET,ADVLOC
	ABS  @DEBENA		GET DEBUGGER FLAG
	JEQ  SETBAC
	LI   RET,DEBUGR		ELSE, HALT ON LOCATION
SETBAC	EQU  $
	B    *R11
*
*  SAVPTR - SAVE POINTERS TO VCURCH, PCURCH
*  RESPTR - RESTORE POINTERS TO VCURCH, PCURCH
*
SAVPTR	EQU  $
	MOV  *R11+,R2		MOVE TO ADDRESS
	LI   R1,VCURCH  	CURRENT CHARACTER ADDRESS
	MOV  *R1+,*R2+
	MOV  *R1,*R2+
	LI   R1,PCURCH  	POINTER TO CHARACTER ADDRESS
	MOV  *R1+,*R2+
	MOV  *R1+,*R2+
	MOV  *R1,*R2
	B    *R11
RESPTR	EQU  $
	MOV  *R11+,R1		MOVE FROM ADDRESS
	LI   R2,VCURCH  	MOVE TO ADDRESS
	MOV  *R1+,*R2+
	MOV  *R1+,*R2
	LI   R2,PCURCH
	MOV  *R1+,*R2+
	MOV  *R1+,*R2+
	MOV  *R1,*R2
	B    *R11
	TITL 'INTERPRETER START, POPS 1,2'
	PAGE
*
*  Contains the intermediate interpreter, and psuedo-ops
*  types 1 and 2 processing.
*
*  The main interpreter loop has three entrance points:
*
*     1.  DEBUGR - Debug trace is turned on
*     2.  SADVLO - Slow advance, resets VDP registers
*     3.  ADVLOC - Fast advance, no reset of VDP registers
*
*  Note the routine uses VDP memory to its advantage, since most
*  Pseudo Ops are executed sequentially, and therefore the VDP
*  registers only have to be refreshed occasionally.
*
EXITFA	EQU  $			EXIT SUBR., SETTING ANSWER=FALSE
	SETO @FANSWE
	JMP  EXITB1
EXIT	EQU  $
	CLR  @FANSWE
EXITB1	EQU  $
	MOV  @RBEXIT,R2
	DECT @RBEXIT		POP STACK POINTER (REXIT STACK)
	MOV  *R2,@PLOCN 	SET LOCATION COUNTER AND RESUME
	JMP  INTER1		TRACE & CONTINUE
*
DEBUGR  EQU  $
	B    @DEBUGC
DERETC	EQU  $
SADVLO	EQU  $
	UNL
	IFEQ GENEVE
	LIST
	INCT @PLOCN		INCREMENT TO NEXT LOCATION
POPSET	EQU  $			NO INCR ENTRANCE
	LIMI 2			LET INTERRUPT ROUTINE RUN ONCE
	LIMI 0
	MOV  @PLOCN,R1  	GET NEXT INSTRUCTION
	SWPB R1	    		FROM VDP RAM
	MOVB R1,@VDPWA
	SWPB R1
	MOVB R1,@VDPWA
	JMP  ADVLO1
	ENDIF
	LIST
ADVLOC	EQU  $			FAST ENTRANCE INTO LOOP
	INCT @PLOCN
ADVLO1	EQU  $
	UNL
	IF   GENEVE
	LIST
	MOV  @PLOCN,R5		GET LOCATION
	MOV  *R5,R5
	ELSE
	LIST
	MOVB @VDPRD,R5
	SWPB R5
	MOVB @VDPRD,R5
	SWPB R5
	MOV  R5,R5
	ENDIF
	JLT  POPT2O		BRIF NOT TYPE 1
*
*  Psuedo Operation Code TYPE 1
*
	MOV  R5,R4		PREPARE FOR SHIFT
	ANDI R5,>0FFF		ISOLATE 12 BIT DISPLACEMENT
	SLA  R5,1		TIMES 2
	ANDI R4,>F000		ISOLATE OPCODE
	SRC  R4,11		MOVE TO RIGHT
	MOV  @TTYPE1(R4),R4	ADD BASE
	B    *R4		EXECUTE FUNCTION
*
POPT2O	MOV  R5,RVP
	ANDI R5,>C000
	CI   R5,>8000
	JNE  POPTY3
*
*  Psuedo Operation Code TYPE 2
*
	MOV  RVP,R4
	ANDI R4,>3E00
	SRC  R4,8		ISOLATE OPCODE *2
	MOV  @TTYPE2(R4),R2
	SLA  RVP,7		ISOLATE	DATABASE DISPLACEMENT
	SRA  RVP,6		EXTEND SIGN BIT & *2
	MOV  RVP,RVP
	JLT  NOADD		BRIF YES
	AI   RVP,DAT		ELSE, ADD LO BYTE TO 'DAT' ADDRESS
	B    *R2
NOADD	ANDI RVP,>FF		ELSE, ADD LO BYTE TO 'VAR' ADDRESS
	AI   RVP,VARIAB
	B    *R2
*
*  Psuedo Operation Code TYPE 3
*
POPTY3	MOV  RVP,R4		POP TYPE 3
	ANDI R4,>3F00		ISOLATE OPCODE
	SRC  R4,7	 	*2
	MOV  @TTYPE3(R4),R2
	ANDI RVP,>00FF  	ISOLATE 8 BIT ADDRESS
	MOV  RVP,R5		FOR OPCODES, WHICH ASSUME ITS IN R5
	B    *R2		 GO DO FUNCTION
*
FEX	EQU  $
	A    @POP,R5		SET FAIL EXIT POINTER
	MOV  R5,@PFAILE
	B    *RET
*
JAF	EQU  $
	MOV  @FANSWE,R2  	JUMP ON ANSWER FALSE
	JNE  JUN
	B    *RET
*
JAT	EQU  $
	MOV  @FANSWE,R2  	JUMP ON ANSWER TRUE
	JEQ  JUN
	B    *RET
*
JOW	EQU  $
	MOV  R5,RVP		JUMP ON W0=0
	MOV  *RBW,R6
	MOV  *R6,R5
	JEQ  NOWORK
	DEC  *R6		N - DECREMENT W0
	B    *RET
*
NOWORK	EQU  $
	DECT @RBWORK		Y - PRUNE W0 AND JUMP
	JMP  BRANCH
*
BIM 	EQU  $			Build instruction by mode
	SWPB R5
	MOV  R5,@VINSTR
	MOV  @KBIM,R5
	S    @POP,R5
*
JSB 	EQU  $			Jump to subroutine
	MOV  R5,RVP
	MOV  @PLOCN,R5
	LI   R2,REXIT
	BL   @PUTONB		push current location on EXIT stack
*
BRANCH	EQU  $
	MOV  RVP,R5		reload branch location
JUN 	EQU  $
	A    @POP,R5		jump unconditionally
INTERP	EQU  $
	DECT R5
	MOV  R5,@PLOCN  	interpret the new psuedo code sequence
INTER1  EQU  $
	ABS  @DEBENA		am I using debugger?
	JEQ  SADVLO		brif no, do slow advance
	JMP  DEBUGR		else, call debugger code
*
*  Following handles jump to assembly subroutines (JML).   On entry,
*  R5 has offset into BASE.  The data area is actually not coded
*  this way, since the lower base has dynamic data, and the upper
*  static data, they are seperated.  So, some games must be played
*  to locate the address of the right subroutine to call.
*
XIT 	EQU  $			Branch to non-interpreter subroutine
	AI   R5,BASE-RBLSP1	Subtract dynamic portion of data area
	AI   R5,AHEXSC		+ first address literal
	MOV  *R5,R6		get address
	BL   *R6		execute the subroutine
	JMP  INTER1		return to slow entry (reset VDP location)
*
* Start of Type 2 Psuedo Ops
*
* POPS WHICH AFFECT W0 AND/OR ARGUMENT ONLY
*
ADP 	EQU  $
	MOV  *RBW,R6		ADD INTO W0
	A    *RVP,*R6
	B    *RET
*
ANP 	EQU  $
	MOV  *RBW,R6		AND INTO W0
	MOV  *RVP,R1
	INV  R1
	SZC  R1,*R6
	B    *RET
*
CLA 	EQU  $
	MOV  *RBW,R6		CLEAR W0 AND ADD
	MOV  *RVP,*R6
	B    *RET
*
MPY 	EQU  $
	MOV  *RBW,R6		MULTIPLY W0 BY ARG
	MOV  *R6,R4
	MPY  *RVP,R4
	MOV  R5,*R6
	B    *RET
*
SUP 	EQU  $			SUBTRACT FROM W0
	MOV  *RBW,R6
	S    *RVP,*R6
	B    *RET
*
SWT 	EQU  $			SWITCH RVP & RBW
	MOV  *RBW,R6
	MOV  *R6,R4		TEMP = RBW
	MOV  *RVP,*R6		RBW  = RVP
	MOV  R4,*RVP		RVP = TEMP
	B    *RET
*
IAD 	EQU  $
	MOV  @KADRFL,R5 	INSERT ADR FIELD INTO W0
	JMP  IADITA
*
ITA 	EQU  $
	MOV  @KTAGFL,R5 	INSERT TAG FIELD INTO W0
*
IADITA	MOV  *RBW,R6
	MOV  *R6,R2
	SZC  R5,R2		AND FIELD OUT OF W0
	MOV  *RVP,R1
	INV  R1
	SZC  R1,R5		AND ALL BUT FIELD OUT OF TAG
	SOC  R2,R5		COMBINE
	MOV  R5,*R6
	B    *RET
*
CLI 	EQU  $
	MOV  *RBW,R6
	MOV  R5,*R6
	B    *RET
*
ASK 	EQU  $			Assign to storage and KEEP
	MOV  *RBW,R6
	MOV  *R6,*RVP
	B    *RET
*
ZER 	EQU  $			Zero a variable
	CLR  *RVP
	B    *RET
*
NOZ 	EQU  $
	INC  *RVP		Increment (set non-zero) a variable
	B    *RET
*
* POPS WHICH AFFECT MPAC
*
PLD 	EQU  $
	MOV  RVP,R6		Precision LOAD
	LI   R3,MPAC
	MOV  *R6+,*R3+
	MOV  *R6+,*R3+
	MOV  *R6,*R3
	B    *RET
*
PST 	EQU  $			Precision STORE
	MOV  RVP,R6
	LI   R3,MPAC
	MOV  *R3+,*R6+
	MOV  *R3+,*R6+
	MOV  *R3,*R6
	B    *RET
*
PADX	EQU  $			Precision ADD
	MOV  RVP,R2	 
	INCT R2
	INCT R2			Point to last word to add
	LI   R3,MPAC+4
	A    *R2,*R3		Add first word
	JOC  SETO1		If no carry, then
	CLR  R5			CARRY=0
	JMP  NSETO1
SETO1	LI   R5,1		ELSE CARRY=1
NSETO1	DECT R2
	DECT R3
	A    *R2,R5
	A    R5,*R3
	JOC  SETO2
	CLR  R5
	JMP  NSETO2
SETO2	LI   R5,1
NSETO2	DECT R2
	DECT R3	
	A    *R2,R5
	A    R5,*R3
	B    *RET
*
* POPS WHICH ALTER ONLY FANSWE
*
SLE	EQU  $			SET IF W0<=ARG
	MOV  *RBW,R6
	C    *RVP,*R6
	JLT  ANSFAL
ANSTRU	EQU  $
	CLR  @FANSWE
	B    *RET
ANSFAL	EQU  $
	SETO @FANSWE
	B    *RET
*
SNE	EQU  $			SET IF W0 NOT = ARG
	MOV  *RBW,R6
	C    *RVP,*R6
	JNE  ANSTRU
	JMP  ANSFAL
*
SNZ	EQU  $			SET IF ARG NOT = 0
	MOV  *RVP,R5	
	JEQ  ANSFAL
	JMP  ANSTRU
*
SAD	EQU  $
	MOV  @KADRFL,R5		SET ON MATCHING W0 ADR FIELD
	MOV  *RBW,R6
	MOV  *R6,R2
	JMP  SPTSTD
*
SPT	EQU  $			SET on matching P0 tag field
	MOV  @RBPOLS,R6
	MOV  *R6,R2 
	JMP  SPTSTG
*
STG	EQU  $			SET on matching W0 tag field
	MOV  *RBW,R6
	MOV  *R6,R2
SPTSTG	EQU  $
	MOV  @KTAGFL,R5
*
SPTSTD	EQU  $
	INV  R5
	SZC  R5,R2		issue stack field
	INV  R5
	MOV  *RVP,R6		get psuedo op argment
	INV  R6
	SZC  R6,R5
	C    R2,R5
	JNE  ANSFAL
	JMP  ANSTRU
*
* POPS WHICH AFFECT SCAN POSITION
*
QSA	EQU  $			SET ON MATCHING QUOTE STRING
	BL   @SAVPTR		SAVE POINTERS
	DATA VCHARS
*
	BL   @QTSCAN		SCAN QUOTE
	JMP  ANSTRU		MATCH    -- RTN UPDATED SCAN & ANS=T
*				MISMATCH --
	BL   @RESPTR		RESTORE POINTERS
	DATA VCHARS
	JMP  ANSFAL
*
QSF	EQU  $
	BL   @QTSCAN		SCAN FOR QUOTE / FAIL IF MISMATCH
	B    *RET		MATCH -- INTERPRET NEXT POP
*
QSCSFA	EQU  $
	MOV  @ZSYNTA,R5		MISMATCH -- EXECUTE INTERPRETIVE
	B    @INTERP		SYNTAX FAIL ROUTINE
*
* QUOTE SCAN ROUTINE
*
QTSCAN	EQU  $
	MOV  R11,R10		SAVE RETURN
	AI   RVP,QTB-DAT	add base (offset from DAT which already added)
*
LOQTCH	EQU  $			COMPARE CHAR W/QUOTE
	MOV  RVP,R6
	INC  RVP
	CB   *R6,@ASCAST  	ASTERICK (QUOTE END)?
	JEQ  RETJUS		RETURN W/FOUND IT
	CB   *R6,@VCURCH+1
	JNE  MISQUO		BRIF NOT THE SAME
	BL   @NEXTCH		ELSE, GET NEXT CHARACTER
	JMP  LOQTCH	 	& REDO LOOP
MISQUO	EQU  $
	INCT R10		N - EXIT TO (A)+1
RETJUS	EQU  $
	B    *R10
*
* Psuedo ops which alter stack sizes
*
PSP 	EQU  $			exclusive or w0 into arg
	MOV  *RBW,R6
	MOV  *R6,R5
	XOR  *RVP,R5
	JMP  PSPASP
*
ASP 	EQU  $			Assign to storage and prune stack
	MOV  *RBW,R6
	MOV  *R6,R5
*
PSPASP	EQU  $
	MOV  R5,*RVP		Set argument
	LI   R5,1
*
POW 	EQU  $
	SLA  R5,1		PRUNE ARG WORDS OFF RWORK
	S    R5,*RBW
	B    *RET
*
EAD 	EQU  $
	MOV  @KADRFL,R5
	JMP  EADOPE		EXTRACT ARG ADR FIELD TO WA
*
EOP 	EQU  $
	MOV  @KOPFLD,R5
	JMP  EADOPE		EXTRACT ARG OP FIELD TO WA
*
ETA 	EQU  $
	MOV  @KTAGFL,R5
*				EXTRACT ARG TAG FIELD TO WA
EADOPE	EQU  $
	MOV  *RVP,R6
	INV  R6
	SZC  R6,R5
	JMP  PUSHWO
*
FET 	EQU  $			Fetch argument into WA
	MOV  *RVP,R5
*
EAW 	EQU  $
PUSHWO	EQU  $			Push on work stack
	LI   R2,RWORK
	BL   @PUTONB
	B    *RET
*
POC 	EQU  $
	MOV  *RVP,R5		Push argument on RCODE stack
	LI   R2,RCODE
	BL   @PUTONB
	B    *RET
*
*  Type 1 Psuedo Ops branch table
*
TTYPE1	EQU  $			TYPE 1 BRANCH TABLE
	DATA FEX		FAIL EXIT
	DATA JAF		JUMP IF ANSWER=.FALSE.
	DATA JAT		JUMP IF ANSWER=.TRUE.
	DATA 0			UNUSED
	DATA JOW		JUMP ON WORK STACK
	DATA JSB		JUMP TO SUBROUTINE
	DATA JUN		JUMP
	DATA XIT		EXIT INTERPRETER OR JUMP TO SUBROUTINE
*
*  Type 2 Psuedo Ops branch table
*
TTYPE2	EQU  $
	DATA ADP
	DATA ANP
	DATA ASK
	DATA ASP
	DATA CLA
	DATA EAD
	DATA EOP
	DATA ETA
	DATA FET
	DATA IAD
	DATA ITA
	DATA MPY
	DATA NOZ
	DATA PADX
	DATA PLD
	DATA POC
	DATA PSP
	DATA PST
	DATA QSA
	DATA QSF
	DATA SAD
	DATA SLE
	DATA SNE
	DATA SNZ
	DATA SPT
	DATA STG
	DATA SUP
	DATA SWT
	DATA ZER
	TITL 'TYPE 3 POPS & SUPPORT'
	PAGE
*
*  Type 3 Psuedo Opcodes
*
*  PSUEDO OPS WHICH INVOKE OTHERS
*
W3	EQU  $
	LI   R5,-6		STACK -3
	JMP  WPOP
*
W2	EQU  $
	LI   R5,-4		STACK -2
	JMP  WPOP
*
W1	EQU  $
	LI   R5,-2		STACK -1
	JMP  WPOP
*
W0	EQU  $
	CLR  R5			STACK
*
WPOP	EQU  $
	A    *RBW,R5		STACK OPERATION
	MOV  RVP,R2
	MOV  R5,RVP
	SLA  R2,1
	MOV  @TTYPE2(R2),R2
	B    *R2		EXECUTE TYPE 2 POP
*
IND 	EQU  $
	MOV  @VINDIR,R5 	TYPE 3 POP ARG IS IN
	MOV  RVP,R2		VINDIR
	MOV  R5,RVP
	SLA  R2,1
	MOV  @TTYPE3(R2),R2
	B    *R2
*
* POPS WHICH AFFECT FANSWE ONLY
*
SOP 	EQU  $
	MOV  *RBW,R6		SET ON MATCHING FIELD
	MOV  *R6,R5
	MOV  @KOPFLD,R6
	INV  R6
	SZC  R6,R5
	SRC  R5,16-6
	C    R5,RVP
	JEQ  ANSTR3
	JMP  ANSFA3
*
SRD 	EQU  $
	MOV  R5,R2		SET IF DATA REMAINING ON ARG STACK
	SLA  R2,1	 	*2
	C    @RB(R2),@RT(R2)
	JEQ  ANSFA3
	JMP  ANSTR3
*
SCK 	EQU  $
	MOV  R5,R2
	MOV  @VCURCH,R5
	SLA  R2,1
	C    R5,@SCKMIN(R2)
	JLT  ANSFA3
	C    R5,@SCKMAX(R2)
	JLT  ANSTR3
	JMP  ANSFA3
*
SCE    C    R5,@VCURCH  	SEE IF INPUT CHARACTER	EQUAL
	JEQ  ANSTR3
	JMP  ANSFA3
*
MOA 	EQU  $
	MOV  R5,R2
	SLA  R2,1
	C    @RB(R2),@RT(R2)
	JEQ  ANSFA3
	MOV  @RB(R2),R5 	ELSE, ANSWER TRUE, PRUNE 2 FROM
	DECT @RB(R2)		ARG STACK, AND PUSH TO WA
	MOV  *R5,R5
	LI   R2,RWORK
	BL   @PUTONB
ANSTR3	EQU  $
	CLR  @FANSWE		SET ANSWER=TRUE
	B    *RET
ANSFA3	EQU  $
	SETO @FANSWE
	B    *RET
*
FLP 	EQU  $
	BL   @FLIPST		INVERT LAST GROUP ON ARG STACK
	B    *RET
*
LGA 	EQU  $			Load inverted bottom group from argument
	BL   @STASET		stack into central.
	MOV  @RB(R2),R5
	C    R5,@RT(R2)
	JEQ  ANSFA3
*
	MOV  R5,@PCRRNT 	RETURN ANSWER=FALSE IF STACK IS
	S    @VMGPSI,R5		EMPTY OR IF FIRST WORD IS A
	MOV  R5,@RB(R2)  	MARKER SYMBOL (M39 BLANKS)
	MOV  @PCRRNT,R6
	MOV  *R6,R5
	S    @KMARKE,R5
	JEQ  ANSFA3
	MOV  @VMGPSI,R2
	MOV  @PCRRNT,R6 	OTHERWISE, INVERT BOTTOM GROUP
	MOV  @PCENTR,R3 	ON STACK, COPY TO CENTRAL
*
LGALOP	EQU  $
	MOV  *R6,*R3+		RETURN ANSWER=.TRUE.
	DECT R6
	DECT R2
	JNE  LGALOP
	JMP  ANSTR3
*
* LOADGR - LOAD GROUP POINTED TO BY W0 INTO CENTRAL.
*
LOADGR	EQU  $
	BL   @ADRCAL
	MOV  R5,@PCRRNT
	BL   @STASE2		SUBROUTINE USED ONLY BY POP ROUTINES
	MOV  @PCRRNT,R5
	S    @RB(R2),R5 	RETURN ANSWER FALSE IF PTR IS TO
	JGT  ANSFA3		TO WORD BEYOND END OF STACK
	MOV  @VMGPSI,R2 	ELSE RETURN ANSWER TRUE
	MOV  @PCRRNT,R6
	MOV  @PCENTR,R3
LOADL1	EQU  $
	MOV  *R6+,*R3+
	DECT R2
	JNE  LOADL1
	JMP  ANSTR3
*
FIRSTL MOV  *RBW,R6		EXTRACT FIRST LETTER OF M39 NAME
	MOV  *R6,R5
	CLR  R4
	MOV  @K39SQ,R1
	DIV  R1,R4		DIVIDE BY 39**2 TO RIGHT JUSTIFY
	MOV  R4,*R6
	C    R5,@MLOBLK 	RETURN TRUE IF REMAINDER=BLANKS
	JEQ  ANSTR3
	JMP  ANSFA3		OTHERWISE RETURN FALSE
*
* POPS WHICH AFFECT SCAN POSITION
*
CSA 	EQU  $
	C    R5,@VCURCH 	SCAN CHARACTER / SET FANSWE
	JNE  ANSFA3
	BL   @NEXTCH		ON MATCH, SCAN TO NEXT CHARACTER
	JMP  ANSTR3		& RETURN ANSWER = .TRUE.
*
CSF 	EQU  $
	C    R5,@VCURCH 	SCAN CHARACTER / FAIL ON MISMATCH
	JNE  NQSCSF
	BL   @NEXTCH		ON MATCH SCAN NEXT CHARACTER
	B    *RET
NQSCSF	EQU  $
	B    @QSCSFA		ON MISMATCH, TAKE SYNTAX FAIL
*
* POPS WHICH AFFECT W0 ONLY
*
SCL 	EQU  $
	MOV  R5,R0		SHIFT W0 CIRCULAR LEFT
	NEG  R0	    		FOR RIGHT SHIFT
	AI   R0,16
	MOV  *RBW,R6
	MOV  *R6,R5
	SRC  R5,0		SHIFT VIA R0
	MOV  R5,*R6
	B    *RET
*
FRP 	EQU  $
	BL   @ADRCAL		REPLACE PTR ON W0 WITH CONTENTS OF
	MOV  RVP,R6
	SLA  R6,1
	A    R6,R5		CELL AT PTR+ARG
	MOV  *RBW,R6
	MOV  *R5,*R6		MOVE TO WORK STACK
	B    *RET
*
ARP 	EQU  $
	MOV  *RBW,R6		STORE W0 IN CELL POINTED TO BY W1
	DECT R6
	MOV  *R6,R5
	BL   @ADRCL1
	MOV  RVP,R6
	SLA  R6,1
	A    R6,R5
	MOV  *RBW,R6
	MOV  *R6,*R5
	LI   R5,2
	B    @POW
*
NCC 	EQU  $
	BL   @COUNTB		COUNT # OF GROUPS ON ARG STACK
	LI   R2,RCODE
	BL   @PUTONB		PUSH COUNT ON RCODE
	MOV  R5,R5
	JNE  DOCTC
	B    *RET		COPY AND RELEASE STACK TO RCODE
DOCTC 	EQU  $
	MOV  RVP,R5		(SKIP IF STACK IS EMPTY)
	JMP  CTC
*
CAR 	EQU  $
	MOV  R5,@VSRCEN 	COPY AND RELEASE ARG STACK TO STACK
	MOV  *RBW,R6
	MOV  *R6,RVP		SPECIFIED ON W0, AND PRUNE W0
	DECT *RBW	 	PRUNE W0 & STORE (W0) AS TARGET
	JMP  COPYRO		STACK #
*
CFC 	EQU  $
	LI   R5,RCODE	 	COPY AND RELEASE COPY STACK TO
	SRC  R5,1		DIVIDE STACK # BY 2
	MOV  R5,@VSRCEN
	JMP  COPYRO		ARG STACK
*
*  CTC : COPY AND RELEASE SPECIFIED STACK TO CODE STACK
*
CTC 	EQU  $
	MOV  R5,@VSRCEN 	COPY AND RELEASE ARGUMENT STACK TO CODE
	LI   RVP,RCODE/2	 STACK
*
COPYRO	EQU  $
	MOV  @VSRCEN,R5 	FLIP SOURCE STACK
	BL   @FLIPST
*
COPYLO	EQU  $
	MOV  @VSRCEN,R2 	FOR EACH WORD ON SOURCE STACK,
	SLA  R2,1		MOVE OFF SOURCE STACK & MOVE
	MOV  @RB(R2),R5 	ONTO TARGET.  WHEN FINISHED,
	C    R5,@RT(R2) 	RELEASE SOURCE STACK
	JEQ  RELCHA
	DECT R5
	MOV  R5,@RB(R2) 	MOVING 1 WORD AT A TIME REDUCES
	INCT R5	    		STACK MEMORY REQUIREMENTS A THE
	MOV  *R5,R5		EXPENSE OF SPEED.
	BL   @PUTARG
	JMP  COPYLO
*
REL	MOV  R5,R2		RELEASE ARG STACK
	SLA  R2,1		STACK # TIMES 2
*
RELCHA MOV  @RT(R2),R5
	C    R5,@RA(R2) 	IF TOP=ANCHOR
	JNE  RELMOD		SET BOTTOM=TOP
	MOV  R5,@RB(R2)
	B    *RET
*
RELMOD	EQU  $
	MOV  R5,RVP		IF TOP>ANCHOR
	DECT R5
	MOV  R5,@RB(R2) 	SET BOTTOM=TOP-1
	A    *RVP,R5		SET TOP=TOP+(TOP+1)
*
SETTOP	EQU  $
	MOV  R5,@RT(R2) 	(TOP+1) HOLDS OLD TOP-BOTTOM
	B    *RET
*
* POPS WHICH INCREASE STACK SIZE
*
*  RSV - RESERVE ARGUMENT STACK (IN CASE OF LATER FAILURE, I CAN FALL BACK)
*
RSV 	EQU  $
	MOV  R5,R2
	SLA  R2,1
	MOV  @RT(R2),R5
	S    @RB(R2),R5
	BL   @PUTONB
	MOV  RVP,R2
	SLA  R2,1
	MOV  @RB(R2),R5
	JMP  SETTOP
*
*  BIN TAKES THE PASSED OPCODE, MOVES IT TO THE HIGH BYTE, AND
*      MOVES THAT WORD AND W0 TO THE CODE STACK.  W0 IS PRUNED.
*
BIN 	EQU  $			BUILD INSTRUCTION
	SWPB R5
	LI   R2,RCODE
	BL   @PUTONB		PUT ARG-FIELD IN HIGH BYTE OF
*				WORD AND MOVE ONTO RCODE
	LI   RVP,RCODE
	SRC  RVP,1		MOVE W0 TO RCODE AND PRUNE W0
*
*  MON - MOVE W0 ON ARGUMENT STACK AND PRUNE W0
*
MON 	EQU  $
	MOV  *RBW,R5
	MOV  *R5,R5
	BL   @PUTARG
	DECT *RBW
	B    *RET
*
*  CNT - COUNT # WORDS ON ARGUMENT STACK AND PUSH ON WORK
*
CNT 	EQU  $
	MOV  R5,R2
	SLA  R2,1
	MOV  @RB(R2),R5
	S    @RT(R2),R5
	SRA  R5,1		CONVERT BYTES TO WORDS
	JMP  BPUSHW
*
NOG 	EQU  $
	BL   @COUNTB		COUNT # OF GROUPS ON ARG STACK
BPUSHW	EQU  $
	B    @PUSHWO
*
*  REG - REGISTER ON ARGUMENT STACK
*
REG 	EQU  $
	BL   @SEARCH		REGISTER CENTRAL GROUP ON ARG STACK
*				    SWA  ARGSTACK
	JNE  NOBADV		    JAT  $+3
	B    *RET		    PNG  ARGSTACK
NOBADV	EQU  $
	BL   @PNG1
	B    @PGO		    PGO  ARGSTACK
*
*  SFA - SEARCH FAST WITH ANSWER
*
SFA	EQU  $
	SETO @FASTSR		SET FAST SEARCH
	JMP  SWA1
*
*  SWA - SEARCH WITH ANSWER
*
SWA 	EQU  $
	CLR  @FASTSR		CLEAR FAST SEARCH
SWA1	EQU  $
	BL   @SEARCH		SEARCH ARG STACK FOR GROUP IN CENTRAL
	MOV  R5,@FANSWE 	SAVE RESULT AS ANSWER
	B    *RET
*
*  PNG - GENERATE POINTER TO NEXT AVAILABLE
*
PNG 	EQU  $
	BL   @PNG1
	B    *RET
*
PNG1	EQU  $
	MOV  R11,@PPTRXI
	MOV  RVP,R2
	SLA  R2,1
	MOV  @RB(R2),R5
*
*  FOLLOWING CODE FINDS A POINTER GIVEN A MEMORY OFFSET IN R5, AND
*  A STACK CODE *2 IN R2.
*
POINT1	EQU  $
	S    @RT(R2),R5
	BL   @COUNTG		COMPUTE DISPLACEMENT
	MOV  R5,R4
	CI   R5,MAXPTR		CHECK FOR OVERFLOW
	JLT  PTRBUI
	CI   R5,>400		OVERFLOW IF ID-STACK PTR REQUIRES
	JLT  PTRCHE	 	>10 BITS, OTHERWISE IF >8 BITS
*
PTROVF	EQU  $
	A    @KOVPCQ,R5  	IN CASE OF OVERFLOW, SET OVERFLOW
	MOV  R5,@PERRMS      	MESSAGE POINTER & POINTER TO
	MOV  @PLSTCH,@PERRCH 	NAME CAUSING IT. RESET COMPILER
	B    @FAIL	     	STATUS & TAKE FAIL EXIT.
*
PTRCHE	EQU  $
	CI   R5,RALLOC
	JLT  PTROVF
*
PTRBUI	EQU  $
	MOV  R2,R5		ELSE, LEFT-JUSTIFY STACK #
	SRC  R5,7
	SOC  R4,R5		OR IN CALCULATED ADDRESS FIELD
	LI   R2,RWORK
	BL   @PUTONB		PUSH ON WA
	CLR  R5			RETURN R5=0 (FOR SWA) AND EXIT
	MOV  @PPTRXI,R11
	MOV  R5,R5
	B    *R11
*
*  PGO - PUT NEW GROUP ONTO ARGUMENT STACK
*
PGO 	EQU  $
	BL   @STASET
*
PGOLOO	EQU  $
	MOV  @PCENTR,R6	 	COPY FROM CENTRAL AND PUSH ONTO
	MOV  *R6,R5		 STACK
	BL   @PUTARG
	INCT @PCENTR
	DECT @VMGPSI
	JNE  PGOLOO
	B    *RET
*
*  CPO - COPY PLEX (W0) TO ARGUMENT STACK AND PRUNE W0
*
CPO 	EQU  $
	BL   @ADRCAL
	MOV  R5,@PCRRNT
	MOV  *R5,R5
	JEQ  CPOMON
*
	NEG  R5
	MOV  R5,@VCOUNT
	MOV  R2,R6
	SLA  R6,1
	S    @RT(R6),@PCRRNT 	ON SOURCE STACK
	MOV  R2,@VSRCEN
*
PLEXLO	EQU  $
	MOV  R2,R6		FOR EACH WORD OF PLEX
	SLA  R6,1
	MOV  @RT(R6),R2
	A    @PCRRNT,R2
	INCT R2
	MOV  *R2,R5		COMPUTE POINTER
	BL   @PUTARG		PUSH ON TARGET STACK
	INCT @PCRRNT		UPDATE DISPLACEMENT
	MOV  @VSRCEN,R2
	INC  @VCOUNT		DECREMENT COUNT
	JNE  PLEXLO
CPOMON	EQU  $
	DECT *RBW		WHEN DONE, PRUNE W0
	B    *RET
*
*  COUNTB : COUNT # OF GROUPS ON SPECIFIED STACK - STACK # IN R5
*  COUNTG : COUNT # OF GROUPS ON GIVEN BYTE COUNT IN R5 & STACK #*2 IN R2
*
COUNTB	EQU  $
	MOV  R5,R2
	SLA  R2,1
	MOV  @RB(R2),R5 	COMPUTE # OF WORDS ON STACK
	S    @RT(R2),R5
COUNTG	EQU  $
	JEQ  CGPSEX
	MOV  @RC(R2),R6 	GET STACK CODE
	ANDI R6,>1F		ISOLATE GROUP SIZE IN VMGPSI
	MOV  R6,@VMGPSI
	CLR  R4
	DIV  R6,R4		#BYTES IN STACK/#BYTES PER GROUP
	MOV  R4,R5
CGPSEX	EQU  $
	B    *R11		RETURN
*
*  ADRCAL : ADDRESS CALCULATION
*
ADRCAL	EQU  $
	MOV  *RBW,R6
	MOV  *R6,R5		COMPUTE ADDRESS OF WORD FROM POINTER
ADRCL1	EQU  $
	MOV  R5,R4
	SRC  R5,10		ENTRY1: STACK # ON W0
	ANDI R5,>3F
	SLA  R5,1
	MOV  R5,R2		ENTRY2: STACK # IN A-REG
	CI   R5,RALLOC
	CLR  R5	    		RETURN ADDRESS IN A-REG AND STACK
	JLT  ADRCA1
	MOV  R4,R5
	ANDI R5,>3FF
	JMP  ADRCA2
ADRCA1	EQU  $
	MOV  R4,R5		IF >=ID STACK, USE LOW 10 BITS AS
	ANDI R5,MADRFL		ADDRESS FIELD. ELSE USE LOW 7.
ADRCA2	EQU  $
	MOV  R5,@PCRRNT
	MOV  @RC(R2),R5
	ANDI R5,>1F		TEMPS USED: PCRRNT
	MOV  R5,R4
	CLR  R5
	MPY  @PCRRNT,R4
	INCT R5
	A    @RT(R2),R5
	B    *R11
*
*  SEARCH - SEARCH STACK FOR MATCHING GROUP
*
SEARCH	EQU  $
	MOV  R11,@PPTRXI	SAVE RETURN
	MOV  RVP,R2		GET STACK #
	SLA  R2,1		* 2
	C    @RB(R2),@RT(R2)	IS STACK EMPTY?
	JEQ  SEARC6		BRIF YES, SKIP SEARCH
*
	BL   @STASE2		SETUP FOR STACK ACCESS
*
	MOVB @RC(R2),R5		GET STACK CODE
	SRC  R5,10		 EXTRACT CLUE SIZE
	ANDI R5,>1F
	MOV  R5,@VCLUES
*
	MOV  @RB(R2),R5		GET END OF STACK
	INCT R5			SET UPPER LIMIT
	MOV  R5,@PLIMIT
*
	MOV  @RT(R2),R6		GET START OF STACK
	INCT R6	
*
	ABS  @FASTSR		IS THIS FAST SEARCH?
	JEQ  SEARC2		BRIF NO
*
SEAR1A	EQU  $
	MOV  R6,R0		GET POINTER TO SEARCH TABLE START
	MOV  @PCENTR,R1		GET POINTER TO SEARCH VALUE
	MOV  @VCLUES,R3		GET BYTE SIZE OF CLUE
*
*  ELSE, FAST SEARCH FOR ALREADY ORDERED INTRINSIC STACK
*
SEAR1B	EQU  $
	C    *R0+,*R1+		IS THIS THE VALUE?
	JH   SEARC6		BRIF NO, AND OVERFLOWED TABLE (EXIT)
	JNE  SEAR1C		BRIF NO
	DECT R3			ELSE, DECREMENT CLUE SIZE
	JNE  SEAR1B		AND TRY AGAIN
	JMP  SEARC4		ELSE, FOUND!
*
SEAR1C	EQU  $
	A    @VMGPSI,R6		BUMP NEXT GROUP START
	C    R6,@PLIMIT		AM I AT END OF TABLE?
	JNE  SEAR1A		BRIF NO
	JMP  SEARC6		ELSE, NOT FOUND (END OF TABLE)
*
*  SET UP REGISTERS FOR THIS GROUP.  R0 POINTS TO STACK ENTRY; R1 POINTS
*  TO START OF CENTRAL.  GET FIRST WORD; IF LABEL STACK; THEN MASK OUT
*  IRRELEVANT BITS.
*
SEARC2	EQU  $
	MOV  R6,R0		GET POINTER TO STACK
	MOV  @PCENTR,R1		GET POINTER TO CENTRAL
	MOV  @VCLUES,R3		GET CLUE SIZE IN R3
	MOV  *R0+,R5		GET FIRST WORD
	CI   R2,RLABEL		IS THIS LABEL STACK
	JNE  SEARC3		BRIF NO
	ANDI R5,1		ELSE, AND OUT IRRELEVANT BITS
*
SEARC3	EQU  $
	C    R5,*R1+		COMPARE NEXT WORD
	JNE  SEARC5		BRIF <>, KEEP ON LOOKING
*
	DECT  R3		DECREMENT CLUE SIZE
	JEQ  SEARC4		FOUND IT!
*
	MOV  *R0+,R5		GET NEXT WORD
	JMP  SEARC3
*
*  IT IS A MATCH.  GENERATE A POINTER TO MATCH ON W0 AND RETURN R5=0
*  TO THE CALLER.
*
SEARC4	EQU  $
	MOV  R6,@PCRRNT		GET CURRENT POINTER
	MOV  R6,R5
	DECT R5
	B    @POINT1		GO FIND A POINTER
*
*  THIS GROUP DIDN'T MATCH.  INCREMENT TO NEXT GROUP NUMBER.  IF OUT
*  OF STACK; THEN GENERATE BAD RETURN (R5 <> 0 ).
*
SEARC5	EQU  $
	A    @VMGPSI,R6		BUMP NEXT GROUP START
	C    R6,@PLIMIT		DID I GO BEFORE BEGINNING?
	JNE  SEARC2		BRIF NO
*
*  DIDN'T MATCH IN STACK.   RETURN A 1 IN R5 TO INDICATE FAILURE.
*
SEARC6	EQU  $
	MOV  @PPTRXI,R11	RESTORE RETURN VECTOR
	LI   R5,1
	B    *R11		RETURN
*
*  FLIPST - FLIP A STACK (REVERSE IN ENTIRELY)
*
FLIPST	EQU  $
	MOV  R5,R2		FLIP ARG STACK
	SLA  R2,1
	MOV  @RT(R2),R1
	MOV  @RB(R2),R4 	STACK # IN R5 ON ENTRY
	MOV  R4,R5
	S    R1,R5
	SRA  R5,2		/4 TO CONVERT TO WORDS & BISECT STACK
	JEQ  FLIPEX
*
FLIPLO	EQU  $
	INCT R1			NEXT WORD IN BOTTOM OF STACK
	MOV  *R1,R6		 GET BOTTOM VALUE
	MOV  *R4,*R1		 MOVE TOP VALUE TO BOTTOM VALUE
	MOV  R6,*R4		 MOVE BOTTOM VALUE TO TOP VALUE
	DECT R4			NEXT WORD IN TOP OF STACK
	DEC  R5			DECR # OF WORDS TO PROCESS
	JNE  FLIPLO		BRIF NOT YET DONE
*
FLIPEX	EQU  $
	B    *R11
*
	TITL 'INSTRUCTION ADDRESSES FOR INTERPRETER'
*
TTYPE3	EQU  $
	DATA ARP		ASSIGN RELATIVE TO POINTER
	DATA BIM		BUILD INSTRUCTION BY MODE
	DATA BIN		BUILD INSTRUCTION
	DATA CAR		COPY AND RELEASE
	DATA CFC		COPY FROM CODE STACK
	DATA CTC		COPY TO CODE STACK
	DATA CLI		CLEAR AND ADD IMMEDIATE
	DATA CNT		COUNT WORDS ON STACK
	DATA CPO		COPY PLEX ON
	DATA CSA		CHARACTER SCAN WITH ANSWER
	DATA CSF		CHARACTER SCAN OR FAIL
	DATA EAW		EFFECTIVE ADDRESS TO WORK
	DATA FLP		FLIP LAST GENERATION
	DATA FRP		FETCH RELATIVE TO POINTER
	DATA IND		INDIRECT
	DATA LGA		LOAD GROUP AND ANSWER
	DATA MOA		MOVE OFF STACK WITH ANSWER
	DATA MON		MOVE ON STACK
	DATA NCC		NUMBER AND COPY TO CODE STACK
	DATA NOG		COUNT NUMBER OF GROUPS
	DATA PGO		PUT GROUP ON STACK
	DATA PNG		GENERATE POINTER TO NEW GROUP
	DATA POW		PRUNE OFF WORK STACK
	DATA REG		REGISTER GROUP ON STACK
	DATA REL		RELEASE STACK
	DATA RSV		RESERVE STACK
	DATA SCE		SET IF CHARACTERS EQUAL
	DATA SCK		SET ON CHARACTER KEY MATCH
	DATA SCL		SHIFT W0 CIRCULAR LEFT
	DATA SOP		SET ON MATCH OP FIELD
	DATA SWA		SEARCH STACK AND SET ANSWER
	DATA SRD		SET IF REMAINING DATA
	DATA W0			ARG SPECIFIES TYPE 2 POP W/W0
	DATA W1			ARG SPECIFIES TYPE 2 POP W/W1
	DATA W2			ARG SPECIFIES TYPE 2 POP W/W2
	DATA W3			ARG SPECIFIES TYPE 2 POP W/W3
	DATA SFA		SEARCH FAST STACK AND SET ANSWER
	TITL 'SCANNING ROUTINES'
	PAGE
*
*  CONTAINS THE SYMBOL SCANNING ROUTINES, FLOATING POINT PARSER,
*  AND MISCELLANEOUS SUPPORT.
*
SYMSCA	EQU  $
	MOV  @VCURCH,R5		SCAN SYMBOLIC NAME & CONVERT TO M39
	C    R5,@KMINLT  	IN V:SYM1 TO V:SYM3
	JLT  JTFAIL
	C    R5,@KMAXLT  	NAME MUST BEGIN WITH LETTER
	JLT  NTFAIL	 	N -- TAKE SYNTAX FAIL
JTFAIL	EQU  $
	B    @QSCSFA
NTFAIL	EQU  $
	LI   R5,CENTRA  	INITIALIZE POINTER TO CENTRAL
	MOV  R5,@PSYMBO
	LI   R5,-3		INITIALIZE SYMBOL WORD COUNT
	MOV  R5,@VCWORD
*
SYMSC1	EQU  $
	MOV  R5,@VCCHAR  	(RE)INITIALIZE LETTER PER WORD
	CLR  R5
	JMP  SYMSC7
*
SYMSC2	EQU  $
	MOV  R5,R4
	MPY  @K39,R4
*
SYMSC7	EQU  $
	MOV  @PSYMBO,R6
	MOV  R5,*R6
	MOV  @VCURCH,R5
*
* 	 NOTE:     0-9   IS M39 0-9
*		   A-Z   IS M39 10-35
*		   " "   IS M39 36
*		   $	 IS M39 37
*		   _	 IS M39 38
*
	LI   R6,CTABLE		CONVERSION TABLE
	MOV  R5,R3		SAVE CHARACTER
	SWPB R5
	LI   R2,3		CHECK 3 SPECIAL CHARACTERS FIRST
SPELOP	EQU  $
	CB   R5,*R6+
	JEQ  SPEOFF		BRIF SPECIAL CHAR
	DEC  R2
	JNE  SPELOP
	CB   R5,*R6+		< '0'?
	JLT  BADCHA		BRIF YES, BAD
	CB   R5,*R6+		> '9??
	JGT  CHKALP		BRIF YES, CHECK ALPHA
	AI   R3,->30		ZERO OFFSET TO GET MOD39 0-9
	JMP  CHACON
CHKALP	EQU  $
	CB   R5,*R6+		< 'A'?
	JLT  BADCHA		BRIF YES, BAD
	CB   R5,*R6+		> 'Z'?
	JGT  BADCHA
	AI   R3,->41+10 	ZERO OFFSET TO GET MOD39 10-36
	JMP  CHACON
SPEOFF	EQU  $
	MOV  R2,R3		USE INDEX INTO TABLE + OFFSET
	AI   R3,35		AS MOD39 INDEX
CHACON	EQU  $
	BL   @NEXTCH		ADVANCE TO NEXT CHAR ON GOOD CHAR
	JMP  SYMSC4
BADCHA	EQU  $			ON BAD CHARACTER, USE A BLANK
	LI   R3,36
SYMSC4	EQU  $
	MOV  R3,R5
	MOV  @PSYMBO,R6
	A    *R6,R5
	INC  @VCCHAR
	JNE  SYMSC2
*
	MOV  R5,*R6
	LI   R5,-3
	INCT @PSYMBO
	INC  @VCWORD
	JNE  SYMSC1
*
SYMSC5	MOV  @VCURCH,R5
	C    R5,@KMINLT
	JLT  B11ADV
	INC  @FLONGN
	BL   @NEXTCH
	JMP  SYMSC5
B11ADV	EQU  $
	B    *RET
*
*  NEXTCH : GET NEXT CHARACTER FROM INPUT STRING.
*
NEXTCH	EQU  $
	MOV  R11,R12		SAVE RETURN
	MOV  @VCURCH,@VLSTCH	SAVE CURRENT CHARACTER,
	MOV  @PCURCH,@PLSTCH	 AND LAST CHARACTER
*
*  IF SKIPPING BLANKS, DO UNTIL NON-BLANK CHARACTER ENCOUNTERED
*
NEXTC1	EQU  $
	MOV  @PCURCH,R2
	C    R2,@PRECCH		GET CURRENT POINTER
	JLT  NEXTC3		BRIF END OF RECORD
	A    @RTINPU,R2
	INCT R2			GET NEXT RECORD
	BL   @CONTNC
	JNE  NEXTC2		BRIF CONTINUATION LINE
*
	MOV  @ECARRN,@VCURCH	ELSE, NO CONTINUE, RETURN CR
	B    *R12
*
NEXTC2	EQU  $
	MOVB @KBLANS,*R2	CLEAR CONTINUATION IN CASE I BACK UP
	A    @K80,@PRECCH	IF CONTINUATION, THEN SKIP TO NEXT
	A    @K6,@PCURCH	 RECORD.
*
NEXTC3	EQU  $
	MOV  @RTINPU,R2		GOOD CHARACTER NEXT.  GET IT
	A    @PCURCH,R2
	INCT R2
	CLR  R5
	MOVB *R2,R5		HERE IT IS
	INC  @PCURCH		INCREMENT CHARACTER POINTER
	ABS  @FBLANK		SKIPPING BLANKS?
	JNE  NOTSKR		BRIF NO, JUST RETURN
*
	CB   R5,@KBLANS		IS THIS A BLANK ?
	JEQ  NEXTC1		BRIF YES, GET NEXT
*
	CB   R5,@EXCLA		ELSE, CHECK FOR COMMENT
	JNE  NOTSKA		BRIF NO, CHECK NEXT
	MOV  @PRECCH,@PCURCH	IT IS A COMMENT.  GO SCAN NEXT LINE
	JMP  NEXTC1
*
NOTSKA	EQU  $
	CB   R5,@ASCSMA		IS THIS A SMALL LETTER?
	JL   NOTSKR		BRIF NO
	CB   R5,@ASCSMZ
	JH   NOTSKR
	ANDI R5,>5F00		MASK OFFENDING BIT
*
NOTSKR  EQU  $
	SWPB R5			SAVE CHARACTER
	MOV  R5,@VCURCH		IN CURRENT CHARACTER
	B    *R12
*
*  CONTNC - CHECK NEXT CARD IMAGE FOR CONTINUATION, DEFINED BY THE
*           LABEL FIELD BEING BLANK, AND THE CONTINUATION COLUMN
*	    NON-ZERO AND NON-BLANK.
*
CONTNC	EQU  $
	MOV  @KBLANS,R5		GET A BLANK
	C    R5,*R2+		COLS 1 & 2
	JNE  NOTCTD
	C    R5,*R2+		COLS 3 & 4
	JNE  NOTCTD
	CB   R5,*R2+		COL 5
	JNE  NOTCTD
	CB   R5,*R2		COL 6 (BLANK?)
	JEQ  NOTCTD
	CB   R5,@ASC0		COL 6 (ZERO?)
	JEQ  NOTCTD
	LI   R5,1		SET CONTINUATION
	B    *R11		IS A CONTINUATION
NOTCTD	EQU  $
	LI   R5,0		SET NO CONTINUATION
	B    *R11
*
*  TAILST - TAIL START ROUTINE.  RECORD START LOCATION OF TAIL
*	    FOR FORTRAN 3.
*
TAILST	EQU  $
	BL   @PUNCH
	MOV  @RTBUFF,R5
	S    @RABUFF,R5 	DISP WITHIN RECORD
	MOV  R5,@PTAILR
	MOV  @PS2,@PTAIRS 	RELATIVE RECORD
	B    @INTER1
*
*  P2INIT - INITIATE PHASE 2 OF THE FORTRAN COMPILER
*
P2INIT	EQU  $
	LIMI 2			RESTORE INTERRUPTS
	BL   @PUNCH		INITIATE PASS 2 OF COMPILER
	MOV  @RBBUFF,R5
	S    @RABUFF,R5 	OUTPUT LAST BLOCK OF CODE
	JEQ  P2INI1		( IF ANY )
	MOV  R5,@VS2BYT 	COMPUTE REMAINING BYTE COUNT
	MOV  @RABUFF,R5
	INCT R5
	MOV  R5,@PS2BUF 	SET POINTER TO BUFFER
	LI   R4,S2PUNC
	BLWP @FIOC		DO IO
	JEQ  P2INI1
	B    @IOABOR		ELSE, ABORT
*
P2INI1	EQU  $
	MOV  @VX2SIZ,@VS2BYT
	MOV  @KFOUR,@ALNUMB
	LI   R4,ALCLOS
	BLWP @FIOC
	INC  @ALNUMB		NOW CLOSE FILE 5 (SCRATCH #2)
	BLWP @FIOC
	B    @FORT3		EXECUTE FORTRAN3
	TITL 'GENERATE CONSTANTS'
	PAGE
*
*  GENFLC - GENERATE FLOATING POINT CONSTANT.   THIS ROUTINE SCANS A
*	    INTEGER, SINGLE PRECISION, OR DOUBLE PRECISION FLOATING
*	    POINT NUMBER.   THE ALGORITHM SCANS THE ASCII CHARACTERS
*	    FOLLOWING, AND MOVES THE CORRESPONDING CHARACTERS TO THE
*	    INTERNAL STRING "RESSTR".  VARIOUS CONVERSIONS, SUCH AS
*	    THE "D" EXPONENT FORM TO "E" EXPONENT FORM, ARE HANDLED
*	    AS THE STRING IS MOVED.  THE ".E" EXPONENT FORM IS ALSO
*	    CHECKED TO MAKE SURE THIS IS NOT PART OF A ".EQ." SEQ-
*	    UENCE.
*
*	    ONCE ALL OF THE STRING HAS BEEN MOVED, A CHECK IS MADE
*	    TO SEE IF A DECIMAL POINT, "E", OR "D" WAS DETECTED. IF
*	    NOT, THEN THE TYPE IS ASSUMED TO BE INTEGER, AND THE
*	    INTSCA ROUTINE (INTEGER SCAN) IS CALLED TO CONVERT THE
*	    STORED STRING INTO AN INTEGER NUMBER.  THE INTEGER
*	    NUMBER IS LEFT IN VDATA4.
*
*	    FLOATING POINT NUMBER STRINGS ARE COPIED TO VDP RAM, AND
*	    THE TI CONSOLE CONVERT STRING TO FAC ROUTINE IS CALLED.
*	    UPON RETURN, THE NUMBER IS THEN MOVED TO VDATA1 TO VDATA4.
*
*	    ROUTINE CODED INLINE RATHER THAN WITH PSEUDO OPS MAINLY
*	    FOR SPEED.
*
GENFLC	EQU  $
	CLR  @FSINGL		ASSUME DOUBLE TIL SINGLE DETECTED
	LI   R14,RESSTR 	MOVE CHARS FROM INPUT STACK TO
	CLR  *R14+		TO STRING
	MOV  @VGENID,R1		ANY CHARACTER WAITING?
	CLR  @VGENID
	JNE  GENFL1		BRIF YES, USE VGENID CHARACTER
	MOV  @VCURCH,R1		ELSE, USE VCURCH
GENFL1	EQU  $
	BL   @GETCS1		GET THE CHARACTER
LOPPCH	EQU  $
	JLT  NOTDIG		BRIF YES
	CB   R1,*R12+		IS IT <=9
	JGT  NOTDIG		BRIF NO
	BL   @SAVEDI		SAVE DIGIT IN STRING
	BL   @GETCST		GET NEXT CHARACTER
	JMP  LOPPCH
*
NOTDIG	EQU  $
	LI   R12,IDIGIT+2	CHECK MORE CHARACTERS
	MOV  @PLSTCH,R15  	SAVE LAST CHAR POS
	CB   R1,*R12+		IS IT A PERIOD?
	JEQ  CONST1		YES, POSSIBLE REAL
	CB   R1,*R12+		IS IT A 'D'?
	JEQ  CONST3		YES, DOUBLE REAL
	CB   R1,*R12+		IS IT AN 'E'?
	JEQ  CONST3
	JMP  CONST2		INTEGER OTHERWISE
*
CONST1	EQU  $			PERIOD, MAY OR MAY NOT BE DECPT
	BL   @GETCST		GET CONSTANT W/FIRST COMPARE
	JLT  NOTDI1		BRIF NOT DIGIT
	CB   R1,*R12+		<= '9'?
	JLT  CONS3A		BRIF A DIGIT
	JEQ  CONS3A
NOTDI1	EQU  $
	LI   R12,ADIGIT
	CB   R1,*R12+		;  , 'A' ?
	JL   CONS3A		NON ALPHA, IS DECPT
	CB   R1,*R12+
	JH   CONS3A		BRIF NON-ALPHA
	CB   R1,*R12+		IS IT A 'D'?
	JEQ  CONS3A		YES, IS DECIMAL POINT
	CB   R1,*R12+		IS IT AN 'E'?
	JNE  RESETO		NO, MUST BE RELATIONAL
	BL   @GETCST		GET NEXT CHARACTER
	CB   R1,@QEQ+1		IS IT RELATIONAL OP .EQ.?
	JEQ  RESETO		BRIF YES
	MOV  R15,@PCURCH	OTHERWISE, RESTORE POINTER
	BL   @GETCST
	BL   @GETCST
	JMP  CONS3A
*
RESETO  EQU  $
	MOV  R15,@PCURCH   	ELSE, RESTORE POINTER
	BL   @GETCST
	JMP  CONST2
*
CONST2	EQU  $			INTEGER CONSTANT
	CLR  R1
	MOVB R1,*R14		SET TERMINATOR
	INCT @RESSTR
	JMP  INTSCA
*
CONS3A	EQU  $			DECPT, SAVE ONE
	MOV  R1,R3
	MOVB @KDEC,R1		SAVE DECIMAL POINT
	BL   @SAVEDI
	MOV  R3,R1
*
CONST3	EQU  $
	LI   R12,IDIGIT		IS IT A DIGIT?
	CB   R1,*R12+
	JLT  NOTDI3		BRIF NO
	CB   R1,*R12+
	JGT  NOTDI3
*
ISDI3	EQU  $
	BL   @SAVEDI		SAVE A DIGIT
	BL   @GETCST		GET NEXT CHARACTER
	JMP  CONST3
*
NOTDI3  EQU  $
	LI   R12,KLETD		GET OFFSET AGAIN
	CB   R1,*R12+		IS IT A 'D'?
	JEQ  REAL1		BRIF YES
	CB   R1,*R12+		IS IT AN 'E'?
	JEQ  REAL0
	JMP  REAL2		NO EXPONENT
*
REAL0 	EQU  $
	BL   @EXPONS		SCAN EXPONENT
REAL2 	EQU  $
	INC  @FSINGL		SET SINGLE PRECISION ARGUMENT
	JMP  ENDTAB
*
REAL1	EQU  $
	BL   @EXPONS		SCAN EXPONENT
*
ENDTAB	EQU  $
	CLR  R1
	MOVB R1,*R14		SET TERMINATOR
	INCT @RESSTR
	BLWP @SCSN		CONVERT STRING TO NUMBER
	JNE  DOOVE1		BRIF OVERFLOW/ERROR
	LI   R1,FAC		MOVE FAC TO VDATA1
	LI   R2,VDATA1  	TO LOCAL AREA
	ABS  @FMINUS		WANT MINUS ?
	JEQ  DOPLUS		BRIF NO
	NEG  @FAC		2'S COMPLEMENT FAC
DOPLUS	EQU  $
	MOV  *R1+,*R2+		MOVE 1ST TWO WORDS
	MOV  *R1+,*R2+
	MOV  *R1+,*R2+
	MOV  *R1,*R2
	MOV  @FSINGL,R4		GET SINGLE/DOUBLE FLAG
	JEQ  BSETDP		SET DOUBLE PRECISION
	B    @SETSPT
BSETDP	B    @SETDPT
*
DOOVE1	EQU  $
	B    @DOOVER
*
*  INTSCA - SCAN INTEGER DIGITS.  CONVERTS A STRING OF INTEGER
*	    DIGITS IN THE CPU RAM BUFFER 'RESSTR' TO AN INTEGER
*	    BINARY DOUBLE WORD.  RESULT IS LEFT IN R4,R5.  IF THE NUMBER
*	    IS GREATER THAN MAXIMUM, THEN THE NUMBER FAIL IS TAKEN.
*
INTSCA  EQU  $
	CLR  R4			CLEAR DOUBLE WORD RESULT
	CLR  R5
	LI   R6,RESSTR		STRING START
	INCT R6
INTLOP  EQU  $
	CLR  R1
	MOVB *R6+,R1		GET THE NEXT CHARACTER
	JEQ  INTDO1		ZERO MEANS I'M DONE
	BL   @SHIFTD		MULTIPLY *2
	MOV  R4,R0		SAVE *2 VALUE
	MOV  R5,R2
	BL   @SHIFTD		*4
	BL   @SHIFTD		*8
	A    R0,R4		DOUBLE WORD ADD *2
	A    R2,R5
	JNC  INTLO1
	INC  R4
INTLO1	EQU  $
	MOV  R4,R4		DID I OVERFLOW?
	JLT  DOOVE1		BRIF YES
	SB   @LETTE0,R1		SUBTRACT ASCII ZERO
	SWPB R1
	A    R1,R5		DOUBLE WORD ADD IT IN
	JNC  INTLOP
	INC  R4
	JMP  INTLOP
*
*  SCANNED ALL DIGITS, SEE IF NEGATIVE VALUE EXPECTED
*
INTDO1  EQU  $
	LI   R2,VDATA3		SET INTEGER *4 RESULT
	ABS  @FMINUS		DID I WANT MINUS?
	JEQ  INTPLU		BRIF NO
	INV  R5
	INV  R4
	INC  R5			DOUBLE WORD NEGATE
	JNC  INTCNT		BRIF NO OVERFLOW INTO SECOND WORD
	INC  R4
INTCNT	EQU  $
	MOV  R4,*R2+
	MOV  R5,*R2
	CI   R4,-1		IS TOP WORD ALL 'F'S?
	JNE  SETI4T		BRIF NO, MUST BE INTEGER *4
	MOV  R5,R5		DID BOTTOM WORD REMAIN NEGATIVE?
	JLT  SETI2T		BRIF YES, FITS IN INTEGER *2
	JMP  SETI4T		ELSE, ITS AN INTEGER *4
INTPLU	EQU  $
	MOV  R4,*R2+
	MOV  R5,*R2
	MOV  R4,R4		TOP WORD ZEROED?
	JNE  SETI4T		BRIF NO, MUST BE INTEGER *4
	MOV  R5,R5		BOTTOM WORD NEGATIVE?
	JLT  SETI4T		BRIF YES, MUST BE INTEGER *4
	JMP  SETI2T		ELSE, INTEGER *2
*
*  HEXSCA - CONVERT HEX DIGITS.  CONVERTS UP TO 16 HEXADECIMAL
* 	    DIGITS INTO AN INTEGER, SINGLE PRECISION, DOUBLE
*	    PRECISION NUMBER.   IF MORE THAN 16 DIGITS ARE
*	    SPECIFIED, THEN A SYNTAX ERROR IS GENERATED.
*
HEXSCA	EQU  $			HEX SCAN ROUTINE
	BL   @CONSET		SETUP
DHXTIN	EQU  $
	MOV  @VCURCH,R12
	LI   R6,CDIGIT		DIGITS TO COMPARE
	SWPB R12
	CB   R12,*R6+		< 0 ?
	JLT  NHXDIG
	CB   R12,*R6+		< 9 ?
	JLT  HXDIG
	CB   R12,*R6+		< A ?
	JLT  NHXDIG
	CB   R12,*R6
	JGT  NHXDIG
	AI   R12,->3700		ZERO OFFSET
	JMP  DHXCOM
HXDIG 	EQU  $
	SB   @LETTE0,R12
DHXCOM	EQU  $
	SWPB R12
	LI   R6,VDATA4
	CLR  R4			SHIFTED OUT DIGIT SAVE
	CLR  R2			COUNTER
SHIFTN	EQU  $
	MOV  *R6,R5		GET LAST WORD
	SRC  R5,16-4		SHIFT LEFT 1 NIBBLE
	MOV  R5,R3		SAVE SHIFTED VALUE
	ANDI R5,>F		MASK SHIFTED OUT DIGIT VALUE
	ANDI R3,>FFF0		MASK SHIFTED VALUE
	SOC  R4,R3		OR IN LAST SHIFTED OUT DIGIT
	MOV  R3,*R6		AND SAVE
	MOV  R5,R4		SAVE SHIFTED DIGIT
	DECT R6
	INC  R2
	CI   R2,4		DONE ?
	JNE  SHIFTN		BRIF NO
	SOC  R12,@VDATA4  	OR IN DIGIT
	INC  @RESSTR		INC # DIGITS
	MOV  @RESSTR,R5
	CI   R5,>16		TOO MANY DIGITS ?
	JGT  DOOVER
	BL   @NEXTCH
	JMP  DHXTIN
NHXDIG	EQU  $
	LI   R4,HEXMAP		HEXADECIMAL DIGITS MAP LENGTH
NHXDI1	EQU  $
	MOV  @RESSTR,R5
	JEQ  GENSYN		BRIF NOTHING SPECIFIED
	C    R5,*R4+		< 3 DIGITS?
	JLT  SETI1T		SET BYTE TYPE
	C    R5,*R4+		< 5 DIGITS?
	JLT  SETI2T		SET INTEGER *2 TYPE
	C    R5,*R4		< 9 DIGITS?
	JLT  SETI4T		SET INTEGER *4 TYPE
	JMP  SETDPT		ELSE, MUST BE DOUBLE PRECISION
*
*  ON EXIT FROM HERE, THE VALUES MUST BE PLACED AS FOLLOWS ACCORDING
*  TO DATA TYPE:
*
*	INTEGER *1		: VDATA3
*	INTEGER *2		: VDATA3
*	INTEGER *4		: VDATA1, VDATA2
*	SINGLE PRECISION	: VDATA1, VDATA2
*	DOUBLE PRECISION	: VDATA1, VDATA2, VDATA3, VDATA4
*
*				INTEGER *4 TYPE
SETI4T	EQU  $
	MOV  @VDATA3,@VDATA1	MOVE DOUBLE WORD RESULT
	MOV  @VDATA4,@VDATA2
	LI   R5,I4TYPE		SET INTEGER *4 RESULT
	JMP  SRETUR
*				INTEGER *2 TYPE
SETI2T	EQU  $
	MOV  @VDATA4,@VDATA3
	LI   R5,INTYPE		SET INTEGER *2 RESULT
	JMP  SRETUR
*
SETI1T	EQU  $
	MOV  @VDATA4,R5
	SLA  R5,8		SET INTEGER *1 RESULT
	MOV  R5,@VDATA3
	LI   R5,BYTYPE
	JMP  SRETUR
*
SETSPT	EQU  $
	LI   R5,SPTYPE		SINGLE PRECISION TYPE
	JMP  SRETUR
*				DOUBLE PRECISION TYPE
SETDPT	EQU  $
	LI   R5,DPTYPE
	JMP  SRETUR
*
DOOVER	EQU  $			NUMBER OVERFLOW ERROR
	MOV  @ZNUMBE,R5
	B    @INTERP
*
GENSYN	EQU  $
	MOV  @ZSYNTA,R5		SYNTAX ERROR
	B    @INTERP
*
*  BINSCA - CONVERT OCTAL DIGITS.   CONVERTS UP TO 64 BINARY DIGITS
*	    INTO AN INTEGER, A SINGLE PRECISION, OR A DOUBLE PRECISION
*	    NUMBER.  IF MORE THAN 64 DIGITS ARE SPECIFIED, THEN AN
*	    ERROR IS GENERATED.
*
BINSCA	EQU  $			BINARY SCAN ROUTINE
	BL   @CONSET
DOBIIN	EQU  $
	MOV  @VCURCH,R12
	CI   R12,>0030		IS IT A ZERO?
	JLT  NOBDIG
	CI   R12,>0031		IS IT A ONE?
	JGT  NOBDIG
	AI   R12,->0030		ELSE, SUBTRACT ASCII ZERO
	BL   @SHIFTB
	SOC  R12,@VDATA4	SET THIS BINARY WORD
	INC  @RESSTR		INC # DIGITS
	MOV  @RESSTR,R5
	CI   R5,64		TOO MANY DIGITS ?
	JGT  DOOVER
	BL   @NEXTCH		GET NEXT CHARACTER
	JMP  DOBIIN		AND DO IT AGAIN
NOBDIG  EQU  $
	LI   R4,BITMAP		BIT LENGTHS MAP
	JMP  NHXDI1		GO PARSE IT
*
*
*  OCTSCA - CONVERT OCTAL DIGITS.  CONVERTS UP TO 22 OCTAL DIGITS
*	    INTO AN INTEGER, SINGLE PRECISION, OR DOUBLE PRECISION
*	    NUMBER.  IF MORE THAN 22 DIGITS ARE SPECIFIED (OR THE
*	    22ND TOP MOST DIGIT IS GREATER THAN ONE) THEN AN ERROR
*	    IS GENERATED.
*
OCTSCA	EQU  $			OCTAL SCAN ROUTINE
	BL   @CONSET		CONVERT SETUP
DOCTIN	EQU  $
	MOV  @VCURCH,R12
	LI   R6,ODIGIT		DIGITS TO COMPARE
	SWPB R12
	CB   R12,*R6+		< 0 ?
	JLT  NOCDIG
	CB   R12,*R6+		< 7 ?
	JGT  NOCDIG
	AI   R12,->3000
	SWPB R12
	BL   @SHIFTB		SHIFT 3 BITS
	BL   @SHIFTB
	BL   @SHIFTB
	SOC  R12,@VDATA4	SET THIS OCTAL WORD
	INC  @RESSTR		INC # DIGITS
	MOV  @RESSTR,R5
	CI   R5,22		TOO MANY DIGITS ?
	JGT  DOOVER
	BL   @NEXTCH		GET NEXT CHARACTER
	JMP  DOCTIN		AND DO IT AGAIN
NOCDIG  EQU  $
	LI   R4,OCTMAP		OCTAL MAP OF DIGITS
	MOV  @RESSTR,R5		GET # DIGITS SPECIFIED
	JEQ  GENSYN		BRIF NOTHING SPECIFIED (ERROR)
	C    R5,*R4+		DOES IT FIT IN A BYTE
	JLT  SETI1T		IF < 3 DIGITS, IT IS AN INTEGER *1
	JNE  NOCDI1		IF > 3 DIGITS, IT IS NOT AN INTEGER *1
	MOVB @VDATA4,R6		ELSE, GET THE VALUE
	JEQ  SETI1T		BRIF NO, INTEGER *1
*
NOCDI1	EQU  $
	C    R5,*R4+		IS IT AN INTEGER *2?
	JLT  SETI2T		IF < 6 DIGITS, IT IS AN INTEGER *2
	JNE  NOCDI2		IF > 6 DIGITS, IT IS NOT AN INTEGER *2
	MOV  @VDATA3,R6		ELSE, DOES IT FIT IN A WORD?
	JEQ  SETI2T		YES, IT'S AN INTEGER *2
*
NOCDI2	EQU  $
	C    R5,*R4+		IS IT AN INTEGER *4?
	JLT  SETI4T		IF < 11 DIGITS, IT IS AN INTEGER *4
	JNE  SETDPT		IF > 11 DIGITS, IT IS A DOUBLE PRECISION
	MOV  @VDATA2,R6		DID IT FIT IN TWO WORDS?
	JEQ  SETI4T		BRIF YES
	JMP  SETDPT		ELSE, NO, DOUBLE PRECISION
*
SRETUR	EQU  $
	CLR  @FMINUS		CLEAR MINUS FLAG (FOR NEXT VALUE)
	MOV  R5,@FSINGL		SET FLAG FOR INTERPRETIVE PROGRAM
	LI   R2,RWORK
	BL   @PUTONB		PUT TAG TYPE ON WORK STACK
	B    @INTER1
*
*  EXPONS - EXPONENT SCAN.  CALLED AFTER A 'D' OR 'E' IS PARSED
*
EXPONS	EQU  $			SCAN EXPONENT
	MOV  R11,@SA7R11  	SAVE RETURN VECTOR
	MOVB @KLETE,R1		SAVE 'E' IN STRING FOR EXPONENT
	BL   @SAVEDI		SAVE CHARACTER
	BL   @GETCST		GET NEXT CHARACTER
	LI   R12,EMINUS
	CB   R1,*R12+		IS IT A MINUS?
	JEQ  ISDI4		BRIF YES
	CB   R1,*R12+		IS IT A PLUS?
	JEQ  ISDI4		BRIF YES
*
EXPON2	EQU  $
	LI   R12,IDIGIT
	CB   R1,*R12+		IS THIS A NUMBER?
	JLT  EXEXPO		BRIF NO
	CB   R1,*R12+
	JGT  EXEXPO		BRIF NO
*
ISDI4	EQU  $			IS A DIGIT, SAVE DIGIT
	BL   @SAVEDI
	BL   @GETCST
	JMP  EXPON2
*
EXEXPO	EQU  $
	MOV  @SA7R11,R11  	RESTORE RETURN VECTOR
	B    *R11	  	RETURN
*
*  SAVEDI - SAVE DIGIT IN STRING 
*
SAVEDI	EQU  $			SAVE CHAR IN STRING
	CI   R14,TABEND
	JEQ  DOOVE2		DIGIT OVERFLOW
	MOVB R1,*R14+		SAVE CHAR IN STRING
	INC  @RESSTR
	B    *R11
DOOVE2	B    @DOOVER
*
*  GETCST - GET A CHARACTER, MOVE TO R1 HIGH BYTE, AND COMPARE WITH
*	    AN ASCII ZERO.
*
GETCST  EQU  $
	MOV  R11,@SAVGCS	SAVE RETURN
	BL   @NEXTCH		GET NEXT CHARACTER
	MOV  @SAVGCS,R11	RESTORE RETURN
	MOV  @VCURCH,R1		GET IT
GETCS1	EQU  $
	SWPB R1
	LI   R12,IDIGIT		GET DIGIT
	CB   R1,*R12+		DO FIRST COMPARE
	B    *R11		RETURN
*
*  CONSET - CONVERSION ROUTINE SETUP
*
CONSET	EQU  $
	LI   R6,VDATA1
	CLR  *R6+
	CLR  *R6+
	CLR  *R6+
	CLR  *R6
	CLR  @RESSTR		# DIGITS READ
	B    *R11
*
*  SCSN- Convert String to Number routine.  This routine is called
*        instead of the low memory routine since the low memory
*        routine does not work well on the Geneve.
*
SCSN	EQU  $			ENTRY INTO ROUTINE
	DATA IOTWSP
	DATA ECSN
*
ECSN	EQU  $			CONVERT STRING TO NUMBER
	LI   R5,FAC		Clear result
	CLR  *R5+		5 words (4 plus overflow)
	CLR  *R5+
	CLR  *R5+
	CLR  *R5+
	LI   R6,RESSTR		Fetch address
	INCT R6			Set start
	MOVB *R6+,R8		Get the byte
	SRL  R8,8		in lbyte R8
	CLR  @MINUSF
	MOV  R6,R2
	CI   R8,>002B		ASCII +
	JEQ  CSNPLU
	CI   R8,>002D		ASCII -
	JNE  CSNMIN		No sign
	SETO @MINUSF
CSNPLU	EQU  $
	INC  R2			Fix length
CSNPL1	EQU  $
	MOVB *R6+,R8		Get byte
	SRL  R8,8		in low byte
CSNMIN	EQU  $
	CI   R8,>0030		0?
	JEQ  CSNPL1		Yes, skip it
	MOV  R6,R12		Save string start
	DEC  R12		right address
	SETO R7
	JMP  CSNCO2
CSNCO1	EQU  $
	INC  R7
	MOVB *R6+,R8		Get character
	SRL  R8,8		in low byte
CSNCO2	EQU  $
	CI   R8,>0030		Compare, if character 0 through 9
	JL   CSNPTO
	CI   R8,>0039
	JLE  CSNCO1		Get another character
CSNPTO  EQU  $
	CI   R8,>002E		Decimal Point?
	JNE  CSNCO6
	INC  R2			Compute digit left of point
	MOV  R7,R7
	JLT  CSNCO4
	JMP  CSNC4A
CSNCO3	EQU  $
	DEC  R7
CSNCO4	EQU  $
	MOVB *R6+,R8
	SRL  R8,8		Get a character
	CI   R8,>0030		0?
	JEQ  CSNCO3
	DEC  R6
	MOV  R6,R12
CSNC4A  EQU  $
	MOVB *R6+,R8
	SRL  R8,8
	CI   R8,>0030
	JL   CSNCO5
	CI   R8,>0039
	JLE  CSNC4A
CSNCO5	EQU  $
	C    R6,R2		End of number
	JEQ  CSNRD2		Set zero
CSNCO6	EQU  $
	MOV  R6,R2
	CLR  R4
	DEC  R2			Correction
	CLR  R1
	CI   R8,>0045		'E' for Exponent?
	JNE  CSNEX3
	MOVB *R6+,R8
	SRL  R8,8		Get next character
	CI   R8,>002B		Sign of exponent (+)
	JEQ  CSNEX2
	CI   R8,>002D		(-)
	JNE  CSNEX1
	DEC  R1
	JMP  CSNEX2
CSNEX1	EQU  $
	DEC  R6
CSNEX2  EQU  $
	BL   @CSNINT		Convert integer exponent
	MOVB R1,R1		Negative number
	JEQ  CSNEX3
	NEG  R4
CSNEX3	EQU  $
	DEC  R6
	MOV  R6,@CSNPTR
	C    R12,R2
	JEQ  CSNRD2		Set FAC=0 and return
	AI   R4,>0080		Correct Exponent
	CLR  R1
	A    R7,R4
	MOV  R4,R7
	SRA  R4,1		Exponent :2, Bias 100!
	MOV  R4,@EXPONF
	SRC  R7,1
	LI   R5,>0008		8 digits of the number
	LI   R0,FAC+1
	MOV  R12,R6		Address, begin number in R5
CSNDO1	EQU  $
	C    R6,R2
	JEQ  CSNDO4		Brif done
	MOVB *R6+,R8
	SRL  R8,8
	CI   R8,>002E		Point?
	JEQ  CSNDO1		Next character.
	AI   R8,>FFD0		ASCII Correction
	INV  R7
	JLT  CSNDO3
CSNDO2	EQU  $
	MPY  @K10,R8		*10
	CLR  R1
	SWPB R9
	MOVB R9,R1		R9 Lbyte in R1
	JMP  CSNDO1
CSNDO3	EQU  $
	SWPB R8
	AB   R8,R1		R8 Lbyte add to R1
CSNDO4  EQU  $
	MOVB R1,*R0+		R1 on FAC
	CLR  R1
	DEC  R5			All digits
	JNE  CSNDO1
CSNDON	EQU  $			Rounding and done
	LI   R0,>3200		Decimal 50
	C    @FAC+8,R0		Compare
	JLT  CSNRD1
	LI   R1,7
	LI   R2,>0100
	LI   R0,>6400		Decimal 100
CSNRD0	EQU  $
	AB   R2,@FAC(R1)
	CB   @FAC(R1),R0
	JL   CSNRD1		Smaller 100, then end
	SB   R0,@FAC(R1)	Minus 100	
	DEC  R1
	JGT  CSNRD0
	INC  @EXPONF		Increase Exponent
	MOVB R2,@FAC+1		1 on first digit
CSNRD1	EQU  $
	MOV  @EXPONF,R3		Fetch Exponent
	CI   R3,>0080		Too big?
	JHE  CSNERR		Error, number too big
	SWPB R3
	MOVB R3,@FAC		Set exponent
	MOV  @MINUSF,R2
	JEQ  CSNRD2
	NEG  @FAC		Negate Number
CSNRD2	EQU  $
	LI   R1,0		Return no error
	JMP  CSNRD3
CSNERR	EQU  $
	LI   R1,1		Return error
CSNRD3	EQU  $
	STST R15
	RTWP			Return
*
*  CSNINT - Convert String to Number, Convert Exponent
*
CSNINT	EQU  $
	CLR  R4
	CLR  R0
	MOV  R11,R9		Save return
	JMP  CSNIN1
CSNIN0	EQU  $
	MPY  @K10,R4		*10
	MOV  R4,R4		Overflow?
	JNE  CSNERR		brif yes, its an error
	INC  R0
	A    R8,R5
	MOV  R5,R4
	JLT  CSNERR		Negative, error
CSNIN1	EQU  $
	MOVB *R6+,R8		Get a character
	SRL  R8,8
	AI   R8,>FFD0		Ascii correction
	CI   R8,10		Smaller 10?
	JL   CSNIN0		No, go on
	MOV  R0,R0
	JEQ  CSNERR		Overflow
	B    *R9		Return
*
*  SHIFTD - SHIFT R4 AND R5 LEFT BY A BIT
*
SHIFTD	EQU  $
	SLA  R4,1		* 2
	SLA  R5,1
	JNC  SHIFTR		BRIF NO CARRY BIT OVERFLOWED
	INC  R4
SHIFTR	EQU  $
	B    *R11
*
*  SHIFTB - SHIFT THE FOUR WORD TEMP AREA LEFT BY A BIT
*
SHIFTB  EQU  $
	MOV  @VDATA1,R5		TOP WORD
	SLA  R5,1
	MOV  R5,@VDATA1
	MOV  @VDATA2,R5
	SLA  R5,1
	MOV  R5,@VDATA2
	JNC  SHIFT1
	A    @KONE,@VDATA1
SHIFT1  EQU  $
	MOV  @VDATA3,R5
	SLA  R5,1
	MOV  R5,@VDATA3
	JNC  SHIFT2
	A    @KONE,@VDATA2
SHIFT2  EQU  $
	MOV  @VDATA4,R5
	SLA  R5,1
	MOV  R5,@VDATA4
	JNC  SHIFT3
	A    @KONE,@VDATA3
SHIFT3  EQU  $
	B    *R11
	TITL 'MISC. ROUTINES'
*
*  OPSTAX: IS CALLED TO SAVE AN OPTION FLAG BASED ON
*	   INTERPRETER PARSE.
*
OPSTAX	EQU  $
	MOV  *RBW,R2		GET WORK POINTER
	MOV  *R2,R5		GET FLAG #
	SLA  R5,1		*2
	AI   R5,FOPT
	INC  *R5		SET FLAG
	B    *R11		GOTO NEXT INSTR
*
*  DRIVEX - EXECUTE INTERPRETER DRIVING TABLE ROUTINE.
*
*  CALLED TO EXECUTE A DRIVING TABLE BASED ON THE INDEX IN VTEMP1.
*  THE START OF THE DRIVING TABLE IS IN PLOCN.
*
DRIVEX	EQU  $
	MOV  @VTEMP1,R0
	S    @KMAXPT,R0 	COMPUTE BRANCH LOCATION
	SLA  R0,1
	A    @PLOCN,R0  	OFFSET FROM CURRENT LOCATION
	UNL
	IF   GENEVE
	LIST
	MOV  *R0,R1		GET LOCATION
	ELSE
	LIST
	SWPB R0	    		SET VDP RAM LOCATION
	MOVB R0,@VDPWA
	SWPB R0
	MOVB R0,@VDPWA
	NOP
	MOVB @VDPRD,R1  	GET LOCATION TO BRANCH TO
	SWPB R1
	MOVB @VDPRD,R1
	SWPB R1
	ENDIF
	SLA  R1,1
	A    @POP,R1
	DECT R1
	MOV  R1,@PLOCN
	B    *R11		EXECUTE INTERPRETIVE LOOP
*
*  MINI-DEBUGGER -  The MINI debugger for the FORTRAN2 code
*
*  The following commands are accepted:
*
*	B XXXX   -  Install a breakpoint at the specified VDP loc
*	I XX     -  Inspect ROLL number XX
*       D XXXX   -  Inspect variable XXXX (relative location)
*	Q        -  Quit
*	T 0/1    -  Trace OFF or ON
*
MININI  EQU  $
	CLR  @TRACE		CLEAR TRACE OR NOT
	CLR  @SNAPLO		CLEAR SNAP LOCATION
MINI	EQU  $
	MOV  R11,@SAVDEB	SAVE DEBUGGER RETURN
	BL   @WRDATA		PRINT HEADER
	DATA MINDEB		FOR MINI DEBUGGER
GETCOM  EQU  $
	LI   R3,6		SIZE OF COMMAND BUFFER
	LI   R4,GETBUF
	BLWP @CSCRI$		GET THE USER COMMAND
	LI   R0,GETBUF		BUFFER ADDRESS
	CLR  R1
	MOVB *R0+,R1		GET # BYTES MOVED
	JEQ  GETCOM		BRIF NONE
	SWPB R1
	CLR  R2			GET COMMAND ENTERED
	MOVB *R0+,R2
	DEC  R1
	LI   R4,MYCOMM		MY LIST OF COMMANDS
	LI   R6,COMLIS
SRCHIT  EQU  $
	MOVB *R4+,R5		GET THE NEXT COMMAND
	JEQ  DOWHAT		NOT FOUND
	CB   R5,R2		IS THIS THE COMMAND?
	JEQ  SRCHDO		BRIF YES
	INCT R6
	JMP  SRCHIT		TRY AGAIN
DOWHAT  EQU  $
	BL   @WRDATA
	DATA WHAT		DON'T UNDERSTAND COMMAND
	JMP  GETCOM
*				CONVERT THE HEX ARGUMENT INTO R5
SRCHDO  EQU  $
	CLR  R5			CLEAR RESULT
TOHEX1  EQU  $
	MOV  R1,R1		ANY CHARACTERS LEFT?
	JEQ  TOHEXR		BRIF NO
	CLR  R2
	MOVB *R0+,R2		GET THE NEXT CHARACTER
	DEC  R1
	CB   R2,@BLANK		IS IT A BLANK?
	JEQ  TOHEX1
TOHEX2  EQU  $
	SWPB R2
	AI   R2,->0030		SUBTRACT OUT A ZERO
	JLT  TOHEXR		ERROR
	CI   R2,10		GREATER THAN NINE?
	JLT  TOHEX3
	AI   R2,-7		ADD OFFSET TO HEX A THRU F
TOHEX3	EQU  $
	SLA  R5,4
	A    R2,R5
	DEC  R1			ANY CHARACTERS LEFT?
	JLT  TOHEXR		BRIF NO
	CLR  R2
	MOVB *R0+,R2		GET NEXT CHARA
	JMP  TOHEX2
TOHEXR  EQU  $
	MOV  *R6,R6		GET COMMAND ADDRESS
	B    *R6		DO IT
*
*  COMMAND LIST JUMP TABLE VECTOR
*
COMLIS  EQU  $
	DATA FUNCB		BREAKPOINT INSTALL #
	DATA FUNCI		INSPECT ROLL #
	DATA FUNCD		DISPLAY VARIABLE #
	DATA FNCT		TRACE ON OR OFF
	DATA FUNCQ		RETURN TO USER
*
*  B - BREAKPOINT INSTALL
*
FUNCB	EQU  $
	MOV  R5,@SNAPLO		SAVE IT
	JMP  GETCOM
*
*  I - INSPECT ROLL #
*
FUNCI	EQU  $
	BL   @DISSTA		DISPLAY STACK #
	JMP  GETCOM
*
*  D - DISPLAY VARIABLE
*
FUNCD	EQU  $
	SLA  R5,1		OFFSET IT NORMALLY
	AI   R5,VARIAB
	MOV  R5,R2		SAVE A COPY
	BL   @PRINTH		DISPLAY THE LOCATION
	MOV  *R2,R5		GET VALUE
	BL   @PRINTH		DISPLAY IT
	BL   @WRDATA		END WITH CARRIAGE RETURN
	DATA STLOCR
	JMP  GETCOM  
*
*  T - TRACE ON OR OFF
*
FNCT	EQU  $
	MOV  R5,@TRACE
	JMP  GETCOM
*
*  Q - QUIT, RETURN TO USER
*
FUNCQ	EQU  $
	MOV  @SAVDEB,R11
	B    *R11
*
*  DEBUGC - THIS CODE IS ENTERED AS PART OF THE INTERPRETIVE
*	    LOOP.  IT PERFORMS THE FOLLOWING FUNCTIONS:
*
*	1. IF THE TRACE IS ENABLED (VIA THE TRACE FLAG), THEN
*	   THE CURRENT LOCATION AND THE WORK ROLL ARE DISPLAYED
*	   AS EACH IS EXECUTED.
*	2. THE CURRENT LOCATION IS COMPARED AGAINST THE "SNAPPED"
*	   LOCATION.  IF THEY ARE THE SAME, THEN THE TRACE IS
*	   PERFORMED REGARDLESS OF THE TRACE FLAG, AND THE
*	   DEBUGGER IS CALLED.  RETURN FROM THE DEBUGGER CAUSES
*	   A RETURN TO THE CALLER.
*
DEBUGC	EQU  $
	MOV  @PLOCN,R3  	GET LOCATION TO DUMP
	INCT R3
	IF   GENEVE
	LI   R5,FORT2
	ELSE
	LI   R5,F2SADR
	ENDIF
	NEG  R5
	A    R5,R3
	MOV  R3,R5
	C    R5,@SNAPLO		IS THIS THE SNAP LOCATION?
	JEQ  DEBUG1		BRIF YES, DISPLAY IT
	ABS  @TRACE		TRACE ON?
	JEQ  NOPRIN		NO, DON'T DISPLAY ANYTHING HERE
DEBUG1  EQU  $
	BL   @PRINTH		PRINT IT IN HEX
	LI   R5,RWORK		DUMP WORK STACK
	BL   @DISSTA		DISPLAY THE STACK
NOPRIN  EQU  $
*
*  EXAMINE THE STACK POINTERS FOR VALIDITY.
*
	LI   R2,RPROLO		STACK POINTER
DEBUG2	EQU  $
	MOV  @RA(R2),R5		STACK ANCHOR
	BL   @CHECKN
	MOV  @RT(R2),R5		STACK TOP
	BL   @CHECKN
	MOV  @RB(R2),R5		STACK BOTTOM
	BL   @CHECKN
	INCT R2			CHECK NEXT
	CI   R2,ROLLS
	JNE  DEBUG2
*
*  CHECK TO SEE IF THIS IS SNAPPED LOCATION
*
	C    @SNAPLO,R3		WAS THIS THE SNAP POINT?
	JNE  NOSNAP		BRIF NO
DOSNAP	EQU  $
	BL   @MINI		GO TO DEBUGGER
NOSNAP	EQU  $
	B    @DERETC		RETURN
*
*  CHECKN - CHECK TO SEE IF A STACK POINTER HAS BEEN CORRUPTED.
*           ADDRESS IS IN R5,  MUST BE BETWEEN SA1ADS & SA1ADE
*
CHECKN	EQU  $
	C    R5,@SA1ADS
	JL   CHECKE		BRIF ERROR
	C    R5,@SA1ADE
	JH   CHECKE
	B    *R11
CHECKE	EQU  $
	BL   @DISSTA		DISPLAY STACK
	BL   @WRDATA
	DATA STAERR		STACK ERROR
	JMP  DOSNAP
*
*  DISSTA - DISPLAY STACK SPECIFIED IN R5
*
DISSTA	EQU  $
	MOV  R11,R12		SAVE RETURN
	MOV  R5,R2		SAVE STACK NUMBER
	MOV  @RT(R2),R6		GET STACK TOP
	MOV  R6,R5
	INCT R5
	BL   @PRINTH		DISPLAY START ADDRESS
WRKLOP  EQU  $
	INCT R6
	C    R6,@RB(R2)		AM I DONE?
	JH   WRKEXI		BRIF YES
	MOV  *R6,R5		ELSE, DISPLAY IT
	BL   @PRINTH
	JMP  WRKLOP
WRKEXI  EQU  $
	BL   @WRDATA
	DATA STLOCR		END WITH A CARRIAGE RETURN
	B    *R12
*
*  PRINTH - PRINT HEX VALUE IN R5 ON PRINTER DEVICE
*
PRINTH	EQU  $
	MOV  R11,R10		SAVE RETURN
	LI   R1,STLONN		STRING START
	LI   R0,-4		4 DIGITS TO CONVERT
PRINT1	EQU  $
	SRC  R5,12		GET NEXT NIBBLE
	MOV  R5,R4
	ANDI R4,>000F		MASK DIGIT
	CI   R4,10
	JLT  INTDIR		ADD INTEGER
	AI   R4,>0041-10 	ELSE, ADD ASCII 'A'
	JMP  INTDON
INTDIR	EQU  $
	AI   R4,>0030		ADD ASCII '0'
INTDON	EQU  $
	SWPB R4	
	MOVB R4,*R1+		SAVE IN STRING
	INC  R0
	JNE  PRINT1		BRIF MORE DIGITS
	BL   @WRDATA		WRITE IT TO SCREEN
	DATA STLONW
	B    *R10		& RETURN
*
*  WRDATA : Write data to selected file using normal I/O routines
*
*  Calling Sequence:
*
*      BL   @WRDATA
*      DATA SADDRESS
*
*  Where:
*
*     SADDRESS is the string address to write, preceded by a byte
*     which contains the number of bytes to write.  
*
*     Destroys R4, R5, R11.
*
WRDATA	EQU  $
	MOV  *R11+,R4		get address to write
	CLR  R5
	MOVB *R4+,R5		get # bytes to write
	SWPB R5
	MOV  R4,@LIADRE		save address to write
	MOV  R5,@LIBYTE
	LI   R4,LIWRIT
	BLWP @CIO$
	B    *R11		ignore error return
END01	EQU  $
	END
