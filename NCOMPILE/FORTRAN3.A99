	TITL 'FORTRAN3 - PART3 OF FORTRAN COMPILER'
	IDT  'FORT3'
	DEF  FORT3
*
*  FORTRAN3 - Code Generator portion of 99 FORTRAN
*
*  This module produces:
*
*	 1.  An object file
*	 2.  A listing file
*
*  it receives as inputs from FORTRAN1/FORTRAN2 the following
*  scratch files:
*
*	 1.  A per module source file
*	 2.  An intermediate object file
*
*  Change History:
*
*  01-May-87    Version 3.0   Major rewrite of code generator.  New
*			      generator much more structured and easy
*			      to modify.
*
*  15-Jun-87		      Changed floating point calls to match
*			      new shortened execution support package.
*
*  01-Aug-87                  Modified floating point LOAD/STORE routines
*			      in the same manner as the other floating
*			      point arguments.  Also added new entry point
*			      into execution support, for integer signed
*			      division.
*
*  18-aug-87		      Moved start address to >C100 (was >C000) to
*			      accomodate increased size of FORTRAN1.
*
*  18-OCT-87                  Fixes to EXTERNAL code.  Allow indirect form
*			      of execution call w/argument, for EXTERNAL.
*
*  07-dec-87	Version 4.0   Updated for MDOS
*
*  14-feb-88		      RORG'd version.  Change BARREL fill logic
*			      to only use registers.
*
*  24-mar-88		      Update for version 3.1.3 fix.
*
*  24-apr-88                  Add new data types.
*
*  29-Nov-89                  Added list directed formatting.
*
*  03-Dec-89    Version 4.42  Fix BYTE Division in GPL mode, DATA Statement
*
*  08-Oct-90    Version 4.4   Long FORMAT statements generating illegal
*                             branch around.   Changed compare.
*
	UNL
	COPY "FORTPAR:"
	COPY "EQUATES:FORTEX.EQ9"
	COPY "EQUATES:FORTIO.EQ9"
*
	IF   GENEVE
	COPY "EQUATES:MATH.EQ9"
	COPY "EQUATES:MEM.EQ9"
	ENDIF
	LIST
*
TMS9995	EQU  GENEVE	TMS9995 (1) OR NOT (0)
*TMS9995	EQU  0			TMS9995 (1) OR NOT (0)
*
	RORG 0
FORT3	EQU  $
	B    @ENTRY
*
      TITL 'FORTRAN3 DATA AREA'
*
*   DEFINITIONS FOR PEEPHOLE OPTIMIZER:
*
	DEF  KMBARS		- BARREL SIZE (WORDS)
	DEF  GETWOR		GET A WORD FROM BARREL ROUTINE
	DEF  GETWO2		GET A WORD FROM SCRATCH FILE ROUTINE
	DEF  PFXCTO		FIXED CONSTANT TABLE
	DEF  ENDL3		END OF FORTRAN3 DYNAMIC DATA AREA
*
*   EXTERNAL REFERENCES: (FROM FORTRAN1)
*
	REF  SC1PAB		SCRATCH FILE 1 PAB
	REF  SC2PAB		SCRATCH FILE 2 PAB
	REF  IOABOR		I/O ABORT HANDLER
	REF  P1RETN		PASS 1 RETURN ENTRY
*
*  EXTERNAL REFERENCES: (FROM OPTIMIZER)
*
	REF  PEEPHO		PEEP HOLE OPTIMIZER START
	REF  FIOC		Fortran I/O
	REF  FOPFIL		Fortran File Open
	IF   GENEVE
	REF  CIO$		Standard Fortran I/O
	ENDIF
*
*  MISC. EQUATES
*
	IF   GENEVE
MYWSP	EQU  >F000		MY WORKSPACE OFFSET
NUMLIN	DATA 55			NUMBER LINES/PAGE
	ELSE
MYWSP	EQU  >8300		MY WORKSPACE OFFSET
NUMLIN  EQU  >2036		LOC OF NUMBER LINES/PAGE (FROM MENU)
	ENDIF
TEMPSZ	EQU  4			TEMPS DATA AREA BYTE SIZE
*
*  FILE NUMBER USAGE EQUATES:
*
OBFILE	EQU  2			OBJECT FILE
LIFILE	EQU  3			LISTING FILE
S1FILE	EQU  4			SCRATCH FILE 1
S2FILE	EQU  5			SCRATCH FILE 2
*
*  REGISTER VARIABLES:
*
RTO	EQU  R9			'TO' POINTER
RET	EQU  R10		Return register (to mainlo)
*
*  OTHER EQUATES:
*
KMBARS	EQU -31			- # WORDS IN BARREL
	EVEN
PASS1	EQU  3
	COPY "FORTRAN5.A99"
REXCEO	EQU  ROLLS+2
KSTARS	DATA >410E		START SUBROUTINE MODULE
KSTARM	DATA >420E		START PROGRAM MODULE
KASTRK	DATA >000A		'*' - ' '
KDEF	DATA >900C		DEF ITEM
KORGRE	DATA >7000
KABSLT	DATA >1000		ABSOLUTE LOAD (INTEGER)
KBBSLT	DATA >1100		ABSOLUTE LOAD (BYTE)
KDATRE	DATA >3000		DATA RELATIVE LOAD
KSPRGR	DATA >A00C
KORGLG	DATA >7200		ORIGIN INTO LOGIC
KLOCAL	DATA >0100
KLCLRE	DATA >3100		LOCAL RELATIVE LOAD
KPRGRE	DATA >2000		PROGRAM RELATIVE LOAD
KFORMT	DATA >200
KHOLVA	DATA >0000
KPRINT	DATA >0005		PRINT ASCII COMMAND
KPRTLE	DATA 92	    		PRINT RECORD LENGTH
KEXECT	DATA >100
KACHAI	DATA >C004		ADDRESS CHAIN
KDFDLB	DATA >2000
KENDMO	DATA >5006		END MODULE
KLSTRE	DATA >9F00
KDBGVA	DATA >600E		VARIABLE DEBUG PACKET
KDBGLB	DATA >6106		LABEL DEBUG PACKET
KDBGLI	DATA >6204		LINE # DEBUG PACKET
KFF00	DATA >FF00		A MASK
ASC0B	TEXT '0 '		ASCII 0
K80	DATA 80	    		CONSTANT 80
K18	DATA 18	    		CONSTANT 18
K6	DATA 6	     		CONSTANT 6
K8	DATA 8	     		CONSTANT 8
KM2	DATA -2	    		CONSTANT -2
*
BLANK	EQU  $	     		TWO BLANKS
EBLANK 	TEXT '  '
EAB	TEXT 'AB'		ABSOLUTE VALUE
ERE	TEXT 'RE'		PROGRAM RELATIVE VALUE
EDA	TEXT 'DA'		DATA RELATIVE VALUE
ECO	TEXT 'CO'		COMMON RELATIVE VALUE
EE	TEXT ' E'
*
*
OPFLD   MACRO
        DATA %1*512
        ENDM
*
OPFIEL	EQU  $	     		ARGUMENT POINTER OPFIELD TABLE
        OPFLD 0				   - DATA AREA
        OPFLD RGDUMM			 B - TEMP ITEM
        OPFLD RATEMP			 C - ADDRESS TEMPORARY
        OPFLD RCTEMP			 D - OTHER TEMPORARY
        OPFLD RMODAD			 1 - MODIFIED ARRAY ADDRESS
OPRGLB  OPFLD RLABEL			 2 - PROGRAM LABEL
        OPFLD RMLABE			 3 - MADE LABEL
        OPFLD RFXCON			 4 - FIXED (I*2) CONSTANT
        OPFLD RBYCON			 5 - BYTE (I*1) CONSTANT
        OPFLD RSPCON			 6 - SINGLE PRECISION CONSTANT
        OPFLD RDPCON			 7 - DOUBLE PRECISION CONSTANT
        OPFLD RI4CON			 8 - INTEGER *4 CONSTANT
	OPFLD RC8CON			 9 - COMPLEX *8 CONSTANT
	OPFLD RC6CON			10 - COMPLEX *16 CONSTANT
        OPFLD RPROGR			11 - PROGRAM NAME
        OPFLD RLSPRO			12 - LOCAL SUBPROGRAM
        OPFLD RGSPRO			13 - EXTERNAL SUB PROGRAM
        OPFLD REXTER			14 - EXTERNALS
OSCALO  OPFLD RSCALE			15 - SCALAR
OARRAO  OPFLD RARRAY			16 - ARRAY
TOPFLD	EQU  $
*
OARYEL  OPFLD RASTAT		ARRAY ELEMENT POINTER (DATA STMT)
*
*
*  FORTRAN LISTING HEADER LINE SHELL
*
THEADE	EQU  $
	TEXT '1 '
TPROGN	EQU  $
        TEXT '          '
TALLOC  TEXT '          '
        TEXT '          '
	TEXT 'Version 4.42'
	TEXT '                '
	TEXT 'Page'
TPAGE   BSS  8
	TEXT '                   '
	EVEN
VSEQNO	DATA 0
*
*   TABLE CODES			#IN, #TOTAL, PAD1, PAD2
*
TBLCD	MACRO
	DATA %1*16+%2*2+%3*2+%4*64
	ENDM
*
	TBLCD 2,2,0,0		 1 MODADR
	TBLCD 2,4,1,0		 2 LABEL
	TBLCD 0,2,1,0		 3 MLABEL
	TBLCD 1,2,0,1		 4 FXCON
	TBLCD 1,2,0,1		 5 BYCON
	TBLCD 2,3,0,0		 6 SPCON
	TBLCD 4,5,0,0		 7 DPCON
	TBLCD 2,3,0,0		 8 I4CON
	TBLCD 4,5,0,0		 9 C8CON
	TBLCD 8,9,0,0		10 C6CON
	TBLCD 3,4,0,0		11 PROGRM
	TBLCD 4,5,0,0		12 LSPROG
	TBLCD 4,5,0,0		13 GSPROG
	TBLCD 4,4,0,0		14 EXTERN
TBLCOD	EQU  $
*
TMLOGI	EQU  $
	TEXT 'PROGRAM '
*
*  BINARY OUTPUT FILE WRITE
*
BOPUNC	DATA WRBOPC		WRITE BINARY
	DATA OBFILE		FILE 2 - OBJECT FILE
	DATA PUNCHB
	DATA 80			80 BYTE RECORDS
*
*  LISTED OUTPUT WRITE STACK
*
LOWRIT	DATA WRAOPC		WRITE ASCII
	DATA LIFILE		FILE 3 - LISTING FILE
	DATA 0			OUTPUT BUFFER ADDRESS
	DATA 90			# BYTES TO WRITE
*
*  SCRATCH FILE 1 READ I/O LIST
*
X1READ	DATA REAOPC		READ ASCII
	DATA S1FILE		FILE 4 - SCRATCH FILE 1
	DATA PRINTB
	DATA 80			80 BYTES TO READ
*
*  SCRATCH FILE 2 FILE READ I/O LIST
*
X2READ	EQU  $
	DATA REAOPC+>0800	READ RANDOM BINARY
	DATA S2FILE		FILE 5 - SCRATCH FILE 2
AX2BUF	DATA 0			INTO BUFFER
VX2BYT	DATA 0			ONE RECORD
PX2	DATA 0			RECORD #
*
*  OFFSETS TO TEXT STRINGS:
*
OFFERR	EQU  $	     		ERROR MESSAGES
	DATA XALLOC		01 - ALLOCATION
	DATA XDATAS		02 - DATA COUNT
	DATA XIDCON		03 - ID CONFLICT
	DATA XOPTIO		04 - BAD OPTION
	DATA XLABEL		05 - LABEL ERROR
	DATA XMAGNI		06 - MAGNITUDE ERROR
	DATA XSUBST		07 - SUBSTATEMENT
	DATA XSUBSC		08 - SUBSCRIPT
	DATA XSYNTA		09 - SYNTAX
	DATA XTYPEC		10 - TYPE CONFLICT
	DATA XENDIF		11 - MISSING ENDIF
	DATA XILLDO		12 - ILLEGAL DOLOOP
	DATA XMTHEN		13 - MISSING THEN
	DATA XMELSE		14 - BAD ELSE
	DATA XMELSI		15 - BAD ELSEIF
	DATA XMENDI		16 - BAD ENDIF
	DATA XOVERF		17 - MEMORY OVERFLOW
	DATA XDATAC		18 - DATA COUNT
	DATA XUNKNO		19 - UNKNOWN (MUST BE LAST ERROR)
OFFWAR	EQU  $
	DATA XTRUNC		4
	DATA XMIXED		2
	DATA XLENGT		1
*
ERRMAX	EQU  19			19 - MAXIMUM ERROR MSG #
*
*  MESSAGES:
*
WLABEL	TEXT '0 Statement Labels:'
	BYTE >FF
WSUBPR	TEXT '0 Subprogram References:'
	BYTE >FF
WCOMMO	TEXT '0 Common Area:'
	BYTE >FF
WCOMME	TEXT '0 Common Errors:'
	BYTE >FF
WLOCAL	TEXT '0 Local Data Area:'
	BYTE >FF
WLOCAE	TEXT '0 Local Errors:'
	BYTE >FF
WWARNC	TEXT '0         Warning(s)'
	BYTE >FF
WERRCN	TEXT '          Error(s)'
	BYTE >FF
WLOGIS	TEXT '0 Logic Size:'
	BYTE >FF
WDATAS	TEXT '  Data Size:'
	BYTE >FF
WTOTAS	TEXT '0 Module Size:'
	BYTE >FF
WCOMSI	TEXT '0 Common Size:'
	BYTE >FF
WARNIN	TEXT '**Warning-'
	BYTE >FF
WERROA	TEXT '**Error-'
	BYTE >FF
WALLOC	TEXT 'Allocation'
	BYTE >FF
XEOD  	TEXT '>EOD'
	BYTE >FF
*
*  ERROR MESSAGES:
*
XALLOC	TEXT 'Could not allocate variable'
	BYTE >FF
XDATAS	TEXT 'Storage count is wrong in DATA'
	BYTE >FF
XIDCON	TEXT 'Variable used incorrectly'
	BYTE >FF
XOPTIO	TEXT 'Illegal compilation option'
	BYTE >FF
XLABEL	TEXT 'Missing or bad statement label'
	BYTE >FF
XMAGNI	TEXT 'Number is too large or small'
	BYTE >FF
XSUBST	TEXT 'Illegal statement of Logical IF'
	BYTE >FF
XSUBSC	TEXT 'Subscript out of range'
	BYTE >FF
XSYNTA	TEXT 'Don''t understand this statement'
	BYTE >FF
XTYPEC	TEXT 'Variable used in incorrect context'
	BYTE >FF
XENDIF	TEXT 'ENDIF statement is missing'
	BYTE >FF
XILLDO	TEXT 'DO loop is used illegally'
	BYTE >FF
XMTHEN	TEXT 'THEN statement is missing'
	BYTE >FF
XMELSE	TEXT 'ELSE statement is used incorrectly'
	BYTE >FF
XMELSI	TEXT 'ELSEIF statement is used incorrectly'
	BYTE >FF
XMENDI	TEXT 'ENDIF statement is used incorrectly'
	BYTE >FF
XOVERF	TEXT 'Compiler workspace memory overflow'
	BYTE >FF
XDATAC	TEXT 'Variable in DATA statement also in COMMON'
	BYTE >FF
XUNKNO	TEXT 'Internal Compiler Error'
	BYTE >FF
*
*  WARNINGS:
*
XMIXED	TEXT ' Mixed Mode Arithmetic'
	BYTE >FF
XLENGT	TEXT ' Name is greater than 9 characters'
	BYTE >FF
XTRUNC	TEXT ' Value is too large or too small'
	BYTE >FF
*
*  MOD39 CONVERT ROUTINE CONVERSION TABLE:
*
VTABLE	EQU  $
	BYTE 10,36,37
	EVEN
*
*  TENS TABLE FOR CVTNUM ROUTINE
*
TENTBL	EQU  $
K10000	DATA 10000
	DATA 1000
	DATA 100
K10	DATA 10
K1	DATA 1
*
*  ELEMENT TYPE TABLES:
*
ELESIZ	EQU  $	     		SIZE FOR EACH TYPE
	DATA 2,1,4,4,8,8,16,2
ELETYP	EQU  $	     		KEY LETTER FOR EACH TYPE
	TEXT 'ikjrdcel'
	EVEN
*
	TITL 'INITIALIZATION & READ DATA SECTION OF S DATA'
	PAGE
*
*   THIS SECTION CONTAINS INITIALIZATION START AND GENERAL SUBROUTINES
*
ENTRY	EQU  $
	MOV  @PTAILR,@PNEXTW
	MOV  @PTAIRS,@PX2
	MOV  @VX2SIZ,@VX2BYT	SET SCRATCH FILE 2 BYTE SIZE
	MOV  @SA1ADS,R1		FIRST FREE LOCATION
	DECT R1
	MOV  R1,@PMODTO
	MOV  @SA1ADE,R1		END OF FREE AREA
	DECT R1
	MOV  R1,@AEX2BU
	S    @VX2SIZ,R1
	MOV  R1,@AX2BFM
	DECT R1
	MOV  R1,@ADSTBT
	AI   R1,4
	MOV  R1,@AX2BUF
	A    R1,@PNEXTW
	LI   R2,ZERODT		COMPUTE # WORDS TO CLEAR
	LI   R6,ZERODA
	S    R6,R2
CLRLO	EQU  $
	CLR  @ZERODA(R2)
	INCT R2
	JNE  CLRLO
	LI   R5,BARREL		COMPUTE ABARRE=BARREL+2
	INCT R5
	MOV  R5,@ABARRE
	SETO @FLO		ALWAYS SET LISTED OUTPUT
	CLR  @VDELTA
	CLR  @VSEQNO		INITIALIZE PUNCH BUF SEQ NO
	CLR  @FLSTFL
	LI   R5,PUNCHB
	MOV  R5,@PNXTIT		SET NEXT OBJECT ITEM POINTER
	LI   R6,LCHKSU
	NEG  R6
	A    R5,R6		SET - # BYTES IN OBJECT BUFFER
	MOV  R6,@VRMNOB
	LI   R5,8
	MOV  R5,@PLCCTO
	LI   R5,TEMPSZ
	MOV  R5,@PGLDUM		SET GLOBAL DUMMY (ARGUMENT POINTER) OFFSET
	MOV  R5,@PATEMP-2
*
*  OPEN SCRATCH FILES 1 & 2 FOR READ ACCESS
*
	LI   R1,SC1PAB		OPEN SCRATCH 4
	LI   R0,>14		OPEN INPUT, SEQUENTIAL, VARIABLE
	MOV  R0,*R1
	LI   R0,S1FILE
	BLWP @FOPFIL
	JNE  IOABO1
*
	LI   R1,SC2PAB		OPEN SCRATCH 5
	LI   R0,S2FILE
	MOV  R0,*R1		OPEN INPUT, RELATIVE, FIXED
	BLWP @FOPFIL
	JNE  IOABO1
*
	LI   R4,X2READ		GET INITIAL RECORD OF X2
	BLWP @FIOC
	JNE  IOABO1
*
	BL   @GETWO2
	NEG  R5	    		GET COUNT
	MOV  R5,@VCOUN1
	SLA  R5,1
	A    @ADSTBT,R5		SET POINTER
	MOV  R5,@PHOLWD
	MOV  R5,RTO		ENSURE SUFFICIENT TABLE SPACE
	S    @PMODTO,R5
	JLT  BRMOV1		READ INTO BOTTOM OF TABLE AREA
	BL   @READWD
	MOV  @PMODTO,RTO  	READ FIXED TABLE SIZE
	LI   R5,PMODTO-PSCLRT	- NUMBER OF TABLES TO READ
	MOV  R5,@VMINTB		SAVE IT
*
TAILR1	EQU  $
	BL   @GETWO2		FOR EACH TABLE:
	JEQ  TAILR5		READ # OF ENTRIES
	NEG  R5
	MOV  R5,@VCENTR   	0 - GET NEXT TABLE
	MOV  @VMINTB,R2
	MOV  @TBLCOD(R2),R5
	MOV  R5,R4
	SRC  R5,12		GET LENGTH
	ANDI R5,>F		MASK LENGTH
	NEG  R5
	MOV  R5,@VCIN		NUMBER OF WORDS IN TAIL
	MOV  R4,R5
	SRC  R5,8
	ANDI R5,>F
	MOV  R5,@VCTOTA		FIRST PADDING WORD (IF ANY)
	MOV  R4,R5
	ANDI R5,>80
	JEQ  NOPAD		SECOND PADDING WORD (IF ANY)
	SETO R5
NOPAD	MOV  R5,@VPAD1
	ANDI R4,>40
	JEQ  NOPAD2
	SETO R4
NOPAD2	MOV  R4,@VPAD2
*
	MOV  @VCENTR,R4		ENSURE SUFFICIENT TABLE SPACE
	NEG  R4
	SLA  R4,1
	MPY  @VCTOTA,R4
	A    RTO,R5
	S    @PHOLWD,R5
	JLT  TAILR2
BRMOV1	B    @RMOVFL		RM OVERFLOW, ABORT
IOABO1	B    @IOABOR		I/O ABORT
*
TAILR2	EQU  $	     		FOR EACH ENTRY IN TABLE:
	MOV  @VCIN,@VCOUN1
	BL   @READWD    	READ TAIL WORDS INTO CORE
	MOV  @VCTOTA,R2
	A    @VCIN,R2
	JEQ  TAILR4		IF ENTRY REQUIRES PADDING
	JLT  TAILR3		INSERT PADDING WORDS
	SLA  R2,1
	NEG  R2
TAL2LO	MOV  @VPADWD(R2),R5
	INCT RTO		IF ENTRY IS SMALLER THAN THE
	MOV  R5,*RTO		NUMBER OF WORDS IN THE TAIL,
	INCT R2			IGNORE THE EXCESS WORDS
	JNE  TAL2LO
	JMP  TAILR4
*
TAILR3	EQU  $
	A    R2,RTO		REPEAT FOR NEXT ENTRY
*
TAILR4	INC  @VCENTR
	JNE  TAILR2
*
TAILR5	MOV  @VMINTB,R2  	AT END OF TABLE, SET TOP POINTER
	MOV  RTO,@PINTBT(R2) 	OF NEXT TABLE TO BOTTOM OF
	INCT @VMINTB
	JNE  TAILR1		REPEAT FOR NEXT TABLE
*
	BL   @GETWO2		READ TEMP CELL ASSIGNMENTS
	MOV  R5,@PATMPT
	MOV  R5,@PATEMP
*
	BL   @GETWO2		ADDRESS TEMPS
	MOV  R5,@PCTMPT
	MOV  R5,@PCTEMP
	BL   @GETWO2
	MOV  R5,@PLCVAR		READ ADR OF FIRST LCL VARIABLE
	BL   @GETWO2
	MOV  R5,R4		NUMBER OF VARIABLE NAMES TO BE READ
	LI   R6,10
	MPY  R6,R4		READ VARIABLE TEMPS
	A    @PSCLRT,R5
	MOV  R5,@PARRYT
	BL   @GETWO2
	MOV  R5,R4
	LI   R6,10
	MPY  R6,R4
	A    @PARRYT,R5		SET TABLE POINTERS
	MOV  R5,@PHVRTO
	S    @PHOLWD,R5
	JGT  BRMOVF
	JEQ  BRMOVF
	MOV  @PX2,@PX2SV 	SAVE CURRENT TAIL POSITION
	MOV  @PNEXTW,@PNWDSV   	FOR RESCAN DURING MAP
*
*  THE FOLLOWING LOOP READS IN THE VARIABLE NAMES.
*
TAILR6	EQU  $			READ VARIABLE NAMES
	BL   @GETWO2
	JEQ  TAILR7
	MOV  R5,@VHEADE		FIRST WORD 0 -- END OF ALLOCATION
	LI   R5,-5		GROUP (COMMON OR LOCAL)
	MOV  R5,@VCOUN1
	LI   RTO,VHEADE 	4TH WORD 0 -- NOT SCALAR OR
	BL   @READWD		ARRAY -- IGNORE
	MOV  @VNAME2,R5 	OTHERWISE, USE 4TH WORD AS
	ANDI R5,MOPCFL   	 POINTER TO INSERT REMAINING WORDS IN
	JEQ  TAILR6	  	 TABLE
	C    @OARRAO,R5
	JNE  NOTOAR
	MOV  @PARRYT,R2 	DETERMINE TABLE FROM OPFIELD
	JMP  NOTOA1
NOTOAR	EQU  $
	MOV  @PSCLRT,R2
NOTOA1	EQU  $
	MOV  @VNAME2,R4
	ANDI R4,MADRFL
	MPY  @K10,R4
	A    R2,R5
	INCT R5
	MOV  R5,RTO
	LI   R6,VHEADE
	MOV  *R6+,*R5+  	INSERT ENTRY
	MOV  *R6+,*R5+
	MOV  *R6+,*R5+
	LI   R6,VNAME3
	MOV  *R6+,*R5+
	MOV  *R6,*R5
	JMP  TAILR6		REPEAT FOR NEXT NAME
*
BRMOVF	EQU  $
	B    @RMOVFL
*
TAILR7	EQU  $			END OF ALLOCATION GROUP
	BL   @GETWO2
	JEQ  TAILR9
	A    R5,@VCALER 	KEEP ALLOCATION ERROR COUNT FOR
	NEG  R5	     		MAP PRINTING
	MOV  R5,@VCENTR 	READ PAST ERROR SUMMARY, IF ANY
*
TAILR8	LI   R5,-4
	MOV  R5,@VCOUN1
	MOV  @VHEADE,RTO 	IGNORE 4*COUNT WORDS
	BL   @READWD
	INC  @VCENTR
	JNE  TAILR8
*
TAILR9	EQU  $			REPEAT FOR LOCAL ALLOCATION
	MOV  @FLOCAL,R5 	GROUP IF NOT ALREADY READ
	JLT  NOTT6A
	SETO @FLOCAL
	JMP  TAILR6
NOTT6A	MOV  @PHVRTO,RTO
	BL   @GETWO2		READ HOLLERITH VARIABLE WORD
	JEQ  TAIL10
	NEG  R5
	MOV  R5,@VCOUN1		SET POINTER
	A    @PHVRTO,R5
	S    @PHOLWD,R5		ENSURE SUFFICIENT TABLE SPACE
	JGT  BRMOVF
	JEQ  BRMOVF
	BL   @READWD		READ ADDRESSES INTO TABLE
*
TAIL10	EQU  $			SET SPECIAL ADDRESSING TABLE
	MOV  RTO,@ADSTTO  	POINTERS TO 1ST AVAIL SPACE
	LI   R5,-5
	MOV  R5,@VCOUN1
	LI   RTO,VHEADE
	DECT RTO		COMMON SIZE
	BL   @READWD    	DATA SIZE
	MOV  @VVALUE,R5 	PROGRAM NAME
	MOV  R5,@PDCTMP
	MOV  R5,@PHLVAR 	SETUP POINTERS FOR MAP PRINTING
*
	BL   @GETWO2		READ FLAGS
	MOV  R5,@FEND   	END SEEN FLAG
	BL   @GETWO2
	NEG  R5	    		FIRST PROG OF COMPILATION
	MOV  R5,@VREC   	I/O DONE
	A    @NUMLIN,R5 	NUMBER LINES PER PAGE, FROM MENU
	MOV  R5,@VCLINE 	INITIALIZE LINE COUNT AND RECORD NUMBER
	BL   @GETWO2
	MOV  R5,@FIO
	CLR  @VLOCN		VLOCN ALWAYS 0 FOR PROGRAM OR SUBPROGRAM
	BL   @GETWO2     	INITIALIZE LOGIC LOCATION COUNTER
	JEQ  GPROGR	 	NON-EXECUTABLE STATEMENTS
GSPROR	EQU  $
	CLR  @FMAIN		SET FMAIN=0 (SUBPROGRAM)
	MOV  @KSTARS,R5
	JMP  GCCONT
GPROGR	EQU  $
	SETO @FMAIN		SET FMAIN=-1 (PROGRAM)
	MOV  @KSTARM,R5
GCCONT	EQU  $
	BL   @G1WDIT    	GENERATE START MODULE LOAD ITEM
	BL   @M39CVT    	CONVERT TO ASCII
	MOV  @VHEADE,R5 	OUTPUT COMMON SIZE, DATA SIZE & IDENT
	MOV  R5,@VHEADE		SAVE SIZES FOR MAP PRINTING
	MOV  R5,@VCMNSI
	MOV  @VVALUE,R5
	MOV  R5,@VVALUE
	MOV  R5,@VDATSI
	BL   @GBCDIT    	GENERATE OBJECT HEADER
	LI   R2,-10
	LI   R0,VNAME1
	LI   R1,TPROGN
	LI   R3,TALLOC
SETNXT	EQU  $
	MOV  *R0+,*R1+  	MOVE PROGRAM NAME
	MOV  @BLANK,*R3+  	BLANK OUT ALLOCATION FIELD
	INCT R2
	JNE  SETNXT		BRIF MORE
	A    @KASTRK,@VNAME5
	MOV  @KDEF,@VHEADE
	CLR  @VVALUE
	BL   @GBCDIT
	BL   @GETWO2    	INITIALIZE REMAINING DATA
	INV  R5
	MOV  R5,@FDW    	FDW IS COMPLEMENT OF
	BL   @GETWO2		NW OPTION FLAG
	MOV  R5,@FMAP
	BL   @GETWO2    	NOISE WORD
*
	MOV  @PHOLWD,R5 	OUTPUT HOLLERITH VARIABLE WORDS
	S    @ADSTBT,R5
	JEQ  TAIL13
	MOV  R5,@VCOUN1 	GEN 'ORG' TO FIRST HOLVAR ADDRESS
	MOV  @PHVRTO,R2
	MOV  @2(R2),R2  	REDEFINE POINTER TO 1ST HOLLERTIH
	MOV  R2,@PHLVAR		 VARIABLE FOR MAP PRINTING
	MOV  @KORGRE,R5
	BL   @GLDITE
*
TAIL12	EQU  $
	INCT @PHOLWD    	OUTPUT ABSOLUTE LOAD ITEM FOR
	MOV  @KABSLT,R5		 EACH HOLLERITH WORD
	MOV  @PHOLWD,R2
	MOV  *R2,R2
	BL   @GLDITE
	INCT @VCOUN1
	JNE  TAIL12
*
TAIL13	EQU  $
	BL   @GETWO2    	INITIALIZE REMAINING DATA
	MOV  R5,@FOBJLS 	 OB OPTION, SET AFTER HOLDWD
	BL   @GETWO2
	MOV  R5,@FDEBUG 	MAP CONTROL FLAG
	CLR  @PX2	 	GEN'D SO THIER NOT LISTED
	CLR  @FPRTMA    	CLEAR MAP PRINT FLAG
	MOV  @AX2BUF,@PNEXTW
	LI   R4,X2READ  	READ NEXT RECORD FROM SCRATCH FILE 2
	BLWP @FIOC
	JNE  IOABO2
	LI   R5,1
	MOV  R5,@FCHNGE
	MOV  @PFXCTO,R5
	S    @PFXCBT,R5
	MOV  R5,@VCCONS
*
	B    @MAINLI    	GOTO MAIN
RMOVFL	EQU  $
	LI   R1,9		RM OVERFLOW ERROR
IOABO2	B    @IOABOR     	I/O ABORT
*
*  READWD : READ THE NUMBER OF WORDS SPECIFIED IN VARIABLE VCOUN1
*
READWD	EQU  $
	MOV  R11,@PREADX 	READ -VCOUN1 WORDS FROM TAIL
	MOV  @VCOUN1,R5
	JEQ  READW2		STORE BEGINNING AT (RTO+2)
*
READW1	BL   @GETWO2
	INCT RTO
	MOV  R5,*RTO
	INC  @VCOUN1
	JNE  READW1
*
READW2	MOV  @PREADX,R11
	B    *R11
*
*  GETWO2 - Get word from scratch file 2 routine
*
GETWO2	EQU  $
	MOV  R11,@PGWDXI  	GET NEXT INTERMEDIATE OBJECT WORD
	MOV  @PNEXTW,R5
	S    @AEX2BU,R5
	JNE  GETWDX
*
	MOV  @AX2BFM,@PNEXTW
	MOV  @AEX2BU,R6 	LAST WORD - MOVE TO POSITION
	MOV  @AX2BFM,R2  	BEFORE BUFFER AND READ NEXT
	MOV  *R6,*R2	 	RECORD INTO BUFFER
	INC  @PX2		INCREMENT RECORD NUMBER
	LI   R4,X2READ
	BLWP @FIOC		GET RECORD
	JNE  IOABO2
*
GETWDX	EQU  $
	MOV  @PNEXTW,R5
	INCT @PNEXTW
	MOV  @PGWDXI,R11
	MOV  *R5,R5		SET COMPARE BITS
	B    *R11	  	RETURN
*
*  GETWOR - Same as GETWO2, except the word is removed from
*	    the optimization stack.
*
GETWOR	EQU  $
	MOV  R11,@PGWDX2	SAVE RETURN
	MOV  @ABARRE,R4		STACK START
	MOV  R4,R2
	DECT R2			MOVE TO ADDRESS
	LI   R5,KMBARS		# WORDS TO MOVE
MOVBAR	EQU  $
	MOV  *R4+,*R2+		MOVE A WORD
	INC  R5
	JNE  MOVBAR
	BL   @GETWO2		GET A WORD FROM SCRATCH FILE 2
	MOV  R5,@VBARLS		INTO STACK
	MOV  @PGWDX2,R11
	MOV  @BARREL,R5
	B    *R11
*
*  M39CVT - M39 TO ASCII CONVERSION ROUTINE
*
M39CVR	EQU  $
	LI   R6,VNAME1
	MOV  *R7+,*R6+
	MOV  *R7+,*R6+
	MOV  *R7,*R6
M39CVT	EQU  $
	LI   R1,VNAME1		GET M39 START
	LI   R2,VM39W1		GET OUT STRING START
	LI   R3,-3		# WORDS TO CONVERT
LOOPMC	EQU  $
	MOV  *R1+,R5		GET A M39 WORD
	CLR  R4
	LI   R6,39*39		SETUP FOR DIVIDE
	DIV  R6,R4		GET 1ST M39 CHAR
	SWPB R4
	MOVB R4,*R2+		SAVE 1ST M39 CHAR
	LI   R6,39		2ND M39 CHAR
	CLR  R4
	DIV  R6,R4		QUOTIENT IS 2ND
	SWPB R4			REMAINDER IS 3RD
	MOVB R4,*R2+		SAVE 2ND CHAR
	SWPB R5
	MOVB R5,*R2+		SAVE 3RD CHAR
	INC  R3			DONE ?
	JNE  LOOPMC		BRIF NO
*
	LI   R1,VNAME1		MOVE M39 STRING TO VNAME1
	LI   R2,VM39W1		 & CONVERT TO ASCII
	LI   R3,-9		9 CHARS TO MOVE
*
LOOPM1	EQU  $
	CLR  R4
	LI   R5,VTABLE
	MOVB *R2+,R4		GET A M39 CHAR
	CB   R4,*R5+		IS IT A DIGIT?
	JLT  ISDIG		BRIF YES
	CB   R4,*R5+		IS IT A LETTER?
	JLT  ISCHAR
	JEQ  ISBLAN
	CB   R4,*R5+		IS IT A DOLLAR SIGN?
	JEQ  ITSADO		BRIF YES
	LI   R4,>5F00		ELSE, UNDERSCORE
	JMP  M39RET
ITSADO	EQU  $
	LI   R4,>2400		DOLLAR SIGN
	JMP  M39RET
*
ISDIG	AI   R4,>3000		IS A DIGIT, ADD OFFSET T'0'
	JMP  M39RET
*
ISCHAR	EQU  $
	AI   R4,>3700
	JMP  M39RET
*
ISBLAN	LI   R4,>2000		BLANK, LOAD ASCII T' '
*
M39RET	EQU  $			SAVE ASCII CHAR
	MOVB R4,*R1+		TO VNAME BUFFER
	INC  R3			DONE ?
	JNE  LOOPM1		BRIF NO
*
	MOVB @EBLANK,*R1	ELSE, BLANK 10TH CHAR &
	B    *R11		RETURN (DONE)
*
	TITL	'DATA STATEMENT PROCESSING'
	PAGE
*
*  THIS MODULE IS CALLED TO PROCESS A DATA STATEMENT.  IT IS PASSED AS
*  INPUT A LIST OF DATA ITEMS TO PROCESS, AS WELL AS A LIST OF ACTUAL
*  DATA.
*
*  THE FOLLOWING MOVES THE LISTS INTO INTERNAL STORAGE, AND THEN PARSES
*  THE LISTS ONE ELEMENT AT A TIME, GENERATING LOAD ITEM HEADERS AND
*  ABSOLUTE LOAD ITEMS FOR EACH ELEMENT IN THE DATA LIST.
*
IDATST	EQU  $
	CLR  @VRPTCN		; CLEAR REPEAT COUNT
	CLR  @VBYTLF		; CLEAR BYTES LEFT
	CLR  @VDATLO		; CLEAR DATA LOCATION
	BL   @GETWOR		; GET # OF ELEMENTS TO PROCESS
	MOV  R5,R8		; COUNT OF ITEMS TO PROCESS
	SLA  R5,1		; CONVERT TO BYTE COUNT
	A    @ADSTBT,R5
	S    @ADSTTO,R5		; SEE IF ROOM LEFT FOR CONVERSION
	JEQ  B2RMOV		; BRIF NO ROOM LEFT
	JLT  B2RMOV
	MOV  @ADSTTO,R7		; SET POINTER TO TOP OF LIST
	MOV  R7,@PDSLBG
*
*  ITEMXF : TRANSFER THE DATA STATEMENT LISTS INTO INTERNAL STORAGE
*
ITEMXF	EQU  $
	BL   @GETWOR		; GET NEXT WORD
	INCT R7
	MOV  R5,*R7		; MOVE TO DATA AREA
	DEC  R8
	JNE  ITEMXF		; MOVE UNTIL ENTIRE LIST DONE
*
	MOV  R7,@PDSLEN		; SET POINTER TO END OF LIST
*
*  ITEMIN : INITIALIZE FOR PROCESSING OF ITEMS IN DATA STATEMENT
*
ITEMIN	EQU  $
	MOV  @PDSLBG,R5		; CHECK CURRENT POINTER AGAINST
	C    @PDSLEN,R5		;  ENDING POINTER
	JNE  NDATSX		; BRIF MORE TO PROCESS
	B    @DATSTA		; ELSE, EXIT THIS
*
NDATSX	EQU  $
	SETO @FNOGEN		; SET GENERATING OBJECT
	INCT @PDSLBG		; INCREMENT TO NEXT ITEM IN LIST
	MOV  @PDSLBG,R6		; GET NEXT ITEMS POINTER
	MOV  *R6,R5		; GET TYPE
	MOV  *R6,R7		; (SAVE)
	ANDI R5,MOPCFL		; MASK OPCODE TYPE
	C    @OSCALO,R5		; IS IT A SCALAR TYPE VARIABLE?
	JNE  DATST1		; BRIF NO
*
	SETO R1			; SET R1=-1, MEANING SCALAR VARIABLE
	MOV  @PSCLRT,R2		; POINT TO TOP OF SCALAR TABLE
	JMP  DATST2
*
B2RMOV	BL   @RMOVFL		; OVERFLOWED INTERNAL VARIABLE ERROR
DATST1	EQU  $
	CLR  R1			; SET R1=0, MEANING ARRAY ELEMENT
	MOV  @PARRYT,R2		; SET POINTER TO TOP OF ARRAY TABLE
	C    @OARRAO,R5		; ARE WE SURE IT IS AN ARRAY?
	JNE  DATST2		; BRIF NO
	LI   R1,1		; SET R1=1, MEANING ENTIRE ARRAY
*
*  DATST2 : R1 IS CURRENTLY SET TO -1 (SCALAR), 0(ARRAY ELE), 1(ARRAY)
*	    R2 POINTS TO TABLE TOP
*	    R7 IS SAVE OF VARIABLE TYPE & ADDRESS
*
DATST2	EQU  $
	MOV  R7,R5
	ANDI R5,MADRFL		; MASK ADDRESS FIELD OF VARIABLE
	MOV  R5,R4
	MPY  @K10,R4
	AI   R5,8		; COMPUTE 4TH ELEMENT OF PROPER TABLE
	A    R5,R2
	MOV  *R2,R5		; GET AREA CODE
	ANDI R5,>F
	CI   R5,1
	JEQ  DATS2A		; BRIF LOCAL VARIABLE
	INC  @FITMCM		; SET DATA ITEM IN COMMON ERROR
	INC  @FNOGEN		; SET DATA NOT TO BE GENNED FLAG
DATS2A	EQU  $
	MOV  @2(R2),@VDISPL	; SET VARIABLE LOCATION IN COMMON
	MOV  R1,R1		; IS THIS AN ENTIRE ARRAY (+1)?
	JGT  DATST3		; BRIF YES
*
*  IT IS AN ARRAY ELEMENT OR VARIABLE.
*
	MOV  R7,R5		; GET VARIABLE TYPE AGAIN
	ANDI R5,MTAGFL		; GET ARRAY SIZE
	SRA  R5,6		; (WAS 7)
*				  GET BYTE SIZE OF ARRAY OR VAR ELEMENT
	MOV  @ELESIZ(R5),@VELMBY
	MOV  R1,R1		; IS THIS A SCALAR VALUE?
	JLT  DATST4		; BRIF YES
	INCT @PDSLBG		; THE NUMBER OF CONTIGUOUS BYTES
	MOV  @PDSLBG,R6		;  TO BE SAVED IS AT LOCATION
	A    *R6,@VDISPL
	JMP  DATST4
*
*  GET NUMBER OF BYTES IN ARRAY
*
DATST3	EQU  $
	INCT @PDSLBG
	MOV  @PDSLBG,R6
	MOV  *R6,@VELMBY
*
*  IT IS AN ENTIRE ARRAY.
*
DATST4	EQU  $
	MOV  @FNOGEN,R5		; AM I CURRENTLY GENNING OBJECT?
	JEQ  CNSTLO		; BRIF NO
	MOV  @VDISPL,R5		; GET DISPLACEMENT
	C    @VDATLO,R5		; DID I GET ARRAY YET?
	JEQ  CNSTLO		; BRIF YES
*
DATST5	EQU  $
	MOV  R5,@VDATLO		; SET LOCATION OF LOAD ITEM ORIGIN
	MOV  R5,@VOBJLO
	MOV  R5,R2
	MOV  @KORGRE,R5
	BL   @GLDITE		; GENERATE SET ORIGIN
*
*  CONSTANT LOOP.
*
CNSTLO	EQU  $
	MOV  @VBYTLF,R5		; ANY CONSTANT BYTES LEFT?
	JNE  DATS13		; BRIF YES
*
*  THIS IS ENTERED WHEN MORE CONSTANT INFORMATION IS NEEDED.  THIS MAY
*  COME FROM A REPEAT OF THE LAST CONSTANT INFORMATION (IF REPEAT FLAG
*  IS SET), OR NEW CONSTANT INFORMATION READ FROM THE SCRATCH FILE.
*
DATST6	EQU  $
	MOV  @VRPTCN,R5		; GET CURRENT REPEAT COUNT
	JNE  DATS12
*
	BL   @GETWOR		; GET NEXT CONSTANT FROM SCRATCH
	MOV  R5,@VRPTCN
	BL   @GETWOR
	MOV  R5,@VCNSTS
	JLT  DATST7
	NEG  R5			; MAKE SURE SIZE IS NEGATIVE
DATST7	EQU  $
	MOV  R5,@VCOUN1		; TRANSFER ITEMS TO TABLE
	A    @ADSTBT,R5
	S    @PDSLEN,R5
	JLT  B1RMOV		; BRIF OVERFLOWED
	MOV  @PDSLEN,R7		; RESET POINTER TO TOP OF CONSTANT
*
CNSTBF	EQU  $
	BL   @GETWOR		; GET NEXT WORD
	INCT R7
	MOV  R5,*R7		; SAVE IN CONSTANT SPACE
	INCT @VCOUN1		; INCREMENT # BYTES READ
	JLT  CNSTBF		; BRIF MORE
*
	MOV  @VCNSTS,R5		; SELECT LOAD ITEM FOR CURRENT
	JGT  DATS11		; BRIF ITS AN ABSOLUTE
*
*  IT IS NOT AN ABSOLUTE DATA ITEM, MUST BE AN ADDRESS LITERAL
*
	MOV  *R7,R5		; GET "POINTER" VALUE
	ANDI R5,MOPCFL		; GET OPCODE FIELD
	C    @OARYEL,R5		; IS IT AN ARRAY?
	JNE  DATST8		; BRIF NO
	S    R5,*R7		; SUBTRACT TAG FIELD FROM CONSTANT PTR
	A    @OARRAO,*R7	; OR IN THE ARRAY PTR
	BL   @GETWOR
	JMP  DATST9
B1RMOV	B    @RMOVFL
*
DATST8	EQU  $			; SET DELTA = 0 FOR ELEMENT
	CLR  R5
*
DATST9	EQU  $
	MOV  *R7,R5		; EVALUATE LITERAL POINTER
	BL   @EVALUA
	MOV  @VDISPL,*R7	; SET VALUE TO EVALUATED DISPLACEMENT
	MOV  @VAREA,R5
	A    @KDATRE,R5		; BUILD DATA RELATIVE LOAD ITEM
	MOV  R5,@VITMHD		;  HEADER USING AREA CODE
	LI   R5,2
	MOV  R5,@VCNSTS		; 2 BYTES FOR CONSTANT SIZE
	JMP  DATS12
*
DATS11	EQU  $
	CI   R5,1		; IS THIS SINGLE BYTE TRANSFER?
	JNE  DAT11A		; BRIF NO
	MOV  @KBBSLT,@VITMHD	; SET ABSOLUTE BYTE LOAD ITEM HEADER
	JMP  DATS12
*
DAT11A	EQU  $
	MOV  @KABSLT,@VITMHD	; SET ABSOLUTE INTEGER LOAD ITEM HEADER
*
DATS12	EQU  $
	MOV  @PDSLEN,R7		; RESET POINTER TO END OF CONSTANT
	DEC  @VRPTCN		; DECREMENT REPEAT COUNT AND
	MOV  @VCNSTS,@VBYTLF	;  COUNT # OF BYTES IN CONSTANT EACH
*				   TIME IT IS USED
*
*  A CONSTANT IS NOW LOADED INTO THE CONSTANT STACK AREA.  IF A SET
*  ORIGIN WAS NEEDED, THEN IT WAS ALREADY DONE.  THE ITEM HEADER IS
*  SET TO THE PROPER TYPE, EITHER ABSOLUTE OR DATA RELATIVE.
*
*  GENERATE THE CONSTANT ITEMS NEEDED.
*
DATS13	EQU  $
	INCT R7			; POINT TO FIRST CONSTANT VALUE
	MOV  R7,@PDCONS		; SAVE POINTER FOR LATER
	MOV  *R7,R2		; GENERATE NEW LOAD ITEM
	MOV  @VITMHD,R5		; GET ITEM HEADER TYPE
	C    @KBBSLT,R5		; CURRENTLY TRANSFERRING BYTES?
	JEQ  DAT13A		; BRIF YES
	MOV  @VBYTLF,R5		; GET CONSTANT SIZE LEFT
	CI   R5,1		; ONLY ONE BYTE LEFT?
	JNE  DAT13C		; BRIF NO, USE WORD TRANSFER
	MOV  @KBBSLT,R5		; ELSE, USE BYTE TRANSFER METHOD
	MOV  R5,@VITMHD
	JMP  DAT13A
*
DAT13C	EQU  $			; TRANSFER A WORD ITEM
	MOV  @VDATLO,R3		; GET DATA LOCATION I AM STORING
	ANDI R3,1		; IS IT ODD?
	JEQ  DAT13E		; BRIF NO, DO NORMAL WORD TRANSFER
*
*  I AM BEING ASKED TO DO A WORD TRANSFER TO AN ODD ADDRESS.  SINCE
*  I'M TRYING TO KEEP THE LINKER AS SIMPLE AS POSSIBLE, LET HIM NOT
*  HAVE TO DEAL WITH THIS SITUATION.  SEND OUT THE WORD AS TWO BYTE
*  VALUES.
*
	MOV  @KBBSLT,R5		; SET ABSOLUTE BYTE LOAD ITEM
	ANDI R2,>FF00		; MASK BYTE
	MOV  @FNOGEN,R3		; CURRENTLY GENERATING OBJECT?
	JEQ  DAT13F		; BRIF NO
	BL   @GLDITE		; GENERATE LOAD ITEM
DAT13F	EQU  $
	INC  @VDATLO		; INCREMENT DATA LOCATION
	DEC  @VBYTLF		; DECREMENT # OF BYTES LEFT
	DEC  @VELMBY
	MOV  @KBBSLT,R5		; SEND ANOTHER BYTE LOAD ITEM
	MOV  @PDCONS,R7		; GET BYTE VALUE AGAIN
	MOV  *R7,R2
	SWPB R2			; NOW SEND OTHER HALF
DAT13A	EQU  $
	ANDI R2,>FF00
	MOV  @FNOGEN,R3		; CURRENTLY GENERATING OBJECT?
	JEQ  DAT13B		; BRIF NO
	BL   @GLDITE
DAT13B	EQU  $
	INC  @VDATLO
	DEC  @VBYTLF
	DEC  @VELMBY
	JMP  DATS14
*
*  DAT13E:  SEND OUT A WORD AS A NORMAL WORD STORE (SIMPLE)
*
DAT13E	EQU  $
	MOV  @FNOGEN,R3		; CURRENTLY NO GENNING?
	JEQ  DAT13D
	MOV  @VITMHD,R5		; GET ITEM HEADER
	BL   @GLDITE		; GENERATE LOAD ITEM
DAT13D	EQU  $
	INCT @VDATLO		; INCREMENT DATA LOCATION
	DECT @VBYTLF		; DECREMENT # BYTES LEFT
	DECT @VELMBY		; DECREMENT ELEMENTS/BYTE
*
DATS14	EQU  $
	MOV  @PDCONS,R7		; RESTORE POINTER TO DATA ITEMS
	MOV  @VELMBY,R5
	JGT  BCNSTL
	B    @ITEMIN		; GO INITIALIZE ANOTHER ITEM
BCNSTL	B    @CNSTLO		; GO TO CONSTANT LOOP
*
*  DATSTA : END OF DATA STATEMENT PROCESSING.  IF ERROR INITIALIZING
*	    CONSTANT DATA, THEN SET ERROR IN RECORD AND RETURN.  OTHERWISE,
*	    JUST CONTINUE WITH NORMAL STATEMENT PROCESSING.
*
DATSTA	EQU  $
	MOV  @FITMCM,R5		AT END OF STATEMENT, CHECK FOR
	JEQ  MAINLO		 ATTEMPT TO INITIALIZE ITEM IN
*				 COMMON
	CLR  @FITMCM		Y - ERROR, DATA IS IN COMMON
	S    @K8,@PRECCH	ERROR MESSAGE
	SETO RTO		COUNT FOR # RECS (1)
	LI   R5,1		RETURN TO MAINLOOP
	B    @IBOS7A
	TITL 'END OF DATA REGION'
	PAGE
*
*  IENDAT : THE END OF THE DATA REGION HAS BEEN ENCOUNTERED.  DO A
*	    NUMBER OF CLEANUP ITEMS, INCLUDING GENERATING EXTERNAL
*	    DATA ITEMS, GENERATING ORIGIN INTO LOGIC, GENERATING
*	    LOGIC PROLOUGE FOR MAIN OR SUBPROGRAM.
*
IENDAT	EQU  $			END OF DATA REGION
	MOV  @PEXTRT,R5
	S    @PEXTRB,R5
	JEQ  IENDA2		OUTPUT REFERENCED ITEMS FOR
	MOV  R5,@VCOUN1		ITEMS DECLARED EXTERNAL
*
IENDA1	EQU  $
	INCT @VCOUN1		DO FOR EACH EXTERNAL LABEL
	MOV  @VCOUN1,R7
	A    @PEXTRB,R7
	BL   @M39CVR		  CONVERT NAME TO ASCII
	INCT @VCOUN1
	INCT @VCOUN1
	MOV  @VCOUN1,R2		  EXTRACT ARGUMENT INDEX
	INCT R2
	A    @PEXTRB,R2 	  CONVERT INDEX TO OFFSET IN DATA
	MOV  *R2,R5		  GET LOCATION IN
	ANDI R5,MADRFL		  DATA AREA
	AI   R5,TEMPSZ		   + TEMPS OFFSET
	MOV  R5,@VVALUE		  IS LOCATION TO STORE
	MOV  @KSPRGR,@VHEADE	  SUBPROGRAM REFERENCE
	BL   @GBCDIT		  GENERATE IT
	INCT @VCOUN1		  BUMP COUNT
	JNE  IENDA1		ENDDO
*
IENDA2	EQU  $
	MOV  @KORGLG,R5		GEN ORG INTO LOGIC
	BL   @G1WDIT
	CLR  @VLOCN		ZERO LOGIC LOCATION COUNTER AND
	CLR  @VOBJLO		RETURN TO MAINLOOP
	MOV  @FMAIN,R5		MAIN PROGRAM ?
	JEQ  MAINLO		BRIF NO
**************
*				MAIN PROGRAM :
	LI   R3,SUB01		GENERATE STARTUP CODE
	MOV  *R3+,R8		# OF WORDS TO GENERATE
	BL   @GENWRD		DO IT
*
*  FOR GPL VERSION, LOAD R7 WITH ADDRESS OF I/O BUFFER.  FOR MDOS
*  VERSION, LOAD R7 WITH FIXED ADDRESS OF I/O BUFFER
*
	IF    GENEVE
	LI    R2,USEIOB		ADDRESS OF USER I/O BUFFER
	BL    @GABSLT
	ELSE
	MOV  @VDATSI,R2 	GET ADRL TO I/O BUFFER
	A    @VCMNSI,R2 	DATA SIZE + COMMON SIZE
	MOV  @KDATRE,R5
	A    @KLOCAL,R5
	BL   @GRELAT		RELATIVE LOAD ITEM
	ENDIF
*
*  FOR GPL AND MDOS VERSIONS, GENERATE A BRANCH AND LINK TO THE
*  EXECUTION TIME INITIALIZATION.
*
	MOV  @SUB09,R2		GENERATE A BRANCH AND LINK
	BL   @GABSLT
*
*  FOR GPL VERSION, USE HARD CODED ADDRESS (CURRENTLY >3000) TO BRANCH
*  TO THE EXECUTION TIME INITIALIZATION.  MDOS VERSION GENERATES A
*  REF TO THE INITIALIZATION ROUTINE USING POINTER PINENT.
*
	UNL
	IFEQ  GENEVE
	LIST
	LI    R2,EXCSTR+4	GET EXECUTION TIME START ADDRESS
	BL    @GABSLT
	UNL
	ELSE
	LIST
	MOV  @VLOCN,@PINENT	INITIAL ENTRY POINTER
	CLR  R2			GENERATE ZERO BASE
	BL   @GABSLT
	ENDIF
	LIST	
*
*  FOR GPL AND MDOS VERSIONS, LOAD R3 WITH ADDRESS OF MAIN PROGRAM
*  DATA AREA.
*
	MOV  @SUB24,R2		GENERATE  LI R3,
	BL   @GABSLT
*
	MOV  @KDATRE,R5		WITH DATA AREA START
	A    @KLOCAL,R5
	CLR  R2
	BL   @GRELAT		POINT TO DATA AREA START
	JMP  MAINLO
*
	TITL 'LOGIC SEGMENT PROCESSING'
	PAGE

*  PROCESS THE LOGIC SEGMENT ( CODE GENERATION )
*
MAINLI	EQU  $			MAIN LOGIC INITIALIZIATION
*				INITIALIZE PEEPHOLE STACK
	MOV  @ABARRE,R7		STACK START
	LI   R8,KMBARS		COUNTER OF WORDS
NEXTBA	EQU  $
	BL   @GETWO2		FILL BARREL WITH WORDS
	MOV  R5,*R7+		SAVE WORD IN BARREL
	INC  R8			INCREMENT BARREL COUNT
	JNE  NEXTBA		BRIF MORE
*
MAINLO	EQU  $
	BL   @PEEPHO		PERFORM PEEPHOLE OPTIMIZATION
	BL   @GETWOR
	MOV  R5,RTO
	SRA  R5,7		INDEX INTO TABLE
	ANDI R5,>01FE		MASK ORDER *2
	CI   R5,MAXOPC+2	ORDER CODE TOO HIGH?
	JGT  IFUTUR		BRIF YES, INTERNAL ERROR, ABORT
	AI   R5,OPCTBL		ADD BASE
	MOV  *R5,R8		GET OPCODE
REENTE	EQU  $			RE-ENTER CODE GENERATION LOOP
	MOV  R8,R5
	MOV  R8,R3		SAVE IT
	ANDI R3,>07FF		MASK OPCODE PSEUDO ADDRESS
	A    R3,R3		*2
	AI   R3,OPCST		+ BASE
	SRA  R5,10		MOVE OPCODE
	ANDI R5,>003E		MASK IT
	AI   R5,OPCJMP		+ JUMP TABLE START
	MOV  *R5,R5		GET PROCESS ROUTINE ADDRESS
	LI   RET,MAINLO		Return for all opcodes
	BL   *R5		DO IT
*
*  GENBRA - General Branch.  In this case, the low order is an indirect
*	    pointer into the GENJMP table.
*
GENBRA	EQU  $
	ANDI R8,>00FF		Mask branch address
	AI   R8,GENJMP		+ General branch table start
	LI   RET,MAINLO
	MOV  *R8,R8		GET ADDRESS
	BL   *R8		do it
*
*  IFUTUR - Future code generation requested, generate internal error
*	    On entry, R11 should point to where the error occurred
*
CONFUS  EQU  $			Confused Entry
IFUTUR	EQU  $
	LI   R1,10		INT Error/ Compiler Fault
	B    @IOABOR
*
*  IABSL1  - GENERATE 1  ABSOLUTE ARGUMENT
*  IABSL2  - GENERATE 2  ABSOLUTE ARGUMENTS
*  IABSL3  - GENERATE 3  ABSOLUTE ARGUMENTS
*  IABSL4  - GENERATE 4  ABSOLUTE ARGUMENTS
*  IABSL5  - GENERATE 5  ABSOLUTE ARGUMENTS
*  IABSL6  - GENERATE 6  ABSOLUTE ARGUMENTS
*  IABSL8  - GENERATE 8  ABSOLUTE ARGUMENTS
*  IABSL9  - GENERATE 9  ABSOLUTE ARGUMENTS
*  IABS11  - GENERATE 11 ABSOLUTE ARGUMENTS
*  IABS12  - GENERATE 12 ABSOLUTE ARGUMENTS
*  IABS14  - GENERATE 14 ABSOLUTE ARGUMENTS
*  IABS15  - GENERATE 15 ABSOLUTE ARGUMENTS
*
IABSL1	EQU  $
	LI   R8,1
	JMP  ABSCOM
*
IABSL2	EQU  $
	LI   R8,2
	JMP  ABSCOM
*
IABSL3	EQU  $
	LI   R8,3
	JMP  ABSCOM
*
IABSL4	EQU  $
	LI   R8,4
	JMP  ABSCOM
*
IABSL5	EQU  $
	LI   R8,5
	JMP  ABSCOM
*
IABSL6	EQU  $
	LI   R8,6
	JMP  ABSCOM
*
IABSL8	EQU  $
	LI   R8,8
	JMP  ABSCOM
*
IABSL9	EQU  $
	LI   R8,9
	JMP  ABSCOM
*
IABS11	EQU  $
	LI   R8,11
	JMP  ABSCOM
*
IABS12	EQU  $
	LI   R8,12
	JMP  ABSCOM
*
IABS14	EQU  $
	LI   R8,14
	JMP  ABSCOM
*
IABS15	EQU  $
	LI   R8,15
	JMP  ABSCOM
*
*  ILOGIC - Logical construct
*
ILOGIC	EQU  $
	MOV  *R3+,R8		Get # words to generate
*
ABSCOM	EQU  $
	BL   @GENWRD		Generate an absolute word string
	B    *RET
*
*  GENERATE SPECIAL SUBROUTINE REFERENCE.  THERE ARE THREE COMMANDS
*  AS FOLLOWS:
*
*   GENRFN  :  IGENRN  :  SPECIAL REFERENCE
*   GENRFT  :  IGENRT  :  SPECIAL REFERENCE W/ARGUMENT
*   GENRFC  :  IGENRC  :  SPECIAL REFERENCE W/ARGUMENT & COUNT
*
*  GENRFC HAS SPECIAL ATTRIBUTE THAT AN INDIRECT ARGUMENT WILL CAUSE
*  THE SPECIAL REFERENCE POINTER TO BE INCREMENTED BY 1 (AS THE INDIRECT
*  FORM OF THE CALL FOLLOWS THE DIRECT CALL VERSION).
*
IGENRN	EQU  $			NO ARGUMENT
	CLR  R5			SET NO ARGUMENTS
	JMP  IGENCO
*
IGENRC	EQU  $
	LI   R5,-2		SET TWO ARGUMENTS
	ANDI RTO,1		IS THIS AN INDIRECT FORM?
	JEQ  IGENCO		BRIF NO
	INCT R8			ELSE, INCREMENT THE POINTER
	JMP  IGENCO
*
IGENRT	EQU  $
	SETO R5			SET ONE ARGUMENT
*
IGENCO	EQU  $			COMMON GENERATION POINT
	MOV  R5,@VNOARG		SET # OF ARGUMENTS TO GEN
	MOV  @SUB09,R2		GENERATE A BRANCH AND LINK
	BL   @GABSLT
*
	ANDI R8,>FF		MASK OFFSET
	AI   R8,PSPSTA		 + POINTERS START
	MOV  *R8,R2		GET CURRENT USED POINTER LOCATION
	MOV  @VLOCN,*R8		 AND SAVE MY NEW LOCATION IN POINTER
	MOV  R2,R2		WAS THERE ANYTHING THERE?
	JNE  GENRLO		BRIF NO, USE RELATIVE
	BL   @GABSLT		ELSE, GEN AN ABSOLUTE ZERO TO ANCHOR CHAIN
	JMP  GENRMO
GENRLO	EQU  $
	MOV  @KPRGRE,R5
	BL   @GRELAT
GENRMO	EQU  $
	INC  @VNOARG		CHECK NUMBER OF ARGUMENTS LEFT
	JGT  GENEXI		BRIF DONE
	BL   @EVALPT		EVALUATE THE POINTER FOLLOWING
	BL   @GADRL		GENERATE AN ADDRESS
	INC  @VNOARG		CHECK NUMBER OF ARGUMENTS LEFT
	JGT  GENEXI		BRIF DONE
	BL   @GETWOR		GET WORD COUNT (USELESS IN THIS TI VERSION)
GENEXI	B    *RET		RETURN
*
*  RUNTIME REFERENCES : THERE ARE TWO COMMANDS AS FOLLOWS:
*
*   RUNTIN  :  IRUNIN  :  EXECUTION REFERENCE
*   RUNTIC  :  IRUNIC  :  EXECUTION REFERENCE W/ARGUMENT AND COUNT
*
IRUNIC	EQU  $
	BL   @GETWOR            GET # OF WORDS WHICH FOLLOW (UNUSED
*				 IN CURRENT TI VERSION OF COMPILER)
IRUNIN	EQU  $
	MOV  @SUB02,R2  	GENERATE EXECUTION REFERENCE CALL
	BL   @GABSLT
	MOV  *R3+,R2    	GET EXECUTION REFERENCE INDEX NUMBER
	BL   @GABSLT
	B    *RET
*
*  IINSTR - GENERATE AN INSTRUCTION WITH ARGUMENT
*
IINSTR	EQU  $			GENERATE AN INSTRUCTION
	MOV  @ABARRE,R6		GET THE ARGUMENT TYPE
	MOV  *R6,R5
	ANDI R5,MTAGFL
	CI   R5,BYTYPE		IS IT A BYTE ARGUMENT?
	JEQ  COMPOF		BRIF YES
	AI   R3,6		SKIP BYTE ARGUMENTS
	CI   R5,INTYPE		IS IT AN INTEGER ?
	JEQ  COMPOF		BRIF YES
	CI   R5,LGTYPE		IS IT LOGICAL *2?
	JEQ  COMPOF		BRIF YES
	AI   R3,6		SKIP INTEGER *2 ARGUMENTS
	CI   R5,I4TYPE		IS IT INTEGER *4?
	JEQ  GENIN4		BRIF YES, GENERATE INTEGER *4
	INCT R3
	CI   R5,SPTYPE		IS IT SINGLE PRECISION?
	JEQ  GENIN4		BRIF YES
	INCT R3
	CI   R5,DPTYPE		IS IT DOUBLE PRECISION?
	JEQ  GENIN4		BRIF YES
	INCT R3
	CI   R5,C8TYPE
	JEQ  GENIN4		BRIF COMPLEX *8
	INCT R3
	CI   R5,C6TYPE		IS IT COMPLEX *16?
	JNE  BFUTUR		I DON'T KNOW WHAT IT IS
GENIN4	EQU  $
	MOV  @SUB04,R2		GEN DIRECT FORM OF INSTRUCTION
	MOV  RTO,R5
	ANDI R5,1		Is this an indirect form?
	JEQ  ISASP1		BRIF A DIRECT FORM
	MOV  @SUB05,R2		ELSE, GEN INDIRECT FORM
ISASP1	EQU  $
	BL   @GABSLT		GEN IT
	BL   @EVALPT		Evaluate the pointer
	BL   @GADRL		Generate the resultant address
	MOV  *R3,R8
	B    @REENTE		RE-ENTER CODE GENERATION LOOP
BFUTUR  BL   @IFUTUR
*
*  IGENCV - Generate Conversion
*
IGENCV	EQU  $
	MOV  RTO,R5		GET CONVERSION DESIRED
	ANDI R5,>00F0		"TO" CONVERSION
	A    R5,R3
	MOV  RTO,R6
	ANDI R6,>000F		"FROM" CONVERSION
	SLA  R6,1
	A    R6,R3
	MOV  *R3,R8		GET CONVERSION TYPE
BREENT	EQU  $
	B    @REENTE		RE-ENTER CODE GENERATION
*
*  COMPOF - INLINE INSTRUCTION, COMPUTE OFFSET INTO TABLE BASED ON
*	    CONSTANT, DIRECT, OR INDIRECT FORM
*
COMPOF	EQU  $
	BL   @EVALPT		EVALUATE THE RESULTING ADDRESS
	MOV  @SUB04,R2		GET CONSTANT/DIRECT FORM OF COMMAND
	MOV  @VAREA,R5		IS THE ELEMENT ALLOCATED IN PROGRAM AREA?
	JEQ  NOTCON		BRIF NO
	JGT  NOTCON		DITTO
	INC  R5
	JNE  ACONST		BRIF IT'S A CONSTANT
NOTCON	EQU  $
	INCT R3			SKIP CONSTANT FORM
NOTCO1	EQU  $
	MOV  RTO,R5		IS THIS VALUE INDIRECT?
	ANDI R5,1
	JEQ  ACONST		BRIF YES
	INCT R3			ELSE, SKIP DIRECT FORM OF INSTRUCTION
	MOV  @SUB05,R2		AND LOAD INDIRECT FORM START OF COMMAND
ACONST	EQU  $
	MOV  *R3,R5		GET INSTRUCTION THAT WILL BE EXECUTED
	MOV  *R3,R8
	SRA  R5,10		SHIFT INSTRUCTION OPCODE
	ANDI R5,>003E		MASK OPCODE *2
*
*  IF A GENERAL ONE WORD ARGUMENT FORM, OR A GENERAL TWO WORD ARGUMENT
*  FORM, THEN RECALL THE GENADL OR GENAD2 SUBEXPRESSION TYPE TO GENERATE
*  THE DESIRED INSTRUCTION AND ADDRESSES.
*
	CI   R5,GENEQU		IS THIS A GENERAL FORM?
	JEQ  BREENT		YES, GO REENTER WITH NEW OPCODE
	CI   R5,GENEQ2		IS THIS A GENERAL 2 WORD INSTRUCTION?
	JEQ  BREENT		BRIF YES
*
*  THIS IS NOT A GENERAL INSTRUCTION FORM.   IT MUST BE SOMETHING LIKE
*  AN ABSOLUTE # OF WORDS TO GENERATE.   GENERATE THE LI R2,X PREAMBLE,
*  AND THEN GENERATE THE FOLLOWING WORDS.
*
NOTGE2	EQU  $
	BL   @GABSLT		ELSE, GENERATE DESIRED INSTRUCTION
	BL   @GADRL		      GENERATE ADDRESS
	MOV  *R3,R8		      STUB START
	JMP  BREENT		      AND THEN REENTER
*
*  IDATA - Generate absolute data words
*
IDATA	EQU  $	     		GENERATE ABSOLUTE DATA WORDS
	ANDI RTO,>00FF
	INV  RTO		INITIALIZE COUNT SPECIFIED IN LOW
*
DATALO	EQU  $			For each data word:
	BL   @GETWOR
	MOV  R5,R2
	BL   @GABSLT		Generate an absolute value
	INC  RTO
	JNE  DATALO		When all data done, return
	B    *RET
*
*  IDELTA - Generate delta reference
*
IDELTA	EQU  $
	BL   @GETWOR		Get the delta value
	MOV  R5,@VDELTA   	and save it
	B    *RET
*
*  IPERIO - Generate I/O reference
*
IPERIO	EQU  $
	MOV  *R3,R5		GET OPCODE TO GENERATE
	ANDI RTO,1		IS THIS INDIRECT?
	JEQ  IPERI1		BRIF NO
	ORI  R5,>8000		OR IN INDIRECT BIT
IPERI1	EQU  $
	MOV  @ABARRE,RTO	GET ARGUMENT TYPE
	MOV  *RTO,RTO
	ANDI RTO,MTAGFL		MASK ARGUMENT TYPE
	SLA  RTO,1		IN 2ND NIBBLE
	SOC  R5,RTO		OR IT IN WORD TO SAVE
	MOV  @SUB02,R2  	GENERATE EXECUTION TIME CALL
	BL   @GABSLT
	MOV  RTO,R2
	BL   @GABSLT		GENERATE INDEX, INDIRECT, & OPCODE
	JMP  IADRL
*
*  IGENAD - Generate absolute word and single address
*
IGENAD	EQU  $
	MOV  *R3,R2		Get word to generate
	BL   @GABSLT
	JMP  IADRL1
*
*  IGENA2 - GENERATE TWO WORD INSTRUCTION FORM
*
IGENA2	EQU  $
	MOV  *R3,R2		GET WORD TO GENERATE
	BL   @GABSLT		GENERATE ABSOLUTE WORD
	BL   @GADRL		GENERATE ADDRESS
	JMP  IADRL		AND GENERATE 2ND ADDRESS
*
*  IADRL - Generate an address
*
IADRL	EQU  $
	BL   @EVALPT		Evaluate the pointer
IADRL1	EQU  $
	BL   @GADRL		Generate the resultant address
	B    *RET		  done
*
*  GADRL - Generate an address literal subroutine
*
GADRL	EQU  $
	MOV  R11,@PGENXI  	Save return vector
	MOV  @VAREA,R5
	JLT  GENAD1		Item in data region
	A    @KDATRE,R5
	MOV  @VDISPL,R2
	BL   @GRELAT
	JMP  GADR1A
*
GENAD1	EQU  $
	INC  R5	    		Item in absolute memory
	JEQ  GENAD2
	INC  R5
	JEQ  GENA1B
	INC  R5
	JEQ  GENA1C
	MOV  @KDATRE,R5 	VAREA = -6, Common area load
	JMP  GENA1D
GENA1C	EQU  $
	MOV  @KLCLRE,R5 	VAREA = -5, Immediate data area load
GENA1D	EQU  $
	MOV  @VDISPL,R2
	BL   @GRELAT
	JMP  GADR1A
*
GENA1B	EQU  $	     		VAREA = -2, Immediate load
	MOV  @VDISPL,R2 	Generate an absolute load item
	BL   @GABSLT		with value of DISPL
	JMP  GADR1A
*
GENAD2	EQU  $
	MOV  @VDISPL,R5 	Item is in program region
	JLT  GENA2A
	MOV  R5,R2
	JMP  GENA2B
*
GENA2A	EQU  $
	MOV  @PADRAD,R2
	MOV  *R2,R2
	JEQ  GENA2C
*
GENA2B	EQU  $
	MOV  @KPRGRE,R5
	JMP  GENA2D
*
GENA2C	EQU  $
	MOV  @KABSLT,R5
*
GENA2D	EQU  $
	BL   @GLDITE		0 -- Generate absolute
	MOV  @VLOCN,R5
	MOV  @PADRAD,R6
	INCT @VLOCN		Increment location counter
	MOV  R5,*R6
*
GADR1A	EQU  $
	MOV  @PGENXI,R11
	B    *R11
*
*  ILABEL - Process a label definiton
*
ILABEL	EQU  $			LABEL DEFINITION
	BL   @GETWOR
	MOV  R5,@VPTR   	MADE LABEL -- DEFINE AT CURRENT
	ANDI R5,MOPCFL   	VALUE OF VLOCN
	MOV  R5,R1
	MOV  @VPTR,R5
	ANDI R5,MADRFL
	C    @OPRGLB,R1
	JNE  ILABE1		PROGRAM LABEL:
	SLA  R5,3
	A    @PLBLTO,R5 	IF MISUSED, WITHHOLD DEFINITION
	MOV  R5,R2	 	(RESOLVE TO END LOGIC)
	INCT R2
	MOV  *R2+,R5		IF FORMAT LABEL, GENERATE FORMAT
	ANDI R5,MTAGFL		FORMAT BRANCH AROUND, THEN DEFINE
	C    @KFORMT,R5		LABEL AT NEW VALUE OF VLOCN.
	JGT  ILABE2
	JNE  LABELR
	MOV  R2,@VPTR
	BL   @GETWOR
	JMP  IFORM1
*
ILABE1	EQU  $
	SLA  R5,2		OTHERWISE, SIMPLY DEFINE LABEL
	A    @PMLBLT,R5  	AT CURRENT VALUE OF VLOCN
	MOV  R5,R2
*
ILABE2	EQU  $	     		TO DEFINE LABEL:
	MOV  @VLOCN,@2(R2) 	SET DEFINITION VALUE
	MOV  @4(R2),R5
	JEQ  LABELR
	BL   @GACHAI		RESOLVE ANY OPEN ADRL CHAIN
*				FOR BRANCH TO LABEL
*
LABELR	EQU  $
	B    *RET
*
*  IFORMA - Process format statement
*
IFORMA	EQU  $			FORMAT STATEMENT WITHOUT LABEL
	CLR  @VPTR		  (LABEL WAS MISUSED)
*
IFORM1	EQU  $			FORMAT STATEMENT WITH LABEL
	BL   @GETWOR
	INC  R5
	MOV  R5,@VCOUN1 	GET WORD COUNT
	CI   R5,>80		GENERATE FORMAT BRANCH AROUND
	JLT  IFORM2
*   LONG BRANCH (E.G. B @X) CAUSE FORMAT TOO LONG FOR SHORT
	MOV  @SUB03,R2
	BL   @GABSLT
	MOV  @VCOUN1,R2
        SLA  R2,1               *2 FOR BYTE COUNT
	A    @VLOCN,R2
	MOV  @KPRGRE,R5 	WORD COUNT <255
	BL   @GRELAT
	JMP  IFORM3		GENERATE DIRECT BRANCH
*   SHORT BRANCH (E.G. JMP X) CAUSE FORMAT IS SHORT
IFORM2	EQU  $
	DEC  R5
	MOV  R5,R2
	A    @SUB07,R2  	RELATIVE JUMP
	BL   @GABSLT
*
IFORM3	EQU  $
	MOV  @VPTR,R5   	IF VALID FORMAT LABEL, DEFINE
	JEQ  IFORM4		AT CURRENT VALUE OF VLOCN
	MOV  R5,R2
	MOV  @VLOCN,@2(R2) 	SET DEFINITION VALUE
	MOV  @4(R2),R5
	JEQ  IFORM4		RESOLVE ANY OPEN FORMAT REF
	BL   @GACHAI		ADRL CHAIN
*
IFORM4	EQU  $
	DEC  @VCOUN1    	INITIALIZE (-COUNT) FOR STATEMENT
	NEG  @VCOUN1		GENERATION LOOP
*
IFORM5	EQU  $			GET FORMAT WORD
	BL   @GETWOR
	MOV  R5,RTO
	MOV  R5,R2
	BL   @GABSLT		GENERATE ABSOLUTE LOAD ITEM
*			 	IF HOLVAR PSEUDO:
	C    @KHOLVA,RTO
	JNE  IFORM6
	BL   @GETWOR		GET POINTER FROM FOLLOWING
	ANDI R5,MADRFL  	 WORD
	SLA  R5,1
	A    @PHVRTO,R5 	GET VARIABLE ADDRESS FROM
	MOV  R5,R2		HOLVAR TABLE
	INCT R2
	MOV  *R2,R2
	MOV  @KLCLRE,R5 	GENERATE LOCAL-DATA-RELATIVE
	BL   @GRELAT		ADDRESS LITERAL
	INC  @VCOUN1
*
IFORM6	EQU  $
	INC  @VCOUN1    	REPEAT FOR NEXT FORMAT WORD
	JNE  IFORM5
	B    *RET		DONE -- RETURN TO MAIN LOOP
*
*  IFUNCE - Function call end
*
IFUNCE	EQU  $	     
	BL   @EVALPT
	MOV  @SUB05,R2
	BL   @GABSLT   		Generate MOV @temp,R6
	BL   @GADRL
	MOV  *R3+,R8    	Get # words to generate and
	BL   @GENWRD		generate remaining words
	B    *RET
*
*  Generate all branch type instructions.
*
*  There are two cases of branch type instructions, based on the
*  following:
*
*  1. If the requested "branch to" location is defined, and the
*     location is within 256 bytes of the current location, generate
*     a backwards relative reference.
*
*  2. Otherwise, generate a long form of the branch.
*
*  Five types of branches are possible:
*
*	 B     -  JMP OR B
*	 JLT   -  JLT OR JGT & B
*	 JEQ   -  JEQ OR JNE & B
*	 JNE   -  JNE OR JEQ & B
*	 JGT   -  JGT OR JLT & B
*
IBRANC	EQU  $
	BL   @EVALPT		Get address to branch to
	ANDI RTO,1		Indirect requested?
	JNE  BLONGF		brif yes
	MOV  @VDISPL,R2 	Else, check the displacement
	JLT  BLONGF		If not yet defined, its a long branch
	S    @VLOCN,R2  	Else, subtract current location
	DECT R2
	SRA  R2,1		convert to a word displacement
	CI   R2,>FF80
	JLT  BLONGF		If out of range, use long form
	ANDI R2,>00FF		Mask displacement
	A    *R3,R2		and generate and absolute instruction
	BL   @GABSLT
	B    *RET
*
BLONGF	EQU  $
	INCT R3			Skip short form of instruction
	MOV  *R3+,R8		Generate basic part of instruction
	BL   @GENWRD
	B    @IADRL1
*
*  ILIST - listing flag on/off
*
ILISTO	EQU  $
	ANDI RTO,>F
	MOV  RTO,@FLSTFL
	B    *RET
*
*  IBOS  -  Beginning of a statement
*	    Log statement, with errors (if any)
*
IBOS 	EQU  $
	ANDI RTO,>00FF		Initialize count of records
	NEG  RTO
	BL   @GETWOR
	MOV  R5,@PERRMS		Error message number (0 is no error)
	BL   @GETWOR
	MOV  R5,@PERRCH
	CLR  @PRECCH
*
IBOS1	EQU  $
	BL   @CHECKP    	CHECK FOR PAGE OVERFLOW
	LI   R6,TFORMA  	START OF LINE
	MOV  R5,*R6+    	SET BLANK
	MOV  @BLANK,*R6 	CLEAR NEXT WORD
	A    @K80,@PRECCH 	UPDATE ERROR CHARACTER #
	INC  @VREC		INCREMENT RECORD #
	JNE  IBOS4		1ST RECORD, NO IMAGE TO ECHO
	MOV  @PERRMS,R5 	PRINT ERROR LINE (IF ANY)
	JEQ  IBOS8		NONE, SKIP EVERYTHING
	JMP  IBOS5		ELSE, PRINT ERROR LINE
*
IBOS4	EQU  $
	MOV  @VREC,R5		INSERT RECORD # IN BUFFER
	BL   @CVTNUM		CONVERT IT TO DECIMAL
	DATA TREC
	LI   R4,X1READ		Read value from scratch 1
	BLWP @FIOC
	JEQ  PRINLI		PRINT LINE
	B    @IOABOR		ELSE, I/O ERROR (ABORT)
PRINLI	EQU  $
	ABS  @FLSTFL		LISTING OFF?
	JNE  IBOS6		BRIF YES
	BL   @PRINT
	DATA 3
	DATA TFORMA
*
IBOS6	EQU  $			OUTPUT STMT LINE ON SCREEN IF ERROR
	MOV  @PERRMS,R5		  OR WARNING
	JEQ  IBOS8
	BL   @PRINT
	DATA 6			TO SCREEN
	DATA TFORMA		USING FORMAT
*
IBOS5	EQU  $			OUTPUT WARNING TO PRINTER (& SCREEN)
	MOV  @PERRMS,R8 	GET WARNING #'S
	ANDI R8,>00FF
	JEQ  IBOS7
	BL   @BLALIN		BLANK PRINT LINE
	LI   R5,WARNIN		MOVE MESSAGE 14
	BL   @MOVETX
	DATA TREC		TO FORMAT +4
	SLA  R8,12		PUT BIT IN HIGH
	LI   R7,-2
IBOS5L	EQU  $
	INCT R7
	SLA  R8,1		IS WARNING HERE?
	JEQ  IBOS7		IF ZERO, DONE
	JGT  IBOS5L
	MOV  @OFFWAR(R7),R5
	BL   @MOVETX
	DATA PRINB2
	ABS  @FLSTFL		LISTING FLAG
	JNE  IBOS5M
	BL   @PRINT		PRINT WARNING
	DATA 3			TO PRINTER
	DATA TFORMA
IBOS5M	EQU  $			PRINT ON SCREEN
	BL   @PRINT
	DATA 6
	DATA TFORMA
	INC  @VCWARN		INCREMENT # OF WARNINGS
	JMP  IBOS5L
IBOS7	EQU  $			PRINT ERROR MSG IF ERR LINE JUST PRINTED
	C    @PRECCH,@PERRCH
	JLT  IBOS8
IBOS7A  EQU  $
	MOV  @PERRMS,R8		GET ERROR #
	SWPB R8
	ANDI R8,>00FF
	JEQ  IBOS8		BRIF NO ERROR
	CI   R8,ERRMAX		EXCEED MAXIMUM PERMISSABLE ERROR?
	JLT  IBOS7B		BRIF NO
	LI   R8,ERRMAX		USE MAXIMUM ERROR FOR THIS MESSAGE
IBOS7B	EQU  $
	BL   @BLALIN		BLANK PRINT BUFFER
	LI   R5,WERROA		PUT '* ERROR *'	TEXT IN BUFFER
	BL   @MOVETX
	DATA TREC
	SLA  R8,1		ERROR MESSAGE *2
	MOV  @OFFERR-2(R8),R5
	BL   @MOVETX		MOVE ERROR TEXT
	DATA PRINB2
	ABS  @FLSTFL		LIST FLAG
	JNE  IBOS5B		BRIF NOT ON PRINTER
	BL   @PRINT
	DATA 3			ON PRINTER
	DATA TFORMA
IBOS5B	EQU  $
	BL   @PRINT
	DATA 6			ON SCREEN
	DATA TFORMA
	INC  @VCERRS		INCREMENT # OF ERRORS
*
IBOS8	EQU  $
	INC  RTO
	JNE  BBOS1
	LI   R5,VHEADE  	BUILD A 3 WORD LINE # PACKET
	MOV  @KDBGLI,*R5+ 	HEADER WORD ('6203'X)
	MOV  @VLOCN,R1  	RELATIVE OFFSET
	BL   @ADJUST
	MOV  R1,*R5+
	MOV  @VREC,*R5+ 	RECORD #
	BL   @GDEBUG		GENERATE DEBUG PACKET (IF APPROPRIATE)
	B    *RET
BBOS1	EQU  $
	B    @IBOS1
*
*  ADJUST - ADJUST R1 (VLOCN) IF SUBR OR PROGRAM
*
ADJUST	EQU  $
	MOV  R1,R1		FIRST WORD?
	JNE  ADJRET		BRIF NO
	ABS  @FMAIN		MAIN PROGRAM?
	JEQ  ADJSUB		BRIF NO
	AI   R1,PROLEN		ELSE, ADD N BYTES FOR PROLOUGE
	JMP  ADJRET
ADJSUB	EQU  $
	AI   R1,4		4 BYTES FOR SUBROUTINES
ADJRET	EQU  $
	B    *R11		RETURN
*
*
*  HEXCVT -    Convert hex number to ASCII and save 4 digit string
*		in buffer address passed in R2.
*
HEXCVT	EQU  $	     		CONVERT HEX # TO ASCII
	LI   R6,-4	 	4 DIGITS TO CONVERT
CVTNLO	SRC  R5,16-4     	 GET NEXT NIBBLE
	MOV  R5,R4
	ANDI R4,>F		MASK NIBBLE
	CI   R4,9		IS IT A NUMBER ?
	JGT  ISLETE		BRIF NO, ITS A LETTER
	AI   R4,>30		NUMBER - ADD ASCII '0'
	JMP  GETNCC
ISLETE	EQU  $
	AI   R4,>41-10		LETTER - ADD ASCII 'A' -10
GETNCC	EQU  $
	SWPB R4	    		SAVE ASCII
	MOVB R4,*R2+
	INC  R6	    		DONE ?
	JNE  CVTNLO		BRIF NO
	B    *R11		ELSE, RETURN
*
*  CVTNUM - Convert an integer number to an ASCII string
*  CVTLBL - Convert a program label number to an ASCII string
*	    (same as CVTNUM, but handles up to +99999 in two words)
*
CVTNUM	EQU  $
	CLR  R4
CVTLBL	EQU  $
	MOV  *R11+,R1		GET BUFFER ADDRESS
	MOV  @EBLANK,*R1+
	LI   R12,TENTBL
	MOV  R5,R5
	JLT  GEN5DI
	CI   R5,10000		IS IT LESS THAN 10000 ?
	JLT  GEN4DI		YES, GEN 4 DIGITS
GEN5DI	EQU  $
	LI   R0,-5		5 DIGITS TO CONVERT
	JMP  NXTDIG
GEN4DI	EQU  $	     		GEN 4 DIGITS
	INCT R12		TENS TABLE
	LI   R0,-4		4 DIGITS TO CONVERT
	MOVB @EBLANK,*R1+ 	BLANK FIRST DIGIT
*
NXTDIG	MOV  *R12+,R6    	GET TENS TABLE
	DIV  R6,R4		NUM = NUM/TENTBL(I)
	AI   R4,>30			+ ASCII 0
	SWPB R4
	MOVB R4,*R1+    	SAVE IN OUTPUT BUFFER
	CLR  R4
	INC  R0
	JNE  NXTDIG		BRIF MORE DIGITS
	MOVB @EBLANK,*R1+ 	SET LAST AS BLANK
	B    *R11		RETURN
*
*  NEWOBJ - Writes an object record to the disk file
*
NEWOBJ	EQU  $
	LI   R6,NEWREC
	MOV  R11,*R6+
	MOV  R2,*R6
	MOV  @VRMNOB,R1		CLEAR REMAINDER OF BUFFER
	MOV  @PNXTIT,R2
	MOV  @VRMNOB,R1
	JEQ  CLREND
	CLR  R5
CLRLO1	EQU  $
	MOVB R5,*R2+		CLEAR A BYTE
	INC  R1
	JNE  CLRLO1		BRIF MORE
*
CLREND	EQU  $
	CLR  @LCHKSU		IGNORE ANY CHECKSUMMING
	INC  @VSEQNO
	MOV  @VSEQNO,R5 	SEQUENCE NUMBER
	BL   @CVTNUM
	DATA LSEQNO		IN BUFFER
*
	LI   R4,BOPUNC  	WRITE BUFFER
	BLWP @CIO$
	JNE  BIOAL1		BRIF I/O ERROR
*
	LI   R5,PUNCHB
	MOV  R5,@PNXTIT		SET NEXT ITEM
	LI   R6,LCHKSU
	S    R6,R5
	MOV  R5,@VRMNOB		SET - BYTES IN BUFFER
	LI   R2,NEWREC
	MOV  *R2+,R11
	MOV  *R2,R2
	B    *R11		RETURN
BIOAL1	B    @IOABOR
*
*  EVALPT - Evaluate pointer to data element
*
EVALPT	EQU  $
	MOV  R11,@PEVALX
	BL   @GETWOR		GET POINTER
	MOV  @PEVALX,R11
*
EVALUA	EQU  $
	CLR  @MODFLG		SET NOT MODADR CELL
	JMP  EVALCO		EVALUATE CONTINUATION
EVALMO	EQU  $
	SETO @MODFLG		SET IS MODADR CALL
EVALCO	EQU  $
	MOV  R5,@VPTR		SAVE POINTER
	ANDI R5,MOPCFL		SET INDEX FOR SPECIFIED TABLE
	LI   R2,OPFIEL-TOPFLD	BY POSITION OF POINTER'S OP-
*				FIELD WITHIN OPFIELD TABLE
CKNXPT	C    @TOPFLD(R2),R5
	JEQ  CKNXEN
	INCT R2
	JNE  CKNXPT
*
CKNXEN	EQU  $
	MOV  @VPTR,R5		EXTRACT ADDRESS FIELD (GROUP #)
	ANDI R5,MADRFL		FROM POINTER
	MOV  @TPTRS(R2),R6
	B    *R6
*				EVALPT BRANCH TABLE (BY PTR TYPE)
*			   	ORDER MATCHES TOPFLDS
*
	DATA LOCARE		   LOCAL DATA AREA
	DATA GDUMMY		 2 TEMP ITEM
	DATA ATEMP		 3 ADDRESS TEMP
	DATA CTEMP		 4 CALCULATION TEMP
	DATA MODADR		 5 ITEM NOT YET ALLOCATED
	DATA LABELF		 6 USER LABEL
	DATA MLBL		 7 MADE LABEL
	DATA FXCON		 8 FIXED CONSTANT
	DATA BYCON		 9 BYTE CONSTANT
	DATA SPCON		10 SINGLE PRECISION CONSTANT
	DATA DPCON		11 DOUBLE PRECISION CONSTANT
	DATA I4CON		12 INTEGER *4 CONSTANT
	DATA C8CON		13 COMPLEX *8 CONSTANT
	DATA C6CON		14 COMPLEX *16 CONSTANT
	DATA PROGRM		15 ITEM DEFINED AFTER LOGIC
	DATA CONFUS		16 LOCAL SUBPROGRAM
	DATA GSPROG		17 EXTERNAL SUB PROGRAM
	DATA CONFUS		18 EXTERNALS
	DATA SCALAR		19 SCALARS
	DATA ARRAY		20 ARRAYS
TPTRS	DATA CONFUS
*
BYCON	EQU  $			BYTE CONSTANT
	INC  R5
	SLA  R5,2		(STORED AS INTEGER CONSTANT, HIGH BYTE)
	A    @PBYCTO,R5
	JMP  FXCON0
*
FXCON	EQU  $			INTEGER *2 CONSTANT
	INC  R5
	SLA  R5,2
	A    @PFXCTO,R5
FXCON0	EQU  $
	MOV  R5,@PADRAD
	DECT R5
	MOV  *R5,@VDISPL 	SAVE CONSTANT VALUE
FXCON1	EQU  $
	MOV  @KM2,@VAREA  	SET AREA=-2, IMMEDIATE ADDRESSING
	B    *R11		RETURN
*
MLBL 	EQU  $			MADE LABEL
	INC  R5
	SLA  R5,2		ITEM ALLOCATED WITHIN LOGIC
	A    @PMLBLT,R5
	MOV  R5,@PADRAD		SET AREA CODE TO -1
	DECT R5
	MOV  *R5,R5		MAKE DISPLACEMENT FROM LAST-
	JMP  LABELA	 	 APPEARANCE CELL OF ENTRY
*
*  SPCON  : SINGLE PRECISION FLOATING POINT CONSTANT
*  I4CON  : INTEGER *4 DOUBLE WORD CONSTANT
*
SPCON	EQU  $			SINGLE PRECISION FP CONSTANT REFERENCE
I4CON	EQU  $			INTEGER *4 CONSTANT
	LI   R6,3
	JMP  SDCON
*
C8CON	EQU  $			COMPLEX *8 CONSTANT
DPCON	EQU  $			REAL    *8 CONSTANT
PROGRM	EQU  $			PROGRAM    CONSTANT
GSPROG	EQU  $			GOSUB      CONSTANT
	LI   R6,5
	JMP  SDCON
*
C6CON	EQU  $
	LI   R6,9		COMPLEX *16 CONSTANT
SDCON	EQU  $
	INC  R5
	MOV  R5,R4		EACH PACKET 5 WORDS LONG
	MPY  R6,R4	
	SLA  R5,1
	A    @TBLTOP(R2),R5
	MOV  R5,@PADRAD 	SET POINTER TO ADDRESS CHAIN CELL
	SETO @VDISPL    	SET AREA CODE & DISPLACEMENT
SDCON1	EQU  $
	SETO @VAREA		TO -1
	B    *R11
*
*  GDUMMY :  GLOBAL DUMMY (PASSED ARGUMENT TO SUBROUTINE)
*  ATEMP  :  ADDRESS TEMPORARY
*  CTEMP  :  CALCULATION TEMPORARY (WHICH IS SIZEOF VARIABLE NEEDED)
*
GDUMMY	EQU  $
ATEMP	EQU  $
CTEMP	EQU  $
	SLA  R5,1		*2, SINCE I HAVE AN ARGUMENT NUMBER HERE
	A    @TBLTOP(R2),R5	ADD AREA OFFSET START
LOCARE	EQU  $			STRAIGHT DATA AREA START
	MOV  R5,@VDISPL
	MOV  @KLOCAL,@VAREA
	B    *R11
*
*  SCALAR :  SINGLE SCALAR VALUE IN DATA AREA
*  ARRAY  :  ARRAY VALUE
*
SCALAR	EQU  $			ITEM ALLOCATED IN A DATA AREA
ARRAY	EQU  $
	INC  R5
	MOV  R5,R4
	MPY  @K10,R4
	DECT R5
	A    @TBLTOP(R2),R5
	MOV  R5,R2
	MOV  *R2+,R5
	ANDI R5,>F
	SWPB R5
	MOV  R5,@VAREA		TO COVER ARRAY DELTA CASE:
	MOV  *R2,R5
	A    @VDELTA,R5		ADD ANY DELTA VALUE TO VDISPL
	MOV  R5,@VDISPL
	MOV  @MODFLG,R1
	JEQ  BRETCL
	MOV  @VAREA,R1		100 FOR LOCAL, 0 FOR COMMONS
	JEQ  ITSCOM
	LI   R1,-3		SET VAREA=-3, IMMEDIATE LOCAL AREA
	JMP  ITSCCN
ITSCOM	EQU  $
	LI   R1,-4	 	SET VAREA=-4, IMMEDIATE COMMON AREA
ITSCCN	EQU  $
	MOV  R1,@VAREA		DATA AREA LOAD
BRETCL	EQU  $
	CLR  @VDELTA		ZERO DELTA VALUE CELL
	B    *R11
*
*
LABELF	EQU  $			PROGRAM LABEL
	INC  R5
	SLA  R5,3
	A    @PLBLTO,R5 	SET AREA CODE TO -1
	MOV  R5,@PADRAD
	DECT R5	    		NON-EXECUTE REFERENCE:
	MOV  R5,R2
	MOV  *R2,R5		GET DISPLACEMENT FROM TABLE ENTRY
LABELA	EQU  $
	MOV  R5,R5		CHECK IF ZERO DISPLACEMENT
	JNE  LABELB		BRIF NOT
	ABS  @FMAIN		MAIN PROGRAM?
	JEQ  LABELC		BRIF NO
	AI   R5,PROLEN		ADD N BYTES FOR PROLOUGE
	JMP  LABELB
LABELC	EQU  $
	AI   R5,4		4 BYTES FOR SUBROUTINES
LABELB	EQU  $
	MOV  R5,@VDISPL		SAVE DISPLACEMENT
	SETO @VAREA
	B    *R11
*
*  MODADR - MODIFIED ARRAY ADDRESS
*
MODADR	EQU  $
	MOV  @VPTR,R5		GET CODE WORD
	ANDI R5,MADRFL		TABLE INDEX
	SLA  R5,2
	A    @PMODTO,R5
	INCT R5
	MOV  @2(R5),R1		DELTA OFFSET INTO ARRAY
	MOV  R1,@VDELTA
	MOV  *R5,R5		GET TABLE # AND REENTER
	B    @EVALMO		EVALUATE ROUTINE
*
*  Generate object code routines
*
*  The following routines generate various types of object records:
*
*    GACHAI  -  ADDRESS CHAIN RESOLUTION
*    GABSLT  -  ABSOLUTE LOAD ITEM
*    GRELAT  -  RELATIVE LOAD ITEM
*    GLDITE  -  2-WORD LOAD ITEM
*    GBCDIT  -  ASCII LOAD ITEM
*    GDEBUG  -  GENERATE DEBUG ITEM
*    G1WDIT  -  SINGLE-WORD LOAD ITEM
*    GENWRD  -  GENERATE MULTIPLE ABS WORDS
*
GACHAI	EQU  $			GEN ADRL-CHAIN RESOLUTION
	MOV  R11,@SAVER5  	SAVE RETURN
	MOV  R5,@PCHAIN
	MOV  @VLOCN,@PRESOL
	MOV  @KACHAI,R2   	GET HEADER
	LI   R5,6	  	ENSURE 6 BYTES REMAIN IN OBJECT
	A    @VRMNOB,R5   	 BUFFER
	JLT  GCHAI1
	BL   @NEWOBJ      	ELSE, FLUSH BUFFER
	AI   R5,6
*
GCHAI1	EQU  $
	MOV  R5,@VRMNOB   	DECR BYTES REMAINING COUNT
	MOV  R2,@VCURIT   	SET CURRENT ITEM CELL
	MOV  @PNXTIT,R6
	MOV  R2,*R6+      	INSERT HEADER WORD
	MOV  @PRESOL,*R6+ 	INSERT RESOLUTION ADDRESS
	MOV  @PCHAIN,*R6+ 	INSERT CHAIN ADDRESS
	MOV  R6,@PNXTIT
	MOV  @SAVER5,R11
	B    *R11
*
*  GABSLT - Generate absolute load item in R2
*
GABSLT	EQU  $			GENERATE ABSOLUTE LOAD ITEM
	MOV  @KABSLT,R5
*
*
*  GRELAT - Generate relative load item
*
GRELAT	EQU  $			GENERATE RELATIVE LOAD ITEM
	INCT @VLOCN
*
GLDITE	EQU  $			GENERATE 4 BYTE LOAD ITEM
	MOV  R11,@SAVER5
	C    @VCURIT,R5
	JNE  GLDIT1
	MOV  @VRMNOB,R5		IF NEW ITEM & CURRENT ITEM
	INCT R5			TYPES MATCH, ADD NEW ITEM
	MOV  R5,@VRMNOB 	ONTO CURRENT ITEM (IF 2 BYTES
	JLT  GLDIT4		OF BUFFER SPACE REMAINS)
	JMP  GLDIT2
*
GLDIT1	EQU  $			IF TYPES DO NOT MATCH, GENERATE
	MOV  R5,@VCURIT 	NEW ITEM (IF 4 BYTES OF BUFFER
	LI   R5,4		SPACE REMAIN)
	A    @VRMNOB,R5
	JLT  GLDIT3
*
GLDIT2	EQU  $
	BL   @NEWOBJ		END OF BUFFER, WRITE CURRENT
	AI   R5,4		RECORD & INITIALIZE NEW ONE
*
GLDIT3	EQU  $			GENERATE NEW ITEM
	MOV  R5,@VRMNOB
	MOV  @PNXTIT,R6
	MOV  @VCURIT,*R6+ 	UPDATE BYTES REMAINING COUNT
	MOV  @PNXTIT,@PCURHD
	INCT @PNXTIT		SET CURRENT ITEM TYPE CELL AND
*				CURRENT ITEM HEADER POINTER
*
GLDIT4	EQU  $
	MOV  @PNXTIT,R6		STORE NEW WORD
	MOV  R2,*R6
	MOV  @PCURHD,R6		UPDATE ITEM BYTE COUNT IN HEADER
	INCT *R6
	INCT @PNXTIT
*
	MOV  @FOBJLS,R5		PRINT GENERATED ITEM
	JEQ  GLDIT5
	MOV  @VCURIT,R5		SKIP UNLESS 'OB' OPTION WAS
	JLT  GLDIT5	 	SELECTED
	CI   R5,>4000
	JLT  GLDI5A
*
GLDIT5	MOV  @SAVER5,R11  	SKIP IF NON-CODE ITEM
	B    *R11
*
GLDI5A	EQU  $
	BL   @BLALIN     	BLANK THE OUTPUT LINE
	MOV  @VCURIT,R5  	GET ITEM
	SRA  R5,8
	CI   R5,>20		DETERMINE ITEM TYPE & TYPE LETTER
	JLT  GENA
	JNE  GENCOA
	MOV  @ERE,R5     	  RE - RELATIVE
	JMP  GLDIT6
GENA 	EQU  $
	MOV  @EAB,R5    	  AB - ABSOLUTE
	JMP  GLDIT6
GENCOA	EQU  $
	ANDI R5,>F		MASK AREA NUMBER
	JEQ  GENCBM		BLANK COMMON
	MOV  @EDA,R5    	  DA - DATA RELATIVE
	JMP  GLDIT6
GENCBM	EQU  $
	MOV  @ECO,R5
*
GLDIT6	EQU  $
	MOV  R5,@PRINTB
	MOV  @FLO,R5
	JEQ  GLDIT5
	MOV  R2,R7		SAVE VALUE AT LOCATION
	LI   R2,TFORMA
	MOV  @BLANK,*R2+
	MOV  @VOBJLO,R5
	C    @VCURIT,@KBBSLT	GENERATE BYTE ITEM?
	JNE  GLDIT7
	INC  @VOBJLO		YES, INCR ONE BYTE ONLY
	JMP  GLDIT8
GLDIT7	EQU  $
	INCT @VOBJLO		ELSE, INCR A FULL WORD
GLDIT8	EQU  $
	BL   @HEXCVT    	PRINT LINE ON 'LO' & RETURN
	MOVB @BLANK,*R2+
	MOV  R7,R5		OUTPUT LOCATION
	BL   @HEXCVT
	ABS  @FLSTFL    	LISTING OFF?
	JNE  GLDIT5		BRIF YES
	BL   @CHECKP    	CHECK FOR PAGE BREAK
	BL   @PRINT
	DATA 3
	DATA TFORMA
	JMP  GLDIT5
*
*  GDEBUG - GENERATE DEBUG PACKET (IF FLAG SET)
*
GDEBUG	EQU  $
	MOV  @FDEBUG,R5 	GET DEBUG ON/OFF FLAG
	JEQ  GBCDI3		BRIF DEBUG OFF
	MOV  @VHEADE,R5 	GET LENGTH PACKET
	ANDI R5,>FF
	INCT R5
	JMP  GBCDI0
*
GBCDIT	EQU  $			GENERATE ASCII LOAD ITEM
	LI   R5,14
GBCDI0	EQU  $
	MOV  R11,@SAVER5 	SAVE RETURN VECTOR
	MOV  R5,@SAVELN  	SAVE LENGTH
	A    @VRMNOB,R5  	14-BYTE ITEM STORED IN VBCDIT
	JLT  GBCDI1
	BL   @NEWOBJ     	ENSURE 14 BYTES AVAILABLE IN
	A    @SAVELN,R5
GBCDI1	EQU  $
	MOV  R5,@VRMNOB
	MOV  @SAVELN,R2
	MOV  @PNXTIT,R1
	LI   R12,VHEADE
GBCDI2	EQU  $
	MOV  *R12+,*R1+
	DECT R2
	JNE  GBCDI2
	MOV  R1,@PNXTIT
*
	CLR  @VCURIT     	SET VCURIT=0 (NON-CONTINUABLE)
	MOV  @SAVER5,R11
GBCDI3	EQU  $
	B    *R11
*
G1WDIT	EQU  $			GENERATE 2 BYTE ITEM
	MOV  R11,@SAVER5
	MOV  R5,@VCURIT
	LI   R5,2
	A    @VRMNOB,R5
	JLT  G1WDI1
	BL   @NEWOBJ
	INCT R5
G1WDI1	MOV  R5,@VRMNOB		INSERT ITEM IN BUFFER
	MOV  @PNXTIT,R6
	MOV  @VCURIT,*R6
	INCT @PNXTIT		UPDATE ITEM POINTER & COUNT
	MOV  @SAVER5,R11
	B    *R11		RETURN
*
*  GENWRD - Generate multiple object words
*
*	    On entry:      R8 contains # words to generate
*			   R3 points to the argument list
*
GENWRD	EQU  $			MOVE MULTIPLE BYTES
	MOV  R11,@SAVER2 	save return vector
	MOV  R8,R8		Any words to generate?
	JEQ  GENWR2		Brif no, exit
GENWR1	EQU  $
	MOV  *R3+,R2		get word to generate
	BL   @GABSLT		generate absolute word
	DEC  R8
	JNE  GENWR1		brif more to go
GENWR2	EQU  $
	MOV  @SAVER2,R11 	restore return vector
	B    *R11
	TITL 'LOGIC SEGMENT TERMINATION'
	PAGE
*
*  This module is called upon termination of code generation (end logic),
*  and does the following:
*
*     1. Allocates single precision constants
*     2. Allocates double precision constants
*     3. Resolves all statement labels
*     4. Prints statement label map
*     5. Prints allocation map
*     6. Prints subprograms used map
*     7. Prints error summary
*
IENDLG	EQU  $
	MOV  @PLBLTO,R5		End of logic segment
	S    @PLBLBT,R5
*
IENDL1	EQU  $
	JEQ  IENDL5		RESOLVE ALL EXTERNAL LABELS
	MOV  R5,@VCOUN1  	 TO END OF LOGIC
	A    @PLBLBT,R5
	MOV  R5,R2		LABELS MAY BE UNRESOLVED EITHIER
	MOV  @6(R2),R5  	BECAUSE THEY WERE UNDEFINED OR
	JLT  IENDL2		OR BECAUSE THEY WERE MISUSED
	JMP  IENDL3
*
IENDL2	EQU  $
	INC  @VCERRL		FOR EACH UNRESOLVED LABEL:
	MOV  @VLOCN,@6(R2)
	MOV  @8(R2),R5		DEFINE LABEL AT CURRENT LOGIC
	JEQ  IENDL3		 LOCATION
	BL   @GACHAI
	MOV  @VCOUN1,R2  	GENERATE ADRL CHAIN RESOLUTION
	A    @PLBLBT,R2  	IF AN ADRL-CHAIN EXISTS
*
IENDL3	EQU  $
	MOV  @VCOUN1,R5  	REPEAT FOR EACH LABEL
	AI   R5,8
	JMP  IENDL1
*
IENDL5	EQU  $
	MOV  @VCERRL,R5  	IF ANY UNRESOLVED LABELS WERE
	JEQ  IENL5A	 	ENCOUNTERED, GENERATE ERROR-
	LI   R3,SUB06    	 EXIT CODE
	MOV  *R3+,R8
	BL   @GENWRD
*
*  GENERATE CHAIN RESOLUTIONS FOR ANY INTEGER *4 CONSTANTS
*
IENL5A	EQU  $
	MOV  @PI4CNT,R5	
	MOV  R5,@VTEMP
*
IENL5B	EQU  $
	S    @PI4CNB,R5
	JEQ  IENDL6		BRIF DONE GENERATING ALL I*4
	MOV  @VTEMP,R8
	MOV  @6(R8),R5		WAS CONSTANT REFERENCED IN CODE?
	JEQ  IENL5C		BRIF NO
	BL   @GACHAI		ELSE, OUTPUT I*4 CONSTANT REFERENCE
	INCT R8			 CHAIN RESOLUTION
	MOV  *R8+,R2		GENERATE 4 BYTE CONSTANT
	BL   @GABSLT
	MOV  *R8+,R2
	BL   @GABSLT
*
IENL5C	EQU  $
	A    @K6,@VTEMP
	MOV  @VTEMP,R5
	JMP  IENL5B
*
*  GENERATE CHAIN RESOLUTIONS FOR SINGLE PRECISION CONSTANTS
*	
IENDL6	EQU  $
	MOV  @PSPCNT,R5
	MOV  R5,@VTEMP
*
IENDL7	EQU  $
	S    @PSPCNB,R5 	GENERATE SINGLE PRECISION CONSTANT
	JEQ  IENDL9		CONSTANTS AT END OF LOGIC
	MOV  @VTEMP,R8
	MOV  @6(R8),R5
	JEQ  IENDL8		OUTPUT ADRL CHAIN RESOLUTION
	BL   @GACHAI		FOR CONSTANT REFS
	INCT R8
	MOV  *R8+,R2		GENERATE 4 BYTE CONSTANT
	BL   @GABSLT
	MOV  *R8+,R2
	BL   @GABSLT
*
IENDL8	EQU  $
	A    @K6,@VTEMP
	MOV  @VTEMP,R5
	JMP  IENDL7
*
*  GENERATE CHAIN RESOLUTIONS FOR DOUBLE PRECISION CONSTANTS
*
IENDL9	EQU  $
	MOV  @PDPCNT,R5   	GENERATE DOUBLE PRECISION
	S    @PDPCNB,R5    	CONSTANTS AT END OF LOGIC
	JEQ  IENL11
	MOV  @PDPCNT,R8   	OUTPUT ADRL CHAIN RESOLUTION
	MOV  @10(R8),R5   	 FOR CONSTANT REFS
	JEQ  IEND10
	BL   @GACHAI
	INCT R8
	MOV  *R8+,R2    	GENERATE 8 BYTE CONSTANT
	BL   @GABSLT
	MOV  *R8+,R2
	BL   @GABSLT
	MOV  *R8+,R2
	BL   @GABSLT
	MOV  *R8+,R2
	BL   @GABSLT
*
IEND10	EQU  $
	A    @K10,@PDPCNT 	SKIP TO NEXT PACKET
	JMP  IENDL9
*
*  GENERATE CHAIN RESOLUTIONS FOR ANY COMPLEX *8 CONSTANTS
*
IENL11	EQU  $
	MOV  @PC8CNT,R5   	GENERATE COMPLEX *8
	S    @PC8CNB,R5    	CONSTANTS AT END OF LOGIC
	JEQ  IENL13
	MOV  @PC8CNT,R8   	OUTPUT ADRL CHAIN RESOLUTION
	MOV  @10(R8),R5   	 FOR CONSTANT REFS
	JEQ  IENL12
	BL   @GACHAI
	INCT R8
	MOV  *R8+,R2    	GENERATE 8 BYTE CONSTANT
	BL   @GABSLT
	MOV  *R8+,R2
	BL   @GABSLT
	MOV  *R8+,R2
	BL   @GABSLT
	MOV  *R8+,R2
	BL   @GABSLT
*
IENL12	EQU  $
	A    @K10,@PC8CNT 	SKIP TO NEXT PACKET
	JMP  IENL11
*
*  GENERATE CHAIN RESOLUTIONS FOR ANY COMPLEX *16 CONSTANTS
*
IENL13	EQU  $
	MOV  @PC6CNT,R5   	GENERATE COMPLEX *16
	S    @PC6CNB,R5    	 CONSTANTS AT END OF LOGIC
	JEQ  MAPLBL
	MOV  @PC6CNT,R8   	OUTPUT ADRL CHAIN RESOLUTION
	MOV  @18(R8),R5   	 FOR CONSTANT REFS
	JEQ  IENL14
	BL   @GACHAI
	INCT R8
	MOV  *R8+,R2    	GENERATE 16 BYTE CONSTANT
	BL   @GABSLT
	MOV  *R8+,R2
	BL   @GABSLT
	MOV  *R8+,R2
	BL   @GABSLT
	MOV  *R8+,R2
	BL   @GABSLT
	MOV  *R8+,R2
	BL   @GABSLT
	MOV  *R8+,R2
	BL   @GABSLT
	MOV  *R8+,R2
	BL   @GABSLT
	MOV  *R8+,R2
	BL   @GABSLT
*
IENL14	EQU  $
	A    @K18,@PC6CNT 	SKIP TO NEXT PACKET
	JMP  IENL13
*
*  START OF MAP GENERATION
*
MAPLBL	EQU  $
	MOV  @NUMLIN,@VCLINE
	BL   @BLALIN
	MOV  @FEND,R5     	IF END STATEMENT WAS MISSING
	JNE  MAPLB0	 	OUTPUT <EOD> WARNING AS LAST
	LI   R5,XEOD
	BL   @WARNOU     	 PRINT SPECIFIED WARNING
*
MAPLB0	EQU  $
	LI   R5,WALLOC    	PUT 'Allocation' INTO PAGE HEADER
	BL   @MOVETX
	DATA TALLOC
*
	MOV  @PLBLTO,R5
	S    @PLBLBT,R5
	JEQ  IEND11		PRINT LABELS SUMMARY
	SRA  R5,3
	MOV  R5,@VCOUN1
	BL   @MAPHDR
	DATA WLABEL
*
MAPLB1	EQU  $	     		LABELS ARE PRINTED IN ASCENDING
	MOV  @PLBLTO,R2    	 ORDER WITH THIER ASSOCIATED
	MOV  @2(R2),R4      	 LOCATION AND A POSSIBLE ERROR
	ANDI R4,1	   	 FLAG
	MOV  @4(R2),R5
*
MAPLB2	EQU  $
	LI   R6,VNAME1
	MOV  R4,*R6+      	THE LABEL TABLE IS SEARCHED N
	MOV  R5,*R6	   	 TIMES FOR THE LOWEST LABEL #
	MOV  R2,R5	   	 WHERE N IS THE NUMBER OF LABELS
	MOV  R5,RTO
*
MAPLB3	EQU  $	     		AFTER EACH PASS THRU THE TABLE
	AI   R5,8	    	 THE LOWEST LABEL IS PRINTED
	MOV  R5,R2	  	 THEN SET TO THE MAX VALUE
	S    @PLBLBT,R5   	 IT WILL BE BYPASSED FOR THE
	JEQ  MAPLB4	 	 REST OF THE SEARCHES
	MOV  @2(R2),R4
	ANDI R4,1
	MOV  @4(R2),R5
	LI   R6,VNAME1
	C    R4,*R6+
	JLT  MAPLB2
	JGT  MAPL3A
	C    R5,*R6
	JLT  MAPLB2
MAPL3A	MOV  R2,R5
	JMP  MAPLB3
*
MAPLB4	EQU  $
	MOV  R2,@SAVELB   	SAVE POINTER TO LABEL PACKET
	LI   R5,VHEADE
	MOV  @KDBGLB,*R5+ 	MOVE DEBUG HEADER
	MOV  @6(RTO),R1   	MOVE LOCATION OF LABEL
	BL   @ADJUST
	MOV  R1,*R5+
	BL   @GDEBUG      	GENERATE DEBUG PACKET
	MOV  @SAVELB,R2   	RESTORE POINTER TO LABEL
	LI   R6,VNAME1
	MOV  *R6+,R4      	FOUND LOWEST REMAINING LABEL SO
	ANDI R4,1
	MOV  *R6,R5		CONVERT IT TO ASCII AND INSERT
	BL   @CVTLBL		IT IN MAP PACKET
	DATA VMAPW1
	MOV  @EBLANK,R5
	LI   R6,VNAME3    	BLANK OUT UNUSED WORDS OF
	MOV  R5,*R6+		ITEM PACKET
	MOV  R5,*R6+
	MOV  R5,*R6+
	MOV  @2(RTO),R5   	IF THE LABEL IS IN ERROR, THE APPROPRIATE
	ANDI R5,MOPCFL      	FLAG IS ATTACHED TO THE LABELS LOCATION
	JEQ  MAPLB6		BRIF UNDEFINED
	C    @KDFDLB,R5
	JNE  MAPLB5
	MOV  @2(RTO),R5   	E -- ERROR
	ANDI R5,MTAGFL
	JNE  MAPLB8
*
MAPLB5	EQU  $
	INC  @VCERRL      	INCREMENT LABEL ERROR IF DOUBLY DEFINED
*
MAPLB6	EQU  $
	MOV  @EE,R5		INCREMENT LABEL ERROR COUNT IF
*
MAPLB7	EQU  $
	MOV  R5,@VNAME3
*
MAPLB8	EQU  $
	SETO R5	    		FORCE FOUND LABEL TO MAX VALUE
	MOV  RTO,R2
	INCT R2
	MOV  R5,*R2+      	FOR SUBSEQUENT SEARCHES
	MOV  R5,*R2+
	MOV  *R2,R5
	LI   R2,VNAME1    	CONVERT LABEL'S LOCATION TO
	BL   @HEXCVT		ASCII AND INSERT IT IN THE
	BL   @MAPITE		MAP PACKET
*
	INC  @VCOUN1      	TRANSFER MAP PACKET TO PRINT
	JNE  MAPLB1	 	BUFFER & PRINT LINE WHEN HAVE
*			    	4 PACKETS.
IEND11	EQU  $
	MOV  @PGSPRT,R5   	OUTPUT SUBPROGRAM REF ITEMS AND
	S    @PGSPRB,R5    	PRINT SUBPROGRAMS SUMMARY
	JEQ  ISPC01
	MOV  R5,@VCOUN1
	BL   @MAPHDR
	DATA WSUBPR
*
IEND14	EQU  $
	INCT @VCOUN1
	MOV  @VCOUN1,R7
	A    @PGSPRB,R7
	BL   @M39CVR      	CONVERT SUBPROGRAM NAME TO ASCII
	MOV  @VCOUN1,R5
	AI   R5,6
	MOV  R5,@VCOUN1
	MOV  @PGSPRB,R2
	A    R5,R2
	INCT R2
	MOV  *R2,@VVALUE
	JEQ  IEND15
	MOV  @KSPRGR,@VHEADE
	BL   @GBCDIT
IEND15	EQU  $
	MOV  @EBLANK,R5
IEN15A	EQU  $
	MOV  R5,@VVALUE
*
IEND16	EQU  $
	MOV  R5,@VHEADE
	MOV  R5,@VMAPW1
	MOV  R5,@VMAPW2
	BL   @MAPITE
	INCT @VCOUN1
	JNE  IEND14
	JMP  IEND17
*
*  CHECK IF ANY SPECIAL ITEMS TO BE PROCESSED.  IF SO, THEN OUTPUT
*  THE SUBPROGRAM HEADER CAUSE NOT DONE ABOVE.
*
ISPC01	EQU  $
	LI   R5,PSPSTA		GET SPECIAL ITEMS START
ISPC02	EQU  $
	MOV  *R5+,R6		ANYTHING IN THIS ITEM?
	JNE  ISPC03		BRIF YES, DISPLAY HEADER
	CI   R5,PSPEND		AT END?
	JH   IEND17		YES, AND NOTHING TO DO YET
	JMP  ISPC02		ELSE, TRY NEXT FLAG
ISPC03	EQU  $
	BL   @MAPHDR
	DATA WSUBPR
*
*  PROCESS THE SPECIAL REFERENCE ITEMS (E.G. FLOATING POINT REFERENCES)
*
IEND17	EQU  $
	CLR  @VCOUN1		CLEAR COUNT POINTER
*
ISPC04	EQU  $
	MOV  @VCOUN1,R5		GET POINTER TO COUNT
	MOV  @PSPSTA(R5),R4	GET FLAG INDICATING SPECIAL REQUIREMENT
	JEQ  ISPC05		BRIF NOTHING HERE, TRY NEXT
	A    @VCOUN1,R5		GET POINTER TO SYMBOL STRING
	A    @VCOUN1,R5
	AI   R5,FPCONS		 + BASE OF REFERENCE NAMES
	LI   R6,VNAME1		MOVE TO VNAME1
	MOV  *R5+,*R6+		 6 BYTES
	MOV  *R5+,*R6+
	MOV  *R5+,*R6+
	MOV  @EBLANK,*R6+	 AND FOUR BLANKS
	MOV  @EBLANK,*R6+
	MOV  R4,@VVALUE		LAST RELATIVE VALUE
	MOV  @KSPRGR,@VHEADE
	BL   @GBCDIT
	MOV  @EBLANK,R5
	MOV  R5,@VVALUE
	MOV  R5,@VHEADE
	MOV  R5,@VMAPW1
	MOV  R5,@VMAPW2
	BL   @MAPITE
ISPC05	EQU  $
	INCT @VCOUN1
	MOV  @VCOUN1,R5
	AI   R5,PSPSTA
	CI   R5,PSPEND
	JLE  ISPC04
*			   	PRINT VARIABLE SUMMARIES BY AREA
*			    	UNLESS MAP OPLBL ASSIGNED TO 0
	SETO @VAREA
	SETO @FLOCAL      	SET FLAG SO PRINT FIRST AREA'S
*			    	HEADER
	MOV  @PX2SV,@PX2
	MOV  @PNWDSV,@PNEXTW
	LI   R4,X2READ    	PROCESS COMMON VARIABLES THEN DO IT
	BLWP @FIOC	  	AGAIN FOR LOCAL VARIABLES
	JEQ  VARMAP
	B    @IOABOR
*
VARMAP	EQU  $	     		SCRATCH FILE 2 INFORMATION PACKETS
	BL   @GETWO2		ARE READ INTO A 6 WORD LIST
	JEQ  VARMA5	 	LOCATED AT MAPX2L
	LI   R6,MAPX2L
	MOV  R5,*R6
	LI   R5,-5	 	IF THE VARIABLE IS A GLOBAL
	MOV  R5,@VCOUN1   	 DUMMY, THEN IGNORE IT.
	MOV  R6,RTO
	BL   @READWD      	PROCESSING ENDS WHEN A ZERO WORD
*			   	 IS READ
	LI   R7,MAPX2L
	MOV  @8(R7),R5
	MOV  R5,R0	 	THE AREA CODE IN THE VARIABLE PACKET
	ANDI R5,MOPCFL    	 DETERMINES WHEN A NEW SECTION WILL BE
	JNE  VARMAP	 	 PRINTED:
	MOV  R0,R5	    	     0 -- 'COMMON'
	ANDI R5,>F	    	     1 -- 'LOCAL'
	C    @VAREA,R5    	  2-15 -- FUTURE LABELLED COMMONS NAME
	JEQ  VARMA2
	MOV  R5,@VAREA
	JEQ  VARMA3
	BL   @MAPHDR
	DATA WLOCAL
	JMP  VARMA2
VARMA3	EQU  $
	BL   @MAPHDR
	DATA WCOMMO
*
VARMA2	EQU  $
	LI   R2,VMAPW1    	CONVERT THE VARIABLES LOCATION
	LI   R7,MAPX2L    	 TO ASCII AND STORE IN MAP
	MOV  @10(R7),R5   	 PACKET
	MOVB @BLANK,*R2+
	BL   @HEXCVT
	MOVB @BLANK,*R2+
	MOV  @6(R7),R5    	GET TYPE OF ELEMENT
	ANDI R5,MTAGFL
	SRC  R5,7		*
	MOVB @ELETYP(R5),*R2+
	MOVB @BLANK,*R2+
	BL   @M39CVR
	BL   @MAPITE
	LI   R5,VHEADE    	BUILD DEBUG PACKET
	LI   R7,MAPX2L    	MAP PACKET
	MOV  @KDBGVA,*R5+ 	HEADER WORD
	MOV  @10(R7),*R5+   	GET LOCATION
	MOV  @9(R7),R1    	GET AREA
	ANDI R1,>000F
	JGT  NOTCOM		BRIF NOT COMMON
	MOV  @FMAIN,R0    	IF SO, MUST BE MAIN
	JEQ  VARMAP		BRIF NOT
NOTCOM	EQU  $
	SWPB R1
	MOV  @6(R7),R4    	GET TYPE CODE
	ANDI R4,MTAGFL
	SRC  R4,7
	SOC  R4,R1
	LI   R4,VBCDIT
	MOV  R4,R3
	DECT R3
	LI   R2,-5
PUSHLO	EQU  $
	MOV  *R3,*R4
	DECT R3
	DECT R4
	INC  R2
	JNE  PUSHLO
	MOV  R1,*R5+
	LI   R3,VBCDIT
TRIMBL	EQU  $
	CB   *R3,@BLANK
	JNE  TRIMEX
	DECT @VHEADE
	DECT R3
	JNE  TRIMBL
TRIMEX	EQU  $
	BL   @GDEBUG      	GENERATE DEBUG PACKET
	JMP  VARMAP
*
VARMA5	EQU  $
	BL   @GETWO2      	PRINT VARIABLE ALLOCATION ERRORS IN
	JEQ  VARMA7	 	 TWO GROUPS: COMMON AND LOCAL
	NEG  R5	    		 ZERO WORD MEANS THERE ARE NO
	MOV  R5,@VCENTR    	 ERRORS FOR VARIABLE GROUP BEING
	MOV  @FLOCAL,R5    	 PROCESSED
	JLT  VARM5A
	BL   @MAPHDR     	 LOCAL ERRORS
	DATA WLOCAE
	JMP  VARMA6
VARM5A	EQU  $
	BL   @MAPHDR      	COMMON ERRORS
	DATA WCOMME
*
VARMA6	EQU  $
	LI   R5,-4	 	THE ERROR PACKETS ARE FOUR WORDS
	MOV  R5,@VCOUN1   	 IN LENGTH
	LI   RTO,MAPX2L
	DECT RTO	    	WORDS 1-3 -- VAR NAME IN M39
	BL   @READWD		WORD  4   -- ERROR NUMBER
	LI   R7,MAPX2L
	BL   @M39CVR      	THE NAME OF THE VARIABLE IN ERROR
	LI   R2,VMAPW1
	LI   R5,-8
VARBLD	EQU  $
	MOVB @BLANK,*R2+
	INC  R5
	JNE  VARBLD
*
	BL   @MAPITE      	THE RESULTING MAP PACKET IS IN-
	INC  @VCENTR		SERTED IN THE PRINT BUFFER AND
	JNE  VARMA6	 	A LINE IS OUTPUT WHEN HAVE FOUR
*			    	PACKETS
*
VARMA7	EQU  $	     		FLOCAL=-1 IF HAVE JUST PROCESSED
	INC  @FLOCAL		COMMON VARIABLES AND MUST STILL
	JNE  MAPSTA	 	PROCESS LOCALS
	B    @VARMAP
*
MAPSTA	EQU  $	     		PRINT DATA AREA ALLOCATION LAYOUT
	MOV  @VCMITM,R5   	ANY LINES OUTSTANDING?
	JLT  MAPST1		BRIF NO
	BL   @MAPLIN      	ELSE, FLUSH BUFFER
MAPST1	EQU  $
	MOV  @VLOCN,R5    	LOGIC SIZE
	BL   @STAMAP
	DATA WLOGIS
	MOV  @VDATSI,R5   	DATA SIZE
	BL   @STAMAP
	DATA WDATAS
	MOV  @VLOCN,R5    	ADD LOGIC + DATA
	A    @VDATSI,R5
	BL   @STAMAP
	DATA WTOTAS		FOR TOTAL SIZE
	MOV  @VCMNSI,R5   	GET COMMON SIZE
	JEQ  IEND18		BRIF NO COMMON
	BL   @STAMAP
	DATA WCOMSI		COMMON SIZE
*
IEND18	EQU  $	     		OUTPUT DEF FOR LOGIC SEGMENT
	MOV  @KDEF,@VHEADE
	CLR  @VVALUE
	LI   R2,-10
	LI   R4,TPROGN    	PROGRAM NAME START
	LI   R5,VNAME1    	BCD ITEM NAME START
	C    R4,@EBLANK   	IS PROGRAM NAME BLANK?
	JNE  IEN18B		BRIF NO
	LI   R4,TMLOGI    	DEFAULT NAME FOR LOGIC AREA
IEN18B	EQU  $
	MOVB *R4+,*R5+    	MOVE A BYTE
	INC  R2
	JNE  IEN18B		DO UNTIL 10 BYTES MOVED
*
IEN18C	EQU  $
	BL   @GBCDIT      	GENERATE END MODULE LOAD ITEM
	MOV  @KENDMO,R5
	MOV  R5,@VHEADE
	MOV  @FIO,R5
	JEQ  NOTSIG		HEADER
	LI   R5,>8000     	EXECUTION TIME KEY
	MOV  R5,@VVALUE   	ERROR SEVERITY
NOTSIG	MOV  @VCERRS,R5   	TOTAL LOGIC LENGTH
	A    @VCERRL,R5
	A    @VCALER,R5
	LI   R6,VNAME1
	MOV  R5,*R6+
	MOV  @VLOCN,*R6+
	CLR  *R6+
	CLR  *R6+
	CLR  *R6
	BL   @CVTNUM
	DATA WERRCN+1
	BL   @GBCDIT
	MOV  @KLSTRE,@VRECTY
	BL   @NEWOBJ      	OUTPUT LAST OBJECT RECORD
	MOV  @VCWARN,R5   	GET # OF WARNINGS
	BL   @CVTNUM      	CONVERT TO DECIMAL
	DATA WWARNC+1     	INTO BUFFER
	BL   @BLALIN      	MOVE LINE TO OUTPUT BUFFER
	BL   @PRINER
	DATA WWARNC		PRINT WARNINGS LINE
	BL   @PRINER
	DATA WERRCN		PRINT ERRORS LINE
	B    @P1RETN      	RETURN TO FORTRAN1
*
PRINER	EQU  $
	MOV  *R11+,R5
	MOV  R11,R7
	BL   @BLALIN      	Blank the line
	BL   @MOVETX
	DATA TFORMA
	BL   @PRINT		PUT ON PRINTER
	DATA 6
	DATA TFORMA
	BL   @PRINT		AND CRT
	DATA 3
	DATA TFORMA
	B    *R7
*
*  MAPHDR - PRINT A MAP SECTION HEADING
*
MAPHDR	EQU  $
	MOV  R11,@VMPXI1  	SAVE RETURN
	MOV  @VCMITM,R5   	PRINT LAST LINE OF PREVIOUS SECTION
	JLT  MAPHD2	 	IF IT WAS NOT FILLED
	BL   @MAPLIN
*
MAPHD2	EQU  $	     		PAGE EJECT & PRINT PAGE HEADER
	MOV  @VCLINE,R5   	BEFORE PRINT SECTION HEADER IF
	AI   R5,3	  	THERE ISN'T ENUF ROOM TO
	C    @NUMLIN,R5   	PRINT AT LEAST 1 LINE OF
	JGT  MAPHD3	 	THIS SECTION
	BL   @NEWPAG
*
MAPHD3	EQU  $
	INCT @VCLINE      	LINE COUNT GETS INCREMENTED BY 2
	MOV  @VMPXI1,R11  	GET OLD R11
	MOV  *R11+,R5     	GET MESSAGE #
	MOV  R11,@VMPXI1
	BL   @MOVETX      	MOVE HEADER
	DATA TFORMA		TO FORMAT
	BL   @PRINT		& PRINT SECTION HEADER
	DATA 3
	DATA TFORMA
	BL   @BLALIN      	BLANK LINE AFTER PRINT
	BL   @PRINT		PRINT THE BLANK LINE
	DATA 3
	DATA TFORMA
	MOV  @VMPXI1,R11
	B    *R11
*
MAPITE	EQU  $	     		INSERT MAP PACKET INTO PRINT BUFFER
	MOV  R11,@VMPXI1   	AND PRINT MAP SECTION LINE WHEN
*			    	HAVE FULL BUFFER (I.E. 4 ITEMS)
	MOV  @VCMITM,R5
	CI   R5,4	  	ENTRY:  R11 -- RETURN ADDRESS
	JLT  MAPIT2
	BL   @MAPLIN      	OUTPUT BUFFER IF ITS ALREADY FULL
*
MAPIT2	EQU  $	     		TRANSFER MAP PACKET INTO PRINT
	MOV  @VCMITM,R4
	INC  @VCMITM		BUFFER AT NEXT AVAILABLE
	MPY  @K18,R4
	AI   R5,TFORMA
	INC  R5
	LI   R4,VMAPW1
	LI   R2,-18
MAPI2A	EQU  $
	MOVB *R4+,*R5+
	INC  R2
	JNE  MAPI2A
*
MAPIT1	EQU  $
	MOV  @VMPXI1,R11
	B    *R11
*
NEWPAG	EQU  $	     		NEW PAGE EJECT
	MOV  R11,@VMPXI2
	JMP  MAPLN2
*
MAPLIN	EQU  $
	MOV  R11,@VMPXI2  	PRINT MAP LINE CONSTRUCTED IN
	C    @TFORMA,@ASC0B  	PRINTB AND PAGE WHEN NEEDED TO
	JNE  MAPL0X
	INC  @VCLINE      	ENTRY   R11  --  RETURN ADDRESS
MAPL0X INC  @VCLINE      	UPDATE COUNT OF LINES, THIS PAGE
	BL   @PRINT		PRINT THE LINE
	DATA 3	     		ON LINE 3
	DATA TFORMA		USING TFORMA BUFFER
*
MAPLN1	EQU  $
	BL   @BLALIN      	BLANK OUT LINE AFTER PRINT
	CLR  @VCMITM      	ZERO COUNT OF ITEMS IN BUFFER IN
	C    @NUMLIN,@VCLINE  	CASE CALLER IS MAPITEM
	JGT  MAPLN3		DON'T HAVE TO PAGE IF STILL ROOM
*			    	FOR ONE MORE LINE
	MOV  @ASC0B,@TFORMA
*
MAPLN2	EQU  $	     		OTHERWISE, INCREMENT PAGE NUMBER
	LI   R5,1	  	AND PAGE EJECT WITH NEW PAGE
	MOV  R5,@VCLINE   	HEADING
	INC  @VPAGE		INCREMENT PAGE NUMBER
	MOV  @VPAGE,R5
	BL   @CVTNUM		PAGE TO 1
	DATA TPAGE
*
	BL   @PRINT		PRINT LINE
	DATA 3
	DATA THEADE		USING HEADER
*
MAPLN3	EQU  $
	MOV  @VMPXI2,R11
	B    *R11	  	RETURN
*
*  WARNOU - PUT SPECIFIED WARNING ON CRT & PRINTER
*
WARNOU	EQU  $
	MOV  R11,@VMPXI1  	SAVE RETURN
	BL   @BLALIN      	BLANK THE PRINT LINE
	BL   @MOVETX      	MOVE TEXT TO PRINT BUFFER
	DATA PRINTB
	BL   @PRINT		PRINT IT
	DATA 3
	DATA TFORMA
	BL   @PRINT
	DATA 6	     		ON PRINTER & CRT
	DATA TFORMA
	MOV  @VMPXI1,R11
	B    *R11	  	RETURN
*
*  BLALIN - BLANK PRINT LINE
*
BLALIN	EQU  $
	MOV  @KPRTLE,R1   	# OF BYTES TO CLEAR
	LI   R0,TFORMA    	OUT OF PRINT BUFFER
BLALOP	EQU  $
	MOVB @BLANK,*R0+
	DEC  R1
	JNE  BLALOP
	B    *R11
*
*  MOVETX - MOVE TEXT MESSAGE TO SPECIFIED ADRL
*
MOVETX	EQU  $
	MOV  *R11+,R1     	GET 'TO' ADRL
MOVELO	EQU  $
	CB   *R5,@KFF00   	IS THIS THE END
	JEQ  MOVEEX		BRIF YES
	MOVB *R5+,*R1+    	ELSE, MOVE IT
	JMP  MOVELO
MOVEEX	EQU  $
	B    *R11
*
*  STAMAP - MAP TOTAL VALUE, GIVEN HEX VALUE IN R5,
*	    AND R11 POINTS TO MESSAGE NUMBER
*
STAMAP	EQU  $
	MOV  R5,R9	 	SAVE HEX VALUE
	MOV  *R11+,R5     	SAVE MESSAGE #
	MOV  R11,@VSAVST
	BL   @BLALIN      	BLANK THE LINE
	BL   @MOVETX      	MOVE TEXT TO OUTPUT BUFFER
	DATA TFORMA
	MOV  R9,R5
	LI   R2,TERRMS
	BL   @HEXCVT      	CONVERT TOTAL VALUE TO HEX
	BL   @PRINT		PRINT IT
	DATA 3	      		TO PRINTER
	DATA TFORMA	 	USING TFORMA BUFFER
	MOV  @VSAVST,R11
	B    *R11	  	RETURN
*
*  PRINT - PRINT THE REQUESTED LINE ON SPECIFIED DEVICE
*
PRINT	EQU  $
	LI   R6,LOWRIT    	COMMAND STACK
	MOV  R6,R4	 	SAVE FOR I/O
	MOV  @KPRINT,*R6+   	ORDER CODE
	MOV  *R11+,*R6+     	FILE NUMBER
	MOV  *R11+,*R6+     	BUFFER ADDRESS
	MOV  @KPRTLE,*R6+   	BYTE COUNT
	MOV  R11,@PIORTN  	RETURN SAVE
	BLWP @FIOC		DO I/O FUNCTION
	JNE  BIOAB6		BRIF ERROR, ABORT
	MOV  @PIORTN,R11  	ELSE, RETURN TO USER
	B    *R11
BIOAB6	B    @IOABOR
*
*  CHECKP - CHECK FOR PAGE OVERFLOW
*
CHECKP	EQU  $
	MOV  R11,@CHECRE  	SAVE RETURN
	C    @VCLINE,@NUMLIN
	JLT  CHEKO2
	MOV  @K1,@VCLINE
	INC  @VPAGE
	MOV  @VPAGE,R5
	BL   @CVTNUM
	DATA TPAGE
	ABS  @FLSTFL
	JNE  CHEKO1
	BL   @PRINT
	DATA 3
	DATA THEADE
CHEKO1	EQU  $
	LI   R5,>3020
	JMP  CHEKO3
CHEKO2	EQU  $
	LI   R5,>2020
CHEKO3	EQU  $
	MOV  @CHECRE,R11
	ABS  @FLSTFL
	JNE  NOINFL
	INC  @VCLINE
NOINFL	EQU  $
	ABS  @FLSTFL
	B    *R11
	TITL 'SUBEXPRESSIONS'
	PAGE
*
*  THIS PORTION OF THE COMPILER CONTAINS THE CODE GENERATOR SUBEXPRESSIONS.
*
*  FLOATING POINT INTERFACE ROUTINES.  REF'S ARE GENNED AT OBJECT
*  CODE GENERATION TIME FOR THE APPROPRIATE ROUTINES.
*
FPCONS	EQU  $
	TEXT 'INITE$'		  INITIAL ENTRY INTO PROGRAM
	TEXT 'AADD$ '		7 SINGLE PRECISION ADD
	TEXT 'ASUB$ '		8		   SUBTRACT
	TEXT 'AMUL$ '		9		   MULTIPLY
	TEXT 'ADIV$ '		A		   DIVIDE
	TEXT 'ACMP$ '		B		   COMPARE
*
	TEXT 'DADD$ '		7 DOUBLE PRECISION ADD
	TEXT 'DSUB$ '		8		   SUBTRACT
	TEXT 'DMUL$ '		9		   MULTIPLY
	TEXT 'DDIV$ '		A		   DIVIDE
	TEXT 'DCMP$ '		B		   COMPARE
*
	TEXT 'CLOA$ '		C COMPLEX *8	   LOAD
	TEXT 'CSTO$ '		D 		   STORE
	TEXT 'CADD$ '		E		   ADD
	TEXT 'CSUB$ '		F		   SUBTRACT
	TEXT 'CMUL$ '		10		   MULTIPLY
	TEXT 'CDIV$ '		11		   DIVIDE
	TEXT 'CCMP$ '		12		   COMPARE
*
	TEXT 'CDLOA$'		13 COMPLEX *16	   LOAD
	TEXT 'CDSTO$'		14 		   STORE
	TEXT 'CDADD$'		15 		   ADD
	TEXT 'CDSUB$'		16 		   SUBTRACT
	TEXT 'CDMUL$'		17		   MULTIPLY
	TEXT 'CDDIV$'		18		   DIVIDE
	TEXT 'CDCMP$'		19		   COMPARE
*
	TEXT 'CNEG$ '		16 NEGATE COMPLEX *8
	TEXT 'CDNEG$'		17 NEGATE COMPLEX *16
*
	TEXT 'J4DIV$'		   INTEGER *4 SIGNED DIVISION
	TEXT 'J4MUL$'		   INTEGER *4 SIGNED MULTIPLY
*
	TEXT 'CGTEX$'		   COMPUTED GOTO EXECUTION
	TEXT 'STOP$ '		   STOP STATEMENT
	TEXT 'NSTOP$'		   NUMBER AND STOP STATEMENT
	TEXT 'PAUSE$'		   PAUSE STATEMENT
	TEXT 'NUMBC$'		   NUMBER CHECK
	TEXT 'SUBCH$'		   SUBTRACT CHECK
	TEXT 'ADDCH$'		   ADD CHECK
	TEXT 'CALL$ '		   CALL SUBROUTINE
	TEXT 'CALLI$'		   CALL INDIRECT SUBROUTINE
	TEXT 'FUNCT$'		   FUNCTION (INLINE) CALL
	TEXT 'FUNCI$'		   INDIRECT FUNCTION (INLINE) CALL
*
*  CONVERSION ROUTINES
*
	TEXT 'IACVT$'		13 CONVERT I*2 TO R*4
	TEXT 'IDCVT$'	   	14 CONVERT I*2 TO R*8
	TEXT 'ICCVT$'		15 CONVERT I*2 TO C*8
	TEXT 'IECVT$'		16 CONVERT I*2 TO C*16
*
	TEXT 'KACVT$'		03 CONVERT I*1 TO R*4
	TEXT 'KDCVT$'		04 CONVERT I*1 TO R*8
	TEXT 'KCCVT$'		05 CONVERT I*1 TO C*8
	TEXT 'KECVT$'		06 CONVERT I*1 TO C*16
*
	TEXT 'JACVT$'		23 CONVERT I*2 TO R*4
	TEXT 'JDCVT$'		24 CONVERT I*2 TO R*8
	TEXT 'JCCVT$'		25 CONVERT I*2 TO C*8
	TEXT 'JECVT$'		26 CONVERT I*2 TO C*16
*
	TEXT 'AICVT$'		30 CONVERT R*4 TO I*1
	TEXT 'AKCVT$'		31 CONVERT R*4 TO I*2
	TEXT 'AJCVT$'		32 CONVERT R*4 TO I*4
	TEXT 'AECVT$'		34 CONVERT R*4 TO C*16
*
	TEXT 'DICVT$'		40 CONVERT R*8 TO I*1
	TEXT 'DKCVT$'		41 CONVERT R*8 TO I*2
	TEXT 'DJCVT$'		42 CONVERT R*8 TO I*4
	TEXT 'DECVT$'		46 CONVERT R*8 TO C*16
*
	TEXT 'CICVT$'		50 CONVERT C*8 TO I*1
	TEXT 'CKCVT$'		51 CONVERT C*8 TO I*2
	TEXT 'CJCVT$'		52 CONVERT C*8 TO I*4
	TEXT 'CECVT$'		56 CONVERT C*8 TO C*16
*
	TEXT 'EICVT$'		60 CONVERT C*16 TO I*1
	TEXT 'EKCVT$'		61 CONVERT C*16 TO I*2
	TEXT 'EJCVT$'		62 CONVERT C*16 TO I*4
	TEXT 'ECCVT$'		65 CONVERT C*16 TO C*8
*
*  OPCODE BRANCH TABLE, ONE PROCESS ROUTINE FOR EACH TYPE OF LOAD
*
OPCJMP	EQU  $
*  GENERIC COMMANDS
	DATA GENBRA		* INDEX INTO GENERAL BRANCH TABLE
	DATA IBRANC		* BRANCH : BRANCH OF SOME KIND
	DATA IINSTR		* INSTRU : SIMPLE INSTRUCTION
	DATA ILOGIC		* LOGICA : LOGICAL CONSTRUCT
*  RUNTIME CALLS TO EXCTIME
	DATA IRUNIN		* RUNTIN : RUNTIME REFERENCE
	DATA IRUNIC		* RUNTIC : EXECUTION TIME W/ARG & COUNT
*  RUNTIME CALLS TO SPECIAL SUBROUTINE REFERENCES
	DATA IGENRN		* GENRFN : GENERATE SPECIAL REFERENCE
	DATA IGENRT		* GENRFT : GEN SPEC REF W/ARGUMENT
	DATA IGENRC		* GENRFC : GEN SPEC REF W/ARGUMENT & COUNT
*  MISC FUNCTIONS AND CONVERSIONS
	DATA IFUNCE		* FUNCCE : FUNCTION CALL END
	DATA IGENCV		* GENCVT : GENERATE CONVERSION
	DATA IPERIO		* PERIOF : SCALAR, ARRAY, OR ADJUSTABLE I/O
GENEQU	EQU  $-OPCJMP		 (NEEDED FOR COMPOF ROUTINE)
	DATA IGENAD		* GENADL : GENERATE ABSOLUTE WORD & ADDRESS
*  ABSOLUTE DATA GENERATION + # OF WORDS TO GEN
	DATA IABSL1		* ABSLO1 : GEN 1 ABSOLUTE WORD
	DATA IABSL2		* ABSLO2 : GEN 2 ABSOLUTE WORDS
	DATA IABSL3		* ABSLO3 : GEN 3 ABSOLUTE WORDS
	DATA IABSL4		* ABSLO4 : GEN 4 ABSOLUTE WORDS
	DATA IABSL5		* ABSLO5 : GEN 5 ABSOLUTE WORDS
	DATA IABSL6		* ABSLO6 : GEN 6 ABSOLUTE WORDS
	DATA IABSL8		* ABSLO8 : GEN 8 ABSOLUTE WORDS
	DATA IABSL9		* ABSLO9 : GEN 9 ABSOLUTE WORDS
	DATA IABS11		* ABSL11 : GEN 11 ABSOLUTE WORDS
	DATA IABS12		* ABSL12 : GEN 12 ABSOLUTE WORDS
	DATA IABS14		* ABSL14 : GEN 14 ABSOLUTE WORDS
	DATA IABS15		* ABSL15 : GEN 15 ABSOLUTE WORDS
GENEQ2	EQU  $-OPCJMP
	DATA IGENA2		* GENAD2 : GENERATE 2 WORD INSTRUCTION
*
GENJMP	EQU  $
FUTURE	EQU  $
	DATA IFUTUR		FUTURE OPCODE (INTERNAL ERROR)
LABEL	EQU  $
	DATA ILABEL		* STATEMENT OR MADE LABEL
BOS	EQU  $
	DATA IBOS		* BEGINNING OF STATEMENT
FORMAT	EQU  $
	DATA IFORMA		* FORMAT STATEMENT
SADRL	EQU  $
	DATA IADRL		* ADDRESS LITERAL
SDATA	EQU  $
	DATA IDATA		* ABSOLUTE DATA
SDATAS	EQU  $
	DATA IDATST		* START OF DATA
SDELTA	EQU  $
	DATA IDELTA		* DELTA REFERENCE
EDATA	EQU  $
	DATA IENDAT		* END OF DATA
ELOGI	EQU  $
	DATA IENDLG		* END OF LOGIC
LISTOF	EQU  $
	DATA ILISTO		* LIST FLAG ON/OFF
SKIPIT	EQU  $
	DATA MAINLO		* SKIP the intermediate code
*
*  Type of opcode conditions (32 possible)
*
GENERAL	MACRO			GENERAL JUMP TABLE WITH NO ARGUMENT
	DATA %1-GENJMP
	ENDM
*
BRANCH	MACRO
	DATA %1-OPCST/2+>0800	BRANCH, CONDITIONAL OR NOT
	ENDM
*
INSTRU	MACRO
	DATA %1-OPCST/2+>1000	INSTRUCTION TYPE
	ENDM
*
LOGICA	MACRO
	DATA %1-OPCST/2+>1800	LOGICAL CONSTRUCT
	ENDM
*
RUNTIN	MACRO			EXECUTION TIME W/NO ARG
	DATA %1-OPCST/2+>2000
	ENDM
*
RUNTIC	MACRO			EXECUTION TIME W/ARGUMENT AND COUNT
	DATA %1-OPCST/2+>2800
	ENDM
*
GENRFN	MACRO			GENERATE SPECIAL EXTERNAL REFERENCE
	DATA %1-PSPSTA+>3000
	ENDM
*				GENERATE SPEC REF W/ARGUMENT
GENRFT	MACRO
	DATA %1-PSPSTA+>3800
	ENDM
*				GENERATE SPEC REF W/ARGUMENT AND COUNT
GENRFC	MACRO
	DATA %1-PSPSTA+>4000
	ENDM
*
FUNCCE	MACRO			FUNCTION CALL END
	DATA %1-OPCST/2+>4800
	ENDM
*
GENCVT	MACRO			GENERATE CONVERSION
	DATA %1-OPCST/2+>5000
	ENDM
*
PERIOF	MACRO			SCALAR, ARRAY, OR ADJUSTABLE I/O
	DATA %1-OPCST/2+>5800
	ENDM
*
GENADL	MACRO			GENERATE ABSOLUTE WORD & ADDRESS
	DATA %1-OPCST/2+>6000
	ENDM
*
ABSLO1	MACRO			GENERATE 1 ABSOLUTE WORD
	DATA %1-OPCST/2+>6800
	ENDM
*
ABSLO2	MACRO			GENERATE 2 ABSOLUTE WORDS
	DATA %1-OPCST/2+>7000
	ENDM
*
ABSLO3	MACRO			GENERATE 3 ABSOLUTE WORDS
	DATA %1-OPCST/2+>7800
	ENDM
*
ABSLO4	MACRO			GENERATE 4 ABSOLUTE WORDS
	DATA %1-OPCST/2+>8000
	ENDM
*
ABSLO5	MACRO			GENERATE 5 ABSOLUTE WORDS
	DATA %1-OPCST/2+>8800
	ENDM
*
ABSLO6	MACRO			GENERATE 6 ABSOLUTE WORDS
	DATA %1-OPCST/2+>9000
	ENDM
*
ABSLO8	MACRO			GENERATE 8 ABSOLUTE WORDS
	DATA %1-OPCST/2+>9800
	ENDM
*
ABSLO9	MACRO			GENERATE 9 ABSOLUTE WORDS
	DATA %1-OPCST/2+>A000
	ENDM
*				GENERATE 11 ABSOLUTE WORDS
ABSL11	MACRO
	DATA %1-OPCST/2+>A800
	ENDM
*				GENERATE 12 ABSOLUTE WORDS
ABSL12	MACRO
	DATA %1-OPCST/2+>B000
	ENDM
*				GENERATE 14 ABSOLUTE WORDS
ABSL14	MACRO
	DATA %1-OPCST/2+>B800
	ENDM
*				GENERATE 15 ABSOLUTE WORDS
ABSL15	MACRO
	DATA %1-OPCST/2+>C000
	ENDM
*
GENAD2	MACRO			GENERATE 2 WORD INSTRUCTION
	DATA %1-OPCST/2+>C800
	ENDM
*
*
*  The following table is organized as the 256 possible opcodes
*  which may be passed to FORTRAN3 by the FORTRAN2 package or
*  the FORTRAN4 optimizer.  
*
OPCTBL	EQU  $
	BRANCH	OPC00		00 BRANCH
	BRANCH	OPC01		01 BRIF <
	BRANCH	OPC02		02 BRIF =
	INSTRU	OPC03		03 INCR
	INSTRU	OPC04		04 AND
	INSTRU	OPC05		05 ADD
	INSTRU	OPC06		06 LOAD
	INSTRU	OPC07		07 STORE
	INSTRU	OPC08		08 COMPARE
	INSTRU	OPC09		09 DIVIDE
	INSTRU	OPC0A		0A MULTIPLY
	INSTRU	OPC0B		0B SUBTRACT
	PERIOF	OPC0C		0C SCALAR I/O
	PERIOF	OPC0D		0D ARRAY I/O
	PERIOF	OPC0E		0E ADJUSTABLE ARRAY I/O
	INSTRU	OPC0F		0F OR
	INSTRU	OPC10		10 XOR
	GENRFT  PSUBCH 		11 SUBCHK
	GENRFT  PADDCH		12 ADSCHK
	LOGICA	OPC13		13 <=
	LOGICA	OPC14		14 =
	LOGICA	OPC15		15 >=
	LOGICA	OPC16		16 >
	LOGICA	OPC17		17 .NE.
	GENERAL LABEL		18 LABEL
	GENERAL BOS		19 BOS
	FUNCCE	OPC1A		1A FUNCTION CALL END
	LOGICA	OPC1B		1B .OR.
	GENERAL FORMAT		1C FORMAT STATEMENT
	INSTRU	OPC1D		1D INCR BY 2
	INSTRU	OPC1E		1E DECR
	INSTRU	OPC1F		1F DECR BY 2
	ABSLO1	OPC20		20 CLEAR
	ABSLO1	OPC21		21 SETO
	ABSLO1	OPC22		22 MULTIPLY BY 16
	ABSLO1	OPC23		23 MULTIPLY BY 32
	ABSLO1	OPC24		24 MULTIPLY BY 64
	ABSLO1	OPC25		25 MULTIPLY BY 128
	ABSLO1	OPC26		26 MULTIPLY BY 256
	RUNTIN  OPC27		27 CHARACTER I/O
	GENERAL	FUTURE		28
	GENERAL	FUTURE		29
	GENERAL	FUTURE		2A
	GENERAL	FUTURE		2B
	GENERAL	FUTURE		2C
	GENERAL	FUTURE		2D
	GENERAL	FUTURE		2E
	ABSLO1	OPC2F		2F MOV R5,R7
	ABSLO1	OPC30		30 MOV R5,*R7
	ABSLO1	OPC31		31 MOV R7,R5
	ABSLO1	OPC32		32 MOV *R7,R5
	ABSLO1	OPC33		33 MOV R5,R8
	ABSLO1	OPC34		34 MOV R5,*R8
	ABSLO1	OPC35		35 MOV R8,R5
	ABSLO1	OPC36		36 MOV R8,*R5
	ABSLO1	OPC37		37 MOV R5,R9
	ABSLO1	OPC38		38 MOV R5,*R9
	ABSLO1	OPC39		39 MOV R9,R5
	ABSLO1	OPC3A		3A MOV R9,*R5
	BRANCH	OPC3B		3B BRIF .NE.
	BRANCH	OPC3C		3C BRIF >
	GENERAL	FUTURE		3D
	GENERAL	FUTURE		3E
	GENERAL	FUTURE		3F
	GENERAL	FUTURE		40
	RUNTIN	OPC41		41 STOPIO
	RUNTIC	OPC42		42 START I/O
	GENRFN  PSTOP		43 STOP
	GENRFN  PPAUSE		44 PAUSE
	ABSLO5	OPC45		45 RETURN
	GENRFN	PSTOPN		45 STOP n
	GENERAL	FUTURE		47
	GENERAL	FUTURE		48
	GENERAL	FUTURE		49
	GENERAL	FUTURE		4A
	GENERAL	FUTURE		4B
	GENRFN  PNUMBC		4C NDSCHK
	GENERAL	FUTURE		4D
	GENERAL	FUTURE		4E
	GENERAL	FUTURE		4F
	GENRFC	PCALL		50 CALL SUBROUTINE/FUNCTION
	GENRFC	PFUNCT		51 FUNCTION
	GENRFN  PCGTEX		52 COMPUTED GOTO
	GENERAL SADRL		53 ADDRESS LITERAL
	GENERAL SDATA		54 DATA
	GENERAL SDATAS		55 DATA STATEMENT
	GENERAL SDELTA		56 SET DELTA
	GENERAL EDATA		57 END DATA
	GENERAL ELOGI		58 END LOGIC
	GENERAL LISTOF		59 LIST / NOLIST
	ABSLO1	OPC5A		5A INCREMENT R5
	ABSLO1	OPC5B		5B DECREMENT R5
	ABSLO1	OPC5C		5C DECREMENT BY 2 R5
	ABSLO1	OPC5D		5D MOVE INDIRECT THRU R5
	ABSLO1	OPC5E		5E MOVE INDIRECT THRU R5 (BYTE)
	ABSLO1	OPC5F		5F ABS
	ABSLO2	OPC60		60 AND ONE
	ABSLO1	OPC61		61 COMPARE WITH ZERO
	ABSLO1	OPC62		62 MULTIPLY TIMES 2
	ABSLO1	OPC63		63 ADD R5 TO R1
	ABSLO1	OPC64		64 INCREMENT R5
	ABSLO1	OPC65		65 ADD R1 TO R5
	ABSLO1	OPC66		66 CLEAR R5
	ABSLO1	OPC67		67 MOVE TO R1
	ABSLO4	OPC68		68 .EQ.
	ABSLO8	OPC69		69 INTEGER *4 ABSOLUTE
	ABSLO1	OPC6A		6A INVERT R5
	INSTRU  OPC6B		6B MOV @X,@Y
	ABSLO3	OPC6C		6C SET STATUS FOR INTEGER *4
	INSTRU  OPC6D		6D CLR @
	INSTRU  OPC6E		6E SETO @
	GENCVT	OPC6F		6F NEGATE
	GENCVT	OPC70		70 CONVERT
	GENERAL	FUTURE		71
	GENERAL	FUTURE		72
	GENERAL	FUTURE		73
	GENERAL SDATAS		74 DATA START 
	GENERAL	FUTURE		75
	GENERAL	FUTURE		76
	GENERAL	FUTURE		77
	ABSLO1	OPC78		78 MULTIPLY TIMES 4
	ABSLO1	OPC79		79 MULTIPLY TIMES 8
MAXOPC	EQU  $-OPCTBL		NUMBER OF VALID OPCODES
*
*  Start of opcode
*
OPCST	EQU  $		     	Start of opcodes
*				BRANCH
OPC00	EQU  $	
	DATA >1000		SHORT FORM   (JMP)
	DATA 1
	DATA >0460		LONG FORM
*				BRIF <
OPC01	EQU  $	
	DATA >1100	  	SHORT FORM   (JLT)
	DATA 3
	JGT  $+8	  	LONG FORM
	JEQ  $+6
OPC01A	DATA >0460
*				BRIF =
OPC02	EQU  $	
	DATA >1300	   	SHORT FORM (JEQ)
	DATA 2
	JNE  $+6
	DATA >0460
*				INCREMENT
OPC03	EQU  $	
*  I*1 INSTRUCTIONS
	GENERAL	FUTURE
	ABSLO3	SUB25
	ABSLO3	SUB25
*  I*2 INSTRUCTIONS
	GENERAL	FUTURE
	GENADL	SUB26
	ABSLO1	SUB27
*  I*4 INSTRUCTIONS
	ABSLO5	SUB14
*  R*4, R*8 INSTRUCTIONS
	GENERAL	FUTURE
	GENERAL	FUTURE
*  C*8, C*16 INSTRUCTIONS
	GENERAL FUTURE
	GENERAL FUTURE
*
*			AND
OPC04	EQU  $	
*  I*1 INSTRUCTIONS
	GENADL	SUB28
	ABSLO3	SUB29
	ABSLO3	SUB29
*  I*2 INSTRUCTIONS
	GENADL	SUB28
	ABSLO3	SUB30
	ABSLO3	SUB30
*  I*4 INSTRUCTIONS
	ABSLO6	SUB15
*  R*4, R*8 INSTRUCTIONS
	GENERAL	FUTURE
	GENERAL	FUTURE
*  C*8, C*16 INSTRUCTIONS
	GENERAL FUTURE
	GENERAL FUTURE
*
*			ADD
OPC05	EQU  $	
*  I*1 INSTRUCTIONS
	ABSLO1	SUB31		CONSTANT
	GENADL	SUB32		DIRECT
	ABSLO1	SUB33		INDIRECT
*  I*2 INSTRUCTIONS
	GENADL	SUB34		CONSTANT
	GENADL	SUB35		DIRECT
	ABSLO1	SUB36		INDIRECT
*  I*4 INSTRUCTIONS
	ABSLO6	SUB16
*  R*4, R*8 INSTRUCTIONS (LINKAGES TO SUBROUTINES)
	GENRFN	PSPADD
	GENRFN	PDPADD
*  C*8, C*16 INSTRUCTIONS (LINKAGES TO SUBROUTINES)
	GENRFN	PC8ADD
	GENRFN	PC6ADD
*
*			LOAD
OPC06	EQU  $	
*  I*1 INSTRUCTIONS
	GENADL	SUB37		CONSTANT
	GENADL	SUB38		DIRECT
	ABSLO1	SUB40		INDIRECT
*  I*2 INSTRUCTIONS
	GENADL	SUB37		CONSTANT
	GENADL	SUB39		DIRECT
	ABSLO1	SUB41		INDIRECT
*  I*4 INSTRUCTIONS
	ABSLO2	SUB17
*  R*4, R*8 INSTRUCTIONS
	ABSLO4	SUB12
	ABSLO4	SUB13
*  C*8, C*16 PSUEDO INSTRUCTIONS
	ABSLO4	SUB13
	GENRFN	PC6LOA
*
*			STORE
OPC07	EQU  $	
*  I*1 INSTRUCTIONS
	GENERAL	FUTURE		CONSTANT (ILLEGAL)
	GENADL	SUB42		DIRECT
	ABSLO1	SUB43		INDIRECT
*  I*2 INSTRUCTIONS
	GENERAL	FUTURE		CONSTANT (ILLEGAL)
	GENADL	SUB44		DIRECT
	ABSLO1	SUB45		INDIRECT
*  I*4 INSTRUCTIONS
	ABSLO2	SUB18
*  R*4, R*8 INSTRUCTIONS
	ABSLO2	SUB10
	ABSLO4	SUB11
*  C*8, C*16 INSTRUCTIONS
	ABSLO4  SUB11
	GENRFN  PC6STO
*
*			COMPARE
OPC08	EQU  $	
*  I*1 INSTRUCTIONS
	ABSLO1	SUB46		CONSTANT
	GENADL  SUB47		DIRECT
	ABSLO1	SUB48		INDIRECT
*  I*2 INSTRUCTIONS
	GENADL  SUB49		CONSTANT
	GENADL  SUB50		DIRECT
	ABSLO1  SUB50A		INDIRECT
*  I*4 INSTRUCTIONS
	ABSLO8	SUB19		I*4 COMPARE
*  R*4, R*8 INSTRUCTIONS
	GENRFN	PSPCMP
	GENRFN	PDPCMP
*  C*4, C*16 INSTRUCTIONS
	GENRFN	PC8CMP
	GENRFN	PC6CMP
*
*			DIVIDE
OPC09	EQU  $	
	IF   TMS9995
*  I*1 INSTRUCTIONS
	ABSLO8	SUB51		CONSTANT
	ABSLO9  SUB52		DIRECT
	ABSLO9  SUB52		INDIRECT
*  I*2 INSTRUCTIONS
	ABSLO5	SUB53		CONSTANT
	ABSLO6  SUB54		DIRECT
	ABSLO6  SUB54		INDIRECT
	ELSE
*  I*1 INSTRUCTIONS
	ABSL14	SUB51		CONSTANT
	ABSL15  SUB52		DIRECT
	ABSL15	SUB52		INDIRECT
*  I*2 INSTRUCTIONS
	ABSL11	SUB53		CONSTANT
	ABSL12	SUB54		DIRECT
	ABSL12	SUB54		INDIRECT
	ENDIF
*  I*4 INSTRUCTIONS
	GENRFN	PI4DIV
*  R*4, R*8 INSTRUCTIONS
	GENRFN	PSPDIV
	GENRFN	PDPDIV
*  C*8, C*16 INSTRUCTIONS
	GENRFN  PC8DIV
	GENRFN  PC6DIV
*
*			MULTIPLY
OPC0A	EQU  $	
*  I*1 ARGUMENTS
	ABSLO2	SUB55
	ABSLO2	SUB56
	ABSLO2	SUB56
*  I*2 ARGUMENTS
	ABSLO2	SUB57
	ABSLO2	SUB59
	ABSLO2	SUB59
*  I*4 ARGUMENTS
	GENRFN	PI4MUL
*  R*4, R*8 ARGUMENTS
	GENRFN	PSPMUL
	GENRFN	PDPMUL
*  C*8, C*16 INSTRUCTIONS
	GENRFN  PC8MUL
	GENRFN  PC6MUL
*
*			SUBTRACT
OPC0B	EQU  $	
*  I*1 INSTRUCTIONS
	ABSLO1	SUB60		CONSTANT
	GENADL	SUB61		DIRECT
	ABSLO1	SUB62		INDIRECT
*  I*2 INSTRUCTIONS
	ABSLO1	SUB63		CONSTANT
	GENADL	SUB64		DIRECT
	ABSLO1	SUB65		INDIRECT
*  I*4 INSTRUCTIONS
	ABSL11	SUB20
*  R*4, R*8 INSTRUCTIONS
	GENRFN	PSPSUB
	GENRFN	PDPSUB
*  C*8, C*16 INSTRUCTIONS
	GENRFN	PC8SUB
	GENRFN  PC6SUB
*
OPC0C	EQU  $	
	DATA SCLRIO		SCALAR I/O
*
OPC0D	EQU  $	
	DATA ARRYIO		ARRAY I/O
*
OPC0E	EQU  $	
	DATA ADJUIO		ADJUSTABLE I/O
*			OR
OPC0F	EQU  $	
*  I*1 INSTRUCTIONS
	GENADL	SUB66
	GENADL  SUB67
	ABSLO1  SUB68
*  I*2 INSTRUCTIONS
	GENADL  SUB66
	GENADL  SUB69
	ABSLO1  SUB70
*  I*4 INSTRUCTIONS
	ABSLO2	SUB22
*  R*2, R*4 INSTRUCTIONS
	GENERAL	FUTURE
	GENERAL	FUTURE
*  C*4, C*16 INSTRUCITONS
	GENERAL FUTURE
	GENERAL FUTURE
*			XOR
OPC10	EQU  $	
*  I*1 INSTRUCTIONS
	ABSLO1	SUB71
	ABSLO1	SUB72
	ABSLO1	SUB72
*  I*2 INSTRUCTIONS
	ABSLO1	SUB71
	ABSLO1	SUB72
	ABSLO1	SUB72
*  I*4 INSTRUCTIONS
	ABSLO2	SUB23
*  R*2, R*4 INSTRUCTIONS
	GENERAL	FUTURE
	GENERAL	FUTURE
*  C*8, C*16 INSTRUCTIONS
	GENERAL FUTURE
	GENERAL FUTURE
*				SUBTRACT CHECK
*  RELATIONAL OPERATORS
*				SET STATUS ON LE
OPC13	EQU  $	
	DATA 4
	CLR  R5
	JGT  OPC13A
	SETO R5
OPC13A	NEG  R5
*				SET STATUS ON LT
OPC14	EQU  $	
	DATA 4
	SETO R5
	JLT  OPC14A
	CLR  R5
OPC14A	NEG  R5
*				SET STATUS ON GE
OPC15	EQU  $	
	DATA 4
	CLR  R5
	JLT  OPC15A
	SETO R5
OPC15A	NEG  R5
*				SET STATUS ON GT
OPC16	EQU  $	
	DATA 4
	SETO R5
	JGT  OPC16A
	CLR  R5
OPC16A	NEG  R5
*				SET STATUS ON NE
OPC17	EQU  $	
	DATA 4
	SETO R5
	JNE  OPC17A
	CLR  R5
OPC17A	NEG  R5
*				FUNCTION CALL END
OPC1A	EQU  $	
	DATA 2
	MOV  R5,R5		IN CASE LOGICAL EXIT
	B    *R2	 	RETURN
*				SET STATUS ON OR
OPC1B	EQU  $	
	DATA 3
	JEQ  OPC1BA
	SETO R5
OPC1BA	NEG  R5
*				INCREMENT BY 2
OPC1D	EQU  $	
*  I*1 ARGUMENTS
	GENERAL	FUTURE
	GENERAL	FUTURE
	GENERAL	FUTURE
*  I*2 ARGUMENTS
	GENERAL	FUTURE
	GENADL	SUB73
	ABSLO1  SUB74
*  I*4 ARGUMENTS
	GENERAL	FUTURE
*  R*2, R*4 ARGUMENTS
	GENERAL	FUTURE
	GENERAL	FUTURE
*  C*8, C*16 ARGUMENTS
	GENERAL FUTURE
	GENERAL FUTURE
*				DECREMENT
OPC1E	EQU  $
*  I*1 ARGUMENTS
	GENERAL	FUTURE
	GENERAL	FUTURE
	GENERAL	FUTURE
*  I*2 ARGUMENTS
	GENERAL	FUTURE
	GENADL	SUB75
	ABSLO1	SUB76
*  I*4 ARGUMENT
	GENERAL	FUTURE
*  R*2, R*4 ARGUMENTS
	GENERAL	FUTURE
	GENERAL FUTURE
*  C*8, C*16 ARGUMENTS
	GENERAL FUTURE
	GENERAL FUTURE
*				DECREMENT BY 2
OPC1F	EQU  $
*  I*1 ARGUMENTS
	GENERAL	FUTURE
	GENERAL	FUTURE
	GENERAL	FUTURE
*  I*2 ARGUMENTS
	GENERAL	FUTURE
	GENADL  SUB77
	ABSLO1  SUB78
*  I*4 ARGUMENTS
	GENERAL	FUTURE
*  R*2, R*4 ARGUMENTS
	GENERAL	FUTURE
	GENERAL	FUTURE
*  C*8, C*16 ARGUMENTS
	GENERAL FUTURE
	GENERAL FUTURE
*				CLEAR
OPC20	EQU  $	
	CLR  R5
*				SET TO ONES
OPC21	EQU  $	
	SETO R5
*				MULTIPLY BY 16
OPC22	EQU  $	
	SLA  R5,4
*				MULTIPLY BY 32
OPC23	EQU  $	
	SLA  R5,5
*				MULTIPLY BY 64
OPC24	EQU  $	
	SLA  R5,6
*				MULTIPLY BY 128
OPC25	EQU  $	
	SLA  R5,7
*				MULTIPLY BY 256
OPC26	EQU  $	
	SLA  R5,8
*				EXECUTION TIME CHARACTER I/O
OPC27	EQU  $
	DATA CHARIO
*				MOVE TO ADDRESS TEMP 1
OPC2F	EQU  $	
	MOV  R5,R4
* 				MOVE TO ADDRESS TEMP 1 (INDIRECT)
OPC30	EQU  $	
	MOV  R5,*R4
*				MOVE FROM ADDRESS TEMP 1
OPC31	EQU  $	
	MOV  R7,R4
*				MOVE FROM ADDRESS TEMP 1 (INDIRECT)
OPC32	EQU  $	
	MOV  *R7,R4
*				MOVE TO ADDRESS TEMP 2
OPC33	EQU  $	
	MOV  R5,R12
*				MOVE TO ADDRESS TEMP 2 (INDIRECT)
OPC34	EQU  $	
	MOV  R5,*R12
*				MOVE FROM ADDRESS TEMP 2
OPC35	EQU  $	
	MOV  R8,R12
*				MOVE FROM ADDRESS TEMP 2 (INDIRECT)
OPC36	EQU  $	
	MOV  *R8,R12
*				MOVE TO ADDRESS TEMP 3
OPC37	EQU  $	
	MOV  R5,R9
*				MOVE TO ADDRESS TEMP 3 (INDIRECT)
OPC38	EQU  $	
	MOV  R5,*R9
*				MOVE FROM ADDRESS TEMP 3
OPC39	EQU  $	
	MOV  R9,R5
*				MOVE FROM ADDRESS TEMP 3 (INDIRECT)
OPC3A	EQU  $	
	MOV  *R9,R5
*				BRIF .ne.
OPC3B	EQU  $	
	DATA >1600	  	SHORT FORM (JNE)
	DATA 2
	JEQ  $+6
	B    @0
	RORG $-2
*				BRIF .gt.
OPC3C	EQU  $	
	DATA >1500	  	SHORT FORM (JGT)
	DATA 3
	DATA >0301
	JLT  $+8
	JEQ  $+6
	B    @0
	RORG $-2
*				STOP I/O
OPC41	EQU  $	
	DATA STOPIO
*				START I/O
OPC42	EQU  $	
	DATA STARTI
*				PROGRAM RETURN
OPC45	EQU  $	
	MOV  @2(R3),R11		 RESTORE RETURN
	MOV  *R3,R3		 RESTORE OLD BASE
	MOV  R5,R5		 RESTORE STATUS
	B    *R11		 RETURN
*				INCREMENT BY 2 R5
OPC5A	EQU  $	
	INCT R5
*				DECREMENT R5
OPC5B	EQU  $	
	DEC  R5
*				DECREMENT BY 2 R5
OPC5C	EQU  $	
	DECT R5
*				MOVE INDIRECT THRU R5
OPC5D	EQU  $	
	MOV  *R5,R5
*				MOVE INDIRECT THRU R5 (BYTE)
OPC5E	EQU  $	
	MOVB *R5,R5
*				ABSOLUTE VALUE
OPC5F	EQU  $	
	ABS  R5
*				AND WITH 1
OPC60	EQU  $	
	ANDI R5,1
*				SET STATUS BITS (COMPARE WITH ZERO)
OPC61	EQU  $	
	MOV  R5,R5
*				ADD R5 TO R5 (*2)
OPC62	EQU  $	
	A    R5,R5
*				ADD R5 TO TEMP
OPC63	EQU  $	
	A    R5,R1
*				INCREMENT R5
OPC64	EQU  $	
	INC  R5
*				ADD TEMP TO R5
OPC65	EQU  $	
	A    R1,R5
*				CLEAR R5
OPC66	EQU  $	
	CLR  R5
*				MOVE R5 TO R1
OPC67	EQU  $	
	MOV  R5,R1
*				SET STATUS ON EQ	
OPC68	EQU  $	
	SETO R5
	JEQ  OPC68A
	CLR  R5
OPC68A	NEG  R5
*
OPC69	EQU  $			INTEGER *4 ABSOLUTE
	MOV  R5,R5		IS ARGUMENT NEGATIVE?
	JEQ  OPC69A		BRIF NO
	JGT  OPC69A
	INV  R5			ELSE, INVERT ARGUMENT
	INV  R6
	INC  R6			ADD ONE TO RESULT
	JNC  OPC69A		FOR TWO'S COMPLEMENT
	INC  R5
OPC69A	EQU  $
*				INVERT R5
OPC6A	EQU  $	
	INV  R5
	INV  R5
*				MOV @X,@Y
OPC6B	EQU  $	
*  I*1 INSTRUCTIONS
	GENERAL	FUTURE
	GENAD2  SUB86		MOVB @X,@Y
	GENERAL FUTURE
*  I*2 INSTRUCTIONS
	GENERAL	FUTURE
	GENAD2  SUB87		MOV @X,@Y
	GENERAL FUTURE
*  I*4 INSTRUCTIONS
	GENERAL FUTURE
*  R*4, R*8 INSTRUCTIONS
	GENERAL	FUTURE
	GENERAL	FUTURE
*  C*8, C*16 INSTRUCTIONS
	GENERAL FUTURE
	GENERAL FUTURE
*				SET STATUS BITS FOR INTEGER *4
OPC6C	EQU  $	
	MOV  R5,R5		CHECK HIGH END
	JNE  OPC6CA		BRIF SOMETHING HERE
	MOV  R6,R6		ELSE, CHECK LOW END
OPC6CA	EQU  $
*				CLR @
OPC6D	EQU  $	
*  I*1 INSTRUCTIONS
	GENERAL	FUTURE
	GENERAL FUTURE
	GENERAL FUTURE
*  I*2 INSTRUCTIONS
	GENERAL	FUTURE
	GENADL	SUB80
	ABSLO1	SUB81
*  I*4 INSTRUCTIONS
	ABSLO2	SUB82
*  R*4, R*8 INSTRUCTIONS
	GENERAL	FUTURE
	GENERAL	FUTURE
*  C*4, C*16 INSTRUCTIONS
	GENERAL FUTURE
	GENERAL FUTURE
*				SETO @
OPC6E	EQU  $	
*  I*1 INSTRUCTIONS
	GENERAL	FUTURE
	GENERAL FUTURE
	GENERAL FUTURE
*  I*2 INSTRUCTIONS
	GENERAL	FUTURE
	GENADL	SUB83
	ABSLO1	SUB84
*  I*4 INSTRUCTIONS
	ABSLO2	SUB85
*  R*4, R*8 INSTRUCTIONS
	GENERAL	FUTURE
	GENERAL	FUTURE
*  C*4, C*16 INSTRUCTIONS
	GENERAL FUTURE
	GENERAL FUTURE
*				MULTIPLY TIMES 4
OPC78	EQU  $	
	SLA  R5,2
*				MULTIPLY TIMES 8
OPC79	EQU  $	
	SLA  R5,3
*
*  Conversion functions
*
*
CVT01	EQU $			I*2 TO I*1
	SLA  R5,8
*
CVT05	EQU $			I*2 TO I*4
	MOV  R5,R6
	SRA  R5,15
*
CVT10	EQU $			I*1 TO I*2
	SRA  R5,8
*
CVT15	EQU $			I*1 TO I*4
	SRA  R5,8
	MOV  R5,R6
	SRA  R5,7
*				R*4 TO R*8
CVT24	EQU  $
	CLR  R7
	CLR  R8
*
CVT50	EQU  $			I*4 TO I*2
	MOV  R6,R5
*
CVT51	EQU  $			I*4 TO I*1
	MOV  R6,R5
	SLA  R5,8
*
*  NEGATE FUNCTIONS, INDEXED BY DATA TYPE
*
OPC6F	EQU  $
	ABSLO1	SUB21		00 - INTEGER *2
	ABSLO1	SUB21		01 - INTEGER *1
	ABSLO5	SUB79		02 - INTEGER *4
	ABSLO1	SUB21		03 - REAL *4
	ABSLO1	SUB21		04 - REAL *8
	GENRFN	PC8NEG		05 - COMPLEX *8
	GENRFN	PC6NEG		06 - COMPLEX *16
	GENERAL FUTURE		07 - FUTURE
*
*  DATA TYPE CONVERSIONS, INDEXED BY CONVERT FROM, CONVERT TO
*
OPC70	EQU  $			CONVERSION START
	GENERAL FUTURE		00 - II
	ABSLO1  CVT01		01 - IK
	ABSLO2  CVT05		02 - IJ
	GENRFN  PIACVT		03 - IA
	GENRFN  PIDCVT		04 - ID
	GENRFN	PICCVT		05 - IC
	GENRFN	PIECVT		06 - IE
	GENERAL FUTURE		07 - IL
*
	ABSLO1	CVT10		10 - KI
	GENERAL FUTURE		11 - KK
	ABSLO3	CVT15		12 - KJ
	GENRFN	PKACVT		13 - KA
	GENRFN	PKDCVT		14 - KD
	GENRFN	PKCCVT		15 - KC
	GENRFN	PKECVT		16 - KE
	GENERAL FUTURE		17 - KL
*
	ABSLO1  CVT50		20 - JI
	ABSLO2	CVT51		21 - JK
	GENERAL FUTURE		22 - JJ
	GENRFN	PJACVT		23 - JA
	GENRFN	PJDCVT		24 - JD
	GENRFN	PJCCVT		25 - JC
	GENRFN	PJECVT		26 - JE
	GENERAL FUTURE		27 - JL
*
	GENRFN	PAICVT		30 - AI
	GENRFN	PAKCVT		31 - AK
	GENRFN	PAJCVT		32 - AJ
	GENERAL FUTURE		33 - AA
	GENERAL SKIPIT		34 - AD
	ABSLO2	CVT24		35 - AC
	GENRFN	PAECVT		36 - AE
	GENERAL FUTURE		37 - AL	
*
	GENRFN	PDICVT		40 - DI
	GENRFN	PDKCVT		41 - DK
	GENRFN	PDJCVT		42 - DJ
	GENERAL SKIPIT		43 - DA
	GENERAL FUTURE		44 - DD
	ABSLO2	CVT24		45 - DC
	GENRFN	PDECVT		46 - DE
	GENERAL FUTURE		47 - DL
*
	GENRFN	PCICVT		50 - CI
	GENRFN	PCKCVT		51 - CK
	GENRFN	PCJCVT		52 - CJ
	ABSLO2	CVT24		53 - CA
	ABSLO2  CVT24		54 - CD
	GENERAL FUTURE		55 - CC
	GENRFN	PCECVT		56 - CE
	GENERAL FUTURE		57 - CL
*
	GENRFN	PEICVT		60 - EI
	GENRFN	PEKCVT		61 - EK
	GENRFN	PEJCVT		62 - EJ
	ABSLO2  CVT24		63 - EA
	GENERAL SKIPIT		64 - ED
	GENRFN  PECCVT		65 - EC
	GENERAL FUTURE		66 - EE
	GENERAL FUTURE		67 - EL	
*
*  The following are substrings which "fill-in" the rest
*  of the opcode information.
*
SUB01	EQU  $			PROLOUGE TO MAIN
	DATA SUB01E/2
SUB01A	EQU  $
	JMP  AROUND		; NON-DEBUGGER ENTRY
	JMP  DEBUGE		; DEBUGGER ENTRY
	DATA 0			; LOGIC START
	DATA 0			; LOGIC END
	DATA 0			; DATA START
	DATA 0			; DATA END
COMSTR  EQU  $-SUB01A
	DATA 0			; COMMON START
	DATA 0			; COMMON END
AROUND	EQU  $
	LWPI MYWSP		; SET MY WORKSPACE
	IF   GENEVE
	LI   R8,MEMXOP		; MEMORY XOP NUMBER
	LI   R7,FORTBG		; FORTRAN BEGINNING LOCATION
	MOV  @COMSTR(R7),R1	; COMMON START
	NEG  R1
	AI   R1,>2000		; ROUND UP # PAGES TO GET
	SRA  R1,13
	ANDI R1,7
	JEQ  NOPAGR
	LI   R0,GETLCP		; GET LOCAL PAGES
	MOV  R1,R2		; COMPUTE FIRST PAGE NUMBER
	NEG  R2
	AI   R2,8
	CLR  R3			; USE SLOW MEMORY
	XOP  @MYWSP+16,0	; DO MEMORY XOP
NOPAGR	EQU  $
	LI   R5,1		; MAP IN SEVEN PAGES (MAXIMUM)
NOPAGL	EQU  $
	LI   R0,MAPLCP		; MAP LOCAL PAGE TO EXECUTION PAGE
	MOV  R5,R1		; PAGE NUMBER TO MAP
	MOV  R5,R2		; TO PHYSICAL PAGE NUMBER
	XOP  @MYWSP+16,0	; DO MEMORY XOP
	INC  R5
	CI   R5,8		; MAP LAST PAGE?
	JNE  NOPAGL		; BRIF NO
	ENDIF
	CLR  R5			; SET NO DEBUGGER ENTRY
	JMP  NEXTEN
DEBUGE	EQU  $
	SETO R5			; SET DEBUGGER ENTRY
NEXTEN	EQU  $
	LI   R7,0		; LOAD R3 WITH DATA AREA ADDRESS
	RORG $-2
SUB01E	EQU  $-SUB01A		; LENGTH OF PROLOUGE (MINUS 2 BYTES)
PROLEN	EQU  SUB01E+10		; TOTAL LENGTH OF PROLOUGE
*
SUB02	EQU  $
	BLWP *R10		CALL EXECUTION TIME VIA R10
*
SUB03	EQU  $			BRANCH INDIRECT $+1
	B    @0
	RORG $-2
*
SUB04	EQU  $			DIRECT FORM OF FLOATING POINT LOAD
	LI   R2,0
	RORG $-2
*
SUB05	EQU  $			INDIRECT FORM OF FLOATING POINT LOAD
	MOV  @0,R2
	RORG $-2
*
SUB06	EQU  $			FORTRAN ERROR CALL (ILLEGAL ENTRY)
	DATA 2
	BLWP *R10
	DATA ERRCAL
*
SUB07	EQU  $			BRANCH RELATIVE
	NOP
*
SUB09	EQU  $
	BL   @0			FIRST PART OF BRANCH AND LINK
	RORG $-2
*
SUB10	EQU  $			STORE SINGLE PRECISION
	MOV  R5,*R2+
	MOV  R6,*R2
*
SUB11	EQU  $			STORE DOUBLE PRECISION
	MOV  R5,*R2+
	MOV  R6,*R2+
	MOV  R7,*R2+
	MOV  R8,*R2
*
SUB12	EQU  $	
	MOV  *R2+,R5		LOAD SINGLE PRECISION
	MOV  *R2,R6
	CLR  R7
	CLR  R8
*
SUB13	EQU  $	
	MOV  *R2+,R5		LOAD DOUBLE PRECISION
	MOV  *R2+,R6
	MOV  *R2+,R7
	MOV  *R2,R8
*
SUB14	EQU  $			INCREMENT ACCUMULATOR
	INCT R2			DINC
	INC  *R2
	JNC  SUB14A
	DECT R2
	INC  *R2
SUB14A	EQU  $
*
SUB15	EQU  $	
	MOV  *R2+,R1
	INV  R1
	SZC  R1,R5
	MOV  *R2,R1
	INV  R1
	SZC  R1,R6
*
SUB16	EQU  $	
	INCT R2
	A    *R2,R6
	JNC  SUB16A
	INC  R5
SUB16A	EQU  $
	DECT R2
	A    *R2,R5
*
SUB17	EQU  $	
	MOV  *R2+,R5		LOAD I*4
	MOV  *R2,R6
*
SUB18	EQU  $	
	MOV  R5,*R2+
	MOV  R6,*R2
*				I*4 COMPARE
SUB19	EQU  $
	C    R5,*R2+		CHECK FIRST WORD
	JNE  SUB19B		BRIF NOT THE SAME, COMPARE WORKED
	MOV  R6,R7
	XOR  *R2,R7		GET 2ND WORD
	JLT  SUB19A		BRIF NO
	C    R6,*R2		ELSE, CAN USE NORMAL COMPARE
	JMP  SUB19B
SUB19A	EQU  $
	C    *R2,R6		ELSE, FLIP COMPARE
SUB19B	EQU  $
*
SUB20	EQU  $			DOUBLE WORD SUBTRACT
	MOV  *R2+,R0		  GET THE VALUE
	MOV  *R2,R1
	INV  R0			  DOUBLE NEGATE R0,R1
	INV  R1
	INC  R1
	JNC  SUB20A
	INC  R0
SUB20A	EQU  $
	A    R0,R5
	A    R1,R6
	JNC  SUB20B
	INC  R5
SUB20B	EQU  $
*				NEGATE R5 (ANY TYPE)
SUB21	EQU  $	
	NEG  R5
*
SUB22	EQU  $			OR WITH I*4 VARIABLE
	SOC  *R2+,R5
	SOC  *R2,R6
*
SUB23	EQU  $	
	XOR  *R2+,R5		XOR WITH I*4 VARIABLE
	XOR  *R2,R6
*
SUB24	EQU  $
	LI   R3,0		LOAD BASE REGISTER
	RORG $-2
*
SUB25	EQU  $			DIRECT BYTE INCREMENT
	LI   R0,>0100
	AB   R0,*R2
*
SUB26	EQU  $			DIRECT INTEGER INCREMENT
	INC  @0
	RORG $-2
*
SUB27	EQU  $			INDIRECT INTEGER INCREMENT
	INC  *R2
*
SUB28	EQU  $			CONSTANT BYTE/INTEGER AND
	ANDI R5,0
	RORG $-2
*
SUB29	EQU  $			DIRECT BYTE AND
	MOVB *R2,R2
	INV  R2
	SZCB R2,R5
*
SUB30	EQU  $			DIRECT WORD AND
	MOV  *R2,R2
	INV  R2		   
	SZC  R2,R5
*
SUB31	EQU  $			ADD OF BYTE CONSTANT
	AB   R2,R5
*
SUB32	EQU  $			ADD OF BYTE DIRECT
	AB   @0,R5
	RORG $-2
*
SUB33	EQU  $			ADD OF BYTE INDIRECT
	AB   *R2,R5
*
SUB34	EQU  $			ADD OF INTEGER CONSTANT
	AI   R5,0
	RORG $-2
*
SUB35	EQU  $			ADD OF INTEGER DIRECT
	A    @0,R5
	RORG $-2
*
SUB36	EQU  $			ADD OF INTEGER INDIRECT
	A    *R2,R5
*
SUB37	EQU  $			LOAD OF CONSTANT
	LI   R5,0
	RORG $-2
*
SUB38	EQU  $			LOAD OF DIRECT BYTE
	MOVB @0,R5
	RORG $-2
*
SUB39	EQU  $			LOAD OF DIRECT WORD
	MOV  @0,R5
	RORG $-2
*
SUB40	EQU  $			MOVE OF INDIRECT BYTE
	MOVB *R2,R5
*
SUB41	EQU  $			MOVE OF INDIRECT WORD
	MOV  *R2,R5
*
SUB42	EQU  $			STORE BYTE DIRECT
	MOVB R5,@0		DSTORE		(DIRECT ARG)
	RORG $-2
*
SUB43	EQU  $			STORE BYTE INDIRECT
	MOVB R5,*R2
*
SUB44	EQU  $			STORE INTEGER DIRECT
	MOV  R5,@0
	RORG $-2
*
SUB45	EQU  $			STORE INTEGER INDIRECT
	MOV  R5,*R2
*
SUB46	EQU  $			COMPARE BYTE (CONSTANT)
	CB   R5,R2
*
SUB47	EQU  $			COMPARE BYTE (DIRECT)
	CB   R5,@0
	RORG $-2
*
SUB48	EQU  $			COMPARE BYTE (INDIRECT)
	CB   R5,*R2
*
SUB49	EQU  $			COMPARE INTEGER (CONSTANT)
	CI   R5,0
	RORG $-2
*
SUB50	EQU  $
	C    R5,@0		COMPARE WORD    (DIRECT)
	RORG $-2
*
SUB50A	EQU  $
	C    R5,*R2		COMPARE WORD    (INDIRECT)
*
*
SUB51	EQU  $			DIVIDE BYTE CONSTANT
	IF   TMS9995
	SRA  R5,8		CONVERT EVERYTHING TO WORDS
	SRA  R2,8
	MOV  R5,R1
	SRA  R5,15
	MOV  R5,R0
	DIVS R2
	MOV  R0,R5
	SLA  R5,8		BACK TO BYTE
	ELSE
	SRA  R5,8
	SRA  R2,8		CONVERT EVERYTHING TO WORDS
	MOVB R5,R1
	XOR  R2,R1
	ABS  R2
	ABS  R5
	MOV  R5,R6
	CLR  R5
	DIV  R2,R5
	ANDI R2,>8000
	JEQ  BSDIV1
	NEG  R5
BSDIV1	EQU  $
	SLA  R5,8		BACK TO BYTE
	ENDIF
*
SUB52	EQU  $			BYTE DIVIDE (DIRECT/INDIRECT)
	IF   TMS9995
	MOVB *R2,R2
	SRA  R5,8
	SRA  R2,8
	MOV  R5,R1		SAVE RESULTING SIGN
	SRA  R5,15
	MOV  R5,R0
	DIVS R2
	MOV  R0,R5
	SLA  R5,8
	ELSE
	MOVB *R2,R2
	SRA  R5,8		CONVERT BYTE ARGUMENTS TO WORD
	SRA  R2,8
	MOV  R5,R1
	XOR  R2,R1		R1 HAS RESULTING SIGN
	ABS  R2			CONVERT BOTH ARGUMENTS TO ABSOLUTE
	ABS  R5
	MOV  R5,R6
	CLR  R5
	DIV  R2,R5		DO DIVIDE
	ANDI R1,>8000		GET SIGN OF RESULT
	JEQ  BSDIV2		BRIF POSITIVE
	NEG  R5			ELSE, NEGATE RESULT
BSDIV2	EQU  $
	SLA  R5,8		FORM BYTE BACK
	ENDIF
*
SUB53	EQU  $			INTEGER CONSTANT DIVIDE
	IF   TMS9995
	MOV  R5,R1
	SRA  R5,15
	MOV  R5,R0
	DIVS R2
	MOV  R0,R5
	ELSE
	MOV  R5,R1
	XOR  R2,R1
	ABS  R2
	ABS  R5
	MOV  R5,R6
	CLR  R5
	DIV  R2,R5
	ANDI R1,>8000
	JEQ  BSDIV3
	NEG  R5
BSDIV3	EQU  $
	ENDIF
*
SUB54	EQU  $			INTEGER DIVIDE (DIRECT/INDIRECT)
	IF   TMS9995
	MOV  *R2,R2
	MOV  R5,R1
	SRA  R5,15
	MOV  R5,R0
	DIVS R2
	MOV  R0,R5
	ELSE
	MOV  *R2,R2
	MOV  R5,R1
	XOR  R2,R1
	ABS  R2
	ABS  R5
	MOV  R5,R6
	CLR  R5
	DIV  R2,R5
	ANDI R2,>8000
	JEQ  BSDIV4
	NEG  R5
BSDIV4	EQU  $
	ENDIF
*
SUB55	EQU  $			MULTIPLY (CONSTANT)
	MPY  R2,R5
	MOVB R6,R5
*
SUB56	EQU  $			MULTIPLY (DIRECT, INDIRECT)
	MPY  *R2,R5
	MOVB R6,R5
*
SUB57	EQU  $			MULTIPLY (INTEGER CONSTANT)
	MPY  R2,R5
	MOV  R6,R5
*
*  (SUB58 UNUSED)
*
SUB59   EQU  $			MULTIPLY (DIRECT, INDIRECT)
	MPY  *R2,R5
	MOV  R6,R5
*
SUB60	EQU  $			SUBTRACT OF BYTE CONSTANT
	SB   R2,R5
*
SUB61	EQU  $			SUBTRACT OF BYTE DIRECT
	SB   @0,R5
	RORG $-2
*
SUB62	EQU  $			SUBTRACT OF BYTE INDIRECT
	SB   *R2,R5
*
SUB63	EQU  $
	S    R2,R5		SUBTRACT OF INTEGER CONSTANT
*
SUB64	EQU  $			SUBTRACT OF INTEGER DIRECT
	S    @0,R5
	RORG $-2
*
SUB65	EQU  $			SUBTRACT OF INTEGER INDIRECT
	S    *R2,R5
*
SUB66	EQU  $
	ORI  R5,0		OR (CONSTANT)
	RORG $-2
*
SUB67	EQU  $
	SOCB @0,R5		SOCB @X,R5	(DIRECT ARG)
	RORG $-2
*
SUB68	EQU  $
	SOCB *R2,R5		 (OR IT IN)
*
SUB69	EQU  $			OR (DIRECT)
	SOC  @0,R5
	RORG $-2
*
SUB70	EQU  $			OR (INDIRECT)
	SOC  *R2,R5
*
SUB71	EQU  $
	XOR  R2,R5
*		
SUB72	EQU  $
	XOR  *R2,R5
*
SUB73	EQU  $
	INCT @0
	RORG $-2
*
SUB74	EQU  $
	INCT *R2
*
SUB75	EQU  $
	DEC  @0
	RORG $-2
*
SUB76	EQU  $
	DEC  *R2
*
SUB77	EQU  $
	DECT @0
	RORG $-2
*
SUB78	EQU  $
	DECT *R2
*
SUB79	EQU  $			NEGATE INTEGER *4
	INV  R5
	INV  R6
	INC  R6
	JNC  SUB79A
	INC  R5
SUB79A	EQU  $
*
SUB80	EQU  $			CLEAR OF A WORD
	CLR  @0
	RORG $-2
*
SUB81	EQU  $			CLEAR OF AN INDIRECT WORD
	CLR  *R2
*
SUB82	EQU  $			CLEAR OF A LONGWORD
	CLR  *R2+
	CLR  *R2
*
SUB83	EQU  $			SET A WORD TO -1
	SETO @0
	RORG $-2
*
SUB84	EQU  $			SET A WORD TO -1 (INDIRECT)
	SETO *R2
*
SUB85	EQU  $			SET A LONGWORD TO -1
	SETO *R2+
	SETO *R2
*
SUB86	EQU  $			MOVE A BYTE
	MOVB @0,@0
	RORG $-4
*
SUB87	EQU  $			MOVE A WORD
	MOV  @0,@0
	RORG $-4
*
ENDIT	EQU  $
	END
