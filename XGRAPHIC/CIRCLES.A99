	TITL  'CIRCLE DRAWING ALOGORITHM'
	IDT   'CIRCLE'
*
*  CIRCLE : DRAW A CIRCLE ON THE SCREEN FROM 9640 FORTRAN
*
*  Calling Sequence:
*                            4         6       8          10           12
*	CALL CIRCLE ( CENTER X, CENTER Y, RADIUS, FORE COLOR [,BACK COLOR] )
*
*  Where:
*
*	CENTER X : is a one word integer variable which is the
*		   x pixel coordinate,
*	CENTER Y : is a one word integer variable which is the
*		   y pixel coordinate,
*	RADIUS   : is a one word integer variable which is the
*		   radius of the circle in pixels
*	COLOR    : is a one word integer variable which is the
*		   color code to make the circle.
*
*  Original source by J. Syzdek, modified by Al Beard for 9640 FORTRAN
*
*  Update History:
*
*     24-Apr-1989            Initial Version
*      4-Feb-1990            GPL Compatible Version
*     18-MAR-1990            Fix color byte logic in GPL
*
************************************************************
*
* Bresenham's Circle Algorithm
* Programmed by J. Syzdek
*
************************************************************
*
	DEF   CIRCLE		CIRCLE ROUTINE
*
*  Equates:
*
	COPY "FORTPAR:"
	UNL
	COPY "EQUATES:VID.EQ9"
	COPY "EQUATES:FORTEX.EQ9"
	LIST
*
CIRCLE	EQU  $
	DATA -5			5 ARGUMENTS
	DATA BASEAD		BASE ADDRESS
*
	LI   R1,BASEAD+4	GET ALL ARGUMENTS
	MOV  *R1+,R6		GET CENTER X
	JEQ  BADXAR
	MOV  *R6,R6
	JLT  BADXAR
	CI   R6,511		>MAX SCREEN?
	JGT  BADXAR
*
	MOV  *R1+,R7		GET CENTER Y
	JEQ  BADYAR
	MOV  *R7,R7
	JLT  BADYAR
	CI   R7,1023
	JGT  BADYAR
*
	MOV  *R1+,R9		GET RADIUS
	JEQ  BADRAD
	MOV  *R9,R9
	JLT  BADRAD
	CI   R9,511
	JGT  BADRAD
*
	IF   GENEVE
	MOV  *R1,R3		GET COLOR
	JEQ  BADCOL
	MOV  *R3,R3
	JLT  BADCOL
	CI   R3,255
	JGT  BADCOL
	SWPB R3			IN HIGH BYTE
	ELSE
	MOV  *R1+,R3		GET FOREGROUND COLOR
	JEQ  NOCOLO		BRIF NONE SPECIFIED
	MOV  *R3,R3		GET COLOR
	DEC  R3
	ANDI R3,>F
	SLA  R3,4
	MOV  *R1+,R5		GET BACKGROUND COLOR
	JEQ  NOCOLO
	DEC  R5
	ANDI R5,>F
	SOC  R5,R3		OR WITH FOREGROUND COLOR
NOCOLO	EQU  $
	SLA  R3,8		PUT IN HIGH BYTE
*
	MOV  @SET40F,R0		GET CURRENT SCREEN MODE
	CI   R0,GRAPH2		GRAPHICS 2 MODE? (BITMAP)
	JNE  BADMOD		BRIF NO, BAD MODE
	ENDIF
*
	CLR  R4
	MOV  R9,R5             	Y=RADIUS
*
*				P=3-(2*RAD)
	SLA  R9,1
	LI   R8,>3
	S    R9,R8
PLOTP	BL   @PLOT
*
	MOV  R8,R8
	JGT  CALCP
*
	MOV  R4,R9		IF P<0 THEN P=P+(4*X)+6
	SLA  R9,2
	LI   R12,6
	A    R9,R12
	A    R12,R8
	JMP  INX
*
CALCP	MOV  R4,R9		P=P+(4*(X-Y))+10
	S    R5,R9
	SLA  R9,2
	LI   R12,10
	A    R9,R12
	A    R12,R8
*
	DEC  R5
INX	INC  R4
	C    R4,R5
	JEQ  PLEQ
	JMP  CHKLS
PLEQ	BL   @PLOT
	C    R4,R5
CHKLS	JLT  PLOTP
	JMP  EXCIR
*
*  ERROR RETURNS
*
BADXAR	EQU  $
	BLWP *R10
	DATA ERROR
	TEXT 'XC'		BAD X COORDINATE
	JMP  EXCIR
*
BADYAR	EQU  $
	BLWP *R10
	DATA ERROR
	TEXT 'YC'		BAD Y COORDINATE
	JMP  EXCIR
*
BADRAD	EQU  $
	BLWP *R10
	DATA ERROR
	TEXT 'BR'		BAD RADIUS
	JMP  EXCIR
*
BADCOL	EQU  $
	BLWP *R10
	DATA ERROR
	TEXT 'CL'		BAD COLOR
	JMP  EXCIR
*
BADMOD	EQU  $
	BLWP *R10
	DATA ERROR
	TEXT 'BM'		BAD MODE
	JMP  EXCIR
*
EXCIR	EQU  $
	MOV  @BASEAD,R3		RESTORE BASE
	MOV  @BASEAD+2,R11	RESTORE RETURN VECTOR
	B    *R11		RETURN
*
*  PLOT : CALLED TO PLOT A POINT
*
PLOT	EQU  $
	MOV  R11,R12		SAVE RETURN
	MOV  R6,R1
	A    R4,R1		XP=XC+X
	JLT  NEXT
	MOV  R7,R2
	A    R5,R2		YP=YC+Y
	JLT  NEXT1
	C    R1,@HLIM
	JGT  NEXT
	C    R2,@VLIM
	JGT  NEXT1
	BL   @POINT
*
NEXT	MOV  R6,R1
	S    R4,R1		XP=XC-X
	JLT  NEXT1
	C    R1,@HLIM
	JGT  NEXT1
	C    R2,@VLIM
	JGT  NEXT1
	BL   @POINT
*
NEXT1	MOV  R6,R1
	A    R4,R1		XP=XC+X
	JLT  NEXT2
	MOV  R7,R2
	S    R5,R2		YP=YC-Y
	JLT  NEXT3
	C    R1,@HLIM
	JGT  NEXT2
	C    R2,@VLIM
	JGT  NEXT2
	BL   @POINT
*
NEXT2	MOV  R6,R1
	S    R4,R1		XP=XC-X
	JLT  NEXT3
	C    R1,@HLIM
	JGT  NEXT3
	C    R2,@VLIM
	JGT  NEXT3
	BL   @POINT
*
NEXT3	MOV  R6,R1
	A    R5,R1		XP=XC+Y
	JLT  NEXT4
	MOV  R7,R2
	A    R4,R2		YP=YC+X
	JLT  NEXT4
	C    R1,@HLIM
	JGT  NEXT4
	C    R2,@VLIM
	JGT  NEXT4
	BL   @POINT
*
NEXT4	MOV  R6,R1
	S    R5,R1		XP=XC-Y
	JLT  NEXT5
	MOV  R7,R2
	A    R4,R2		YP=YC+X
	JLT  NEXT5
	C    R1,@HLIM
	JGT  NEXT5
	C    R2,@VLIM
	JGT  NEXT5
	BL   @POINT
*
NEXT5	MOV  R6,R1
	A    R5,R1		XP=XC+Y
	JLT  NEXT6
	MOV  R7,R2
	S    R4,R2		YP=YC-X
	JLT  DONE
	C    R1,@HLIM
	JGT  NEXT6
	C    R2,@VLIM
	JGT  NEXT6
	BL   @POINT
*
NEXT6	MOV  R6,R1
	S    R5,R1		XP=XC-Y
	JLT  DONE
	C    R1,@HLIM
	JGT  DONE
	C    R2,@VLIM
	JGT  DONE
	BL   @POINT
*
DONE	B    *R12
*
*  POINT : PLOTS A POINT ON THE SCREEN
*
*          R1  -  HAS X COORDINATE OF PIXEL
*          R2  -  HAS Y COORDINATE OF PIXEL
*          R3  -  HAS COLOR
*
POINT	EQU  $
	UNL
	IF   GENEVE
	LIST
	LI   R0,SETPIC		SETPIXEL
	XOP  @DVIDXP,0		PLOT A POINT
	B    *R11
	UNL
	ELSE
	LIST
	MOV  R1,@SAVER1
	MOV  R2,@SAVER2
	MOV  R4,@SAVER4
	MOV  R5,@SAVER5
	MOV  R6,@SAVER6
*
	MOV  R1,R0		SET X REG
	MOV  R2,R1		SET Y REG
	MOV  R1,R4
	SLA  R4,5
	SOC  R1,R4
	ANDI R4,>FF07
	MOV  R0,R5		R0 IS X VALUE
	ANDI R5,7
	A    R0,R4		R4 IS THE BYTE OFFSET
	S    R5,R4		R5 IS THE BIT OFFSET
*
	MOV  @TABADD,R6		GET TABLE ADDRESS
	MOV  @6(R6),R0		GET PATTERN TABLE START ADDRESS
	A    R4,R0		 + BYTE OFFSET
	LIMI 0			DISABLE INTERRUPTS
	SWPB R0
	MOVB R0,@VDPWA
	SWPB R0
	MOVB R0,@VDPWA
	NOP
	MOVB @VDPRD,R1		GET PATTERN BYTE
*
	SOCB @BYTES(R5),R1	SET THE BIT I NEED
	ORI  R0,>4000		SET WRITE BIT
*
	SWPB R0
	MOVB R0,@VDPWA
	SWPB R0
	MOVB R0,@VDPWA
	NOP
	MOVB R1,@VDPWD
*
	MOV  @BASEAD+10,R5	GET FOREGROUND COLOR ADDRESS
	JEQ  SKIPCO		BRIF NOT SPECIFIED, SKIP IT
*
	MOV  *R5,R5		GET FOREGROUND COLOR
	DEC  R5
	SLA  R5,12
*
	ANDI R0,>3FFF		MASK MY ADDRESS
	AI   R0,>2000		+ OFFSET TO COLOR TABLE
*
	MOV  @BASEAD+12,R3	GET BACKGROUND COLOR
	JEQ  NOBACK		BRIF NONE
*
	MOV  *R3,R3		ELSE, GET BACKGROUND COLOR
	DEC  R3
	ANDI R3,>F		MAKE SURE A NIBBLE
	SLA  R3,8
	SOC  R3,R5		OR WITH FOREGROUND
	MOV  R5,R1
	BLWP @CVSBW$		WRITE IT
	JMP  SKIPCO
*
NOBACK	EQU  $
	BLWP @CVSBR$		READ THE BYTE
	ANDI R1,>0F00		MASK MY OLD COLOR
	SOC  R5,R1		OR IN FOREGROUND
	BLWP @CVSBW$		WRITE IT
*
SKIPCO	EQU  $
	MOV  @SAVER1,R1
	MOV  @SAVER2,R2
	MOV  @SAVER4,R4
	MOV  @SAVER5,R5
	MOV  @SAVER6,R6
	LIMI 2
	B    *R11		RETURN
BYTES	EQU  $
	BYTE >80,>40,>20,>10,>08,>04,>02,>01
SAVER1	BSS  2
SAVER2	BSS  2
SAVER4	BSS  2
SAVER5	BSS  2
SAVER6	BSS  2
	ENDIF
	LIST
*
HLIM	DATA 1023		SCREEN BOUNDRY LIMITS
VLIM	DATA 511
*
	IF   GENEVE
DVIDXP	DATA VIDXOP
	ENDIF
*
BASEAD	EQU  $
	BSS  14			14 BYTES (2 TEMPS, + 5 ARGS, * 2)
	END
