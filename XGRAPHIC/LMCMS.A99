	TITL  'LMCM - High Speed Move of VDP/CPU Ram'
	IDT   'LMCM'
*
*  LMCM : Logical Move of VRAM to CPU Ram
*  LMMC : Logical Move of CPU Ram to VRAM
*
*  This routine is called from 9640 FORTRAN, and performs a logical move
*  of memory from VRAM to CPU Ram, and vice/versa.
*
*  Calling Sequence;
*
*    CALL LMCM ( x_coord, y_coord, dots_x, dots_y, direc_x, direc_y,
*                array, bytes_xfered )
*    CALL LMMC ( x_coord, y_coord, dots_x, dots_y, direc_x, direc_y,
*                array, bytes_xfered [, logic] )
*  where:
*
*	x_coord :  is a one word integer variable which specifies the
*		   starting pixel coordinate, from 0 to 511,
*	y_coord :  is a one word integer variable which specifies the
*		   starting pixel coordinate, from 0 to 1023,
*	dots_x  :  is a one word integer variable which is a value from
*		   0 to 511, and is the # of pixels in the x direction
*		   comprising the window,
*	dots_y  :  is a one word integer variable which is a value from
*		   0 to 1023, and is the # of pixels in the y direction
*		   comprising the window,
*	direc_x :  is a one word integer variable, and is set to 0 for
*		   transfer in the right direction, and 1 for transfer
*		   in the left direction,
*	direc_y :  is a one word integer variable, and is set to 0 for
*		   transfers in the down direction, and 1 for transfers
*		   in the up direction,
*	array   :  is a FORTRAN array that will contain the pixel values, and
*	bytes_  :  is a one word integer variable which will contain the
*	xferred    the number of bytes of data actually transferred.
*       logic   :  is a one word integer variable which is the logic
*		   operation to perform (0, just copy) (optional)
*
*  Copyright 1989 by LGMA Products
*
*  The array is packed according to the following:
*
*              graphics mode 4,6  :  two pixels/byte
*              graphics mode 5:      four pixels/byte
*              graphics mode 7:      one pixel/byte
*
*  This offers the greatest storage compaction for each graphics mode
*  (with an expense of speed).
*
*  Update History:
*
*    24-Apr-1989             Initial Release
*
	DEF  LMCM
	DEF  LMMC
*
*  Equates:
*
	COPY "FORTPAR:"
	UNL
	copy "equates:vid.eq9"
	copy "equates:fortex.eq9"
	LIST
*
LMMC	EQU  $
	DATA -9			NINE ARGUMENTS
	DATA BASEAD
	MOV  @BASEAD+20,R0	GET LOGIC OPERATION ARGUMENT
	JEQ  NOLOGI		BRIF NONE
	MOV  *R0,R0		GET ARGUMENT
NOLOGI	EQU  $
	ANDI R0,>F		MASK OPERATION
	SWPB R0
	AI   R0,>B000		COMMAND CODE FOR LMMC
	LI   R12,ARLMMC		ARGUMENT TABLE
	JMP  LMCMCO
*
LMCM	EQU  $
	DATA -8			EIGHT ARGUMENTS
	DATA BASEAD
	LI   R0,>A000		COMMAND CODE FOR LMCM
	LI   R12,ARLMCM		ARGUMENT TABLE
*
LMCMCO	EQU  $
	MOVB R0,@COMMAN 	SAVE COMMAND CODE
*
	LI   R0,GETVID
	XOP  @DVIDXP,0		GET CURRENT VIDEO MODE
	CI   R0,GRAPH4		IS IT LESS THAN GRAPHICS MODE 4?
	JLT  BADMOD		BRIF YES, BAD VIDEO MODE
	CLR  R8			USE 1 PIXEL/BYTE (0)
	CI   R0,GRAPH7		GRAPHICS MODE 7?
	JEQ  CHKNCO
	SETO R8			USE 4 PIXELS/BYTE (-1)
	CI   R0,GRAPH5		GRAPHICS MODE 5?
	JEQ  CHKNCO		BRIF YES
	ABS  R8			USE 2 PIXELS/BYTE (1)
*
CHKNCO	EQU  $
	LI   R3,BASEAD+4	STARTING ARGUMENT ADDRESS
	LI   R4,4		4 ARGUMENTS TO PARSE
	LIMI 0			DISABLE INTERRUPTS
*
ARGLOP	EQU  $
	MOV  *R12+,R6		GET HIGH ACCEPTABLE VALUE
	MOV  *R12+,R7		GET VECTOR ADDRESS
	MOV  *R12+,R1		GET REGISTER NUMBER TO USE
	MOV  *R3+,R2		GET ARGUMENT ADDRESS
	JEQ  BRABAD		BRIF NO ARGUMENT SPECIFIED, ERROR
	MOV  *R2+,R2		GET ACTUAL VALUE TO TRANSFER
	JLT  BRABAD
	C    R2,R6		IS VALUE GREATER THAN MAX?
	JGT  BRABAD
	LI   R0,VVWTR		WRITE VIDEO REGISTERS
	XOP  @DVIDXP,0		DO IT
*
	INC  R1			WRITE NEXT REGISTER ALSO
	SWPB R2
	XOP  @DVIDXP,0
	DEC  R4
	JNE  ARGLOP		DO MORE
*
*  REGISTERS 32,33,34,35,40,41,42 AND 43 HAVE BEEN SET.  NOW SET
*  THE DIRECTION POINTER (X,Y DIRECTION)
*
	MOV  *R12+,R7		GET ERROR VECTOR
	MOV  *R12+,R1		GET REGISTER NUMBER
	MOV  *R3+,R2		GET VALUE TO SET IN REGISTER
	JEQ  BRABAD		BRIF NONE SPECIFIED (ERROR)
	MOV  *R2,R2		GET VALUE
	JLT  BRABAD		BRIF BAD VALUE (NEGATIVE)
	CI   R2,1
	JGT  BRABAD		MUST BE 0 OR 1
*
	SLA  R2,2		PUT IN PROPER BIT POSITION
	MOV  *R12+,R7		GET Y DIRECTION ERROR
	MOV  *R3+,R4
	JEQ  BRABAD		BRIF NOTHING SPECIFIED (ERROR)
	MOV  *R4,R4
	JLT  BRABAD		MUST BE 0 OR 1
	CI   R4,1
	JGT  BRABAD
	SLA  R4,3		SET Y DIRECTION
	SOC  R4,R2		"OR" IN VALUE
	LI   R0,VVWTR
	XOP  @DVIDXP,0		DO IT
*
*  GET THE ARRAY POINTER ARGUMENT
*
	MOV  *R12+,R7		GET ERROR CODE FOR BAD ARRAY POINTER
	MOV  *R3+,R4		GET THE ARRAY
	JEQ  BRABAD
*
*  GET THE COMMAND CODE.  IF IT IS COMMAND >A000 (WHICH IS LMCM), THEN
*  SET THE COMMAND REGISTER AND INITIATE POLLING LOOP.   IF IT IS COMMAND
*  >B000 (WHICH IS LMMC), THEN PLUG IN FIRST BYTE BEFORE EXECUTING COMMAND.
*
	MOV  @COMMAN,R2		GET COMMAND REGISTER CODE
	CI   R2,>A000		IS IT A LMCM COMMAND?
	JEQ  EXLMCM		BRIF YES
	B    @EXLMMC
*
BADMOD	EQU  $
	BLWP *R10		SET ERROR, BAD VIDEO MODE
	DATA ERROR
	TEXT 'BM'		(BAD MODE)
	JMP  SUDONE
*
BRABAD	EQU  $
	MOV  R7,@BRACEL		SET ERROR CODE CELL
	BLWP *R10
	DATA ERROR
BRACEL	DATA 0			WILL CONTAIN 2 CHAR ERROR CODE
	JMP  SUDONE
*
*  LMCM : SET THE COMMAND REGISTER, AND EXECUTE THE COMMAND
*
EXLMCM	EQU  $
	LI   R1,46		REGISTER 46
	LI   R2,>A0		LMCM COMMAND CODE
	LI   R0,VVWTR
	XOP  @DVIDXP,0		DO IT
	CLR  R6			R6 BYTES TRANSFERRED
	CLR  R9			R9 IS # PIXELS PROCESSED THIS BYTE
	CLR  R12		R12 CONTAINS THE CURRENT PIXEL SHIFTED
	LI   R1,VDPOR1		ADDRESS OF VDP REG 1
*
*  THINGS SHOULD BE IN FULL SWING.   POLL STATUS REGISTER #2 LOOKING FOR
*  TR READY TO SAY I SHOULD PULL A BYTE AND STUFF IT IN MY ARRAY.
*
*  NOTE: DIRECT 9938 CHIP REGISTER ACCESS INSTEAD OF XOPS USED FOR SPEED.
*
POLLOP	EQU  $
	LI   R0,>0200		STORE STATUS REGISTER POINTER 15=2
	MOVB R0,*R1
	LI   R0,>80+15*256
	MOVB R0,*R1
*
	CLR  R5
	MOVB *R1,R5		GET STATUS REGISTER #2 VALUE
*
	JGT  CHKCME		NOT READY, SEE IF COMMAND FINISHED
	JEQ  CHKCME		NOT READY, SEE IF COMMAND FINISHED
*
	LI   R0,>0700		SET STATUS REGISTER = 7
	MOVB R0,*R1
	LI   R0,>80+15*256
	MOVB R0,*R1
*
	CLR  R2
	MOVB *R1,R2		GET THE BYTE VALUE
*
*  THE PIXEL VALUE IS NOW SITTING IN THE HIGH BYTE OF R2.  SAVE IT
*  AWAY.
*
	BL   @STOPIX		STORE IT
*
*  EITHER THERE WAS NO BYTE TO TRANSMIT, OR I TRANSMITTED A BYTE.
*  CHECK THE STATUS REGISTER TO SEE IF COMMAND FINISHED
*
CHKCME	EQU  $
	ANDI R5,>0100		IS COMMAND END SET?
	JNE  POLLOP		BRIF YES, DO ANOTHER
*
*  END OF COMMAND.  MAKE SURE I FLUSH THE LAST PIXELS OUT OF THE BYTE
*  BUFFER, AND RETURN TO COMMON EXIT SEQUENCE.
*
CHKCM0	EQU  $
	MOV  R9,R9		ANY ODD BYTES HANGING?
	JEQ  CHKCM1		BRIF NO
	CLR  R2			CLEAR BYTE TO STORE
	BL   @STOPIX		STORE IT
	JMP  CHKCM0		TRY AGAIN
CHKCM1	B    @STOCNT
*
*  EXLMMC : EXECUTE A MOVE OF CPU TO VRAM.
*
EXLMMC	EQU  $
	LI   R1,VDPOR1		VDP REG 1 ADDRESS
	CLR  R6			R6 BYTES TRANSFERRED
	CLR  R9			R9 IS # PIXELS PROCESSED THIS BYTE
	CLR  R12		R12 CONTAINS THE CURRENT PIXEL SHIFTED
	BL   @LOAPIX		LOAD NEXT PIXEL
	MOVB R2,*R1		SET THE COMMAND CODE
	LI   R0,>80+46*256	 INTO VIDEO REGISTER 46
	MOVB R0,*R1
*
*  THE FOLLOWING LOOP READS THE STATUS REGISTER (#2) AND WAITS FOR THE
*  9938 CHIP TO TRANSMIT THE PIXEL.  WHEN EACH IS COMPLETE, THEN THE
*  NEXT BYTE IS LOADED AND TRANSMITTED.
*
LMMCPO	EQU  $
	LI   R0,>0200		STORE STATUS REGISTER POINTER 15=2
	MOVB R0,*R1
	LI   R0,>80+15*256
	MOVB R0,*R1
*
	CLR  R5
	MOVB *R1,R5		GET STATUS REGISTER #2 VALUE
	MOVB R5,R0
	ANDI R0,>0100		IS COMMAND STILL EXECUTING?
	JEQ  STOCNT		BRIF NO, COMMAND HAS TERMINATED
	MOVB R5,R5		IS TRANSMIT READY?
	JGT  LMMCPO		BRIF NO
	JEQ  LMMCPO		BRIF NO
*
*  9938 CHIP HAS SENT THE PIXEL TO VRAM.  LOAD THE NEXT PIXEL TO SEND
*
	BL   @LOAPIX		LOAD ANOTHER PIXEL
	JMP  LMMCPO		AND WAIT SOME MORE
*
*  DONE WITH THE COMMAND.  SAVE THE NUMBER OF BYTES TRANSFERRED FOR THE
*  CALLER.
*
STOCNT	EQU  $
	MOV  *R3,R3		GET ADDRESS OF BYTES_XFERRED CELL
	JEQ  SUDONE		BRIF USER DOESN'T CARE
	MOV  R6,*R3
*
SUDONE	EQU  $
	LIMI 2			RESTORE INTERRUPTS
	MOV  @BASEAD,R3		RESTORE R3
	MOV  @BASEAD+2,R11	RESTORE R11
	B    *R11
*
*  STOPIX : STORE A PIXEL AWAY ACCORDING TO THE SCREEN MODE.
*
STOPIX	EQU  $
	MOV  R8,R8		IS THIS A BYTE ALIGNED PIXEL?
	JNE  STOPI1		BRIF NO
	MOVB R2,*R4+		ELSE, SAVE BYTE
	INC  R6			INCR # OF BYTES PROCESSED
	B    *R11		& RETURN
*
STOPI1	EQU  $
	JLT  STOPI4		BRIF 4 PIXELS/BYTE
	MOV  R9,R9		2 PIXELS/BYTE
	JNE  STOPI2		BRIF ALREADY REMEMBERED A PIXEL
STOPI5	EQU  $
	MOV  R2,R12		SAVE THE PIXEL
	INC  R9
	B    *R11
STOPI2	EQU  $
	SLA  R12,4		SHIFT SAVED PIXEL
	SOCB R2,R12		OR IN NEW PIXEL
	MOVB R12,*R4+		SAVE IT
	INC  R6			INCR # OF BYTES PROCESSED
	CLR  R9			NO PIXELS WAITING
	B    *R11
*
STOPI4	EQU  $
	MOV  R9,R9		HAVE I ALREADY REMEMBERED A PIXEL?
	JEQ  STOPI5
	SLA  R12,2		SHIFT SAVED PIXEL
	SOC  R2,R12		SAVE NEW PIXEL
	INC  R9
	CI   R9,4		DID I SAVE ALL 4 PIXELS?
	JNE  STOPI6		BRIF NO, JUST RETURN
	MOVB R12,*R4+		ELSE, SAVE PIXELS
	INC  R6			INCR # OF BYTES PROCESSED
	CLR  R9
STOPI6	EQU  $
	B    *R11		RETURN
*
*  LOAPIX : LOAD A PIX FROM CPU RAM INTO VIDEO REGISTER #44 (COLOR REG)
*
LOAPIX	EQU  $
	MOV  R8,R8		IS THIS A BYTE ALIGNED PIXEL?
	JNE  LOAPI1		BRIF NO
	MOVB *R4+,*R1		STORE BYTE INTO VIDEO REGISTER
	INC  R6
	JMP  FINREG		FINISH REGISTER STORE
*
LOAPI1	EQU  $
	JLT  LOAPI4		BRIF 4 PIXELS/BYTE
	MOV  R9,R9		2 PIXELS/BYTE
	JNE  LOAPI2		BRIF ALREADY GOTTON A PIXEL
LOAPI5	EQU  $
	MOVB *R4,R12		GET A BYTE
	SRC  R12,4		ALIGN THE NIBBLE
	ANDI R12,>0F00		MASK IT
	MOVB R12,*R1
	INC  R9
	JMP  FINREG		GO STORE IT
*
LOAPI2	EQU  $
	MOVB *R4+,R12		GET A BYTE
	INC  R6			INCREMENT BYTE COUNT
	ANDI R12,>0F00		MASK THE NIBBLE
	MOVB R12,*R1		STORE IT
	CLR  R9
	JMP  FINREG		GO STORE IT
*
LOAPI4	EQU  $			2-BIT ONLY PIXEL
	MOV  R9,R9		NEW BYTE?
	JNE  NOTFIR
	MOVB *R4+,R12		GET NEXT BYTE TO STORE
	INC  R6
*
NOTFIR	EQU  $
	SRC  R12,16-2		GET NEXT 2-BIT CHUNK
	MOV  R12,R0
	SWPB R0
	ANDI R0,>0300		MASK IT
	MOVB R0,*R1		AND SAVE IT
	INC  R9			INCR # OF CHUNKS PROCESSED
	CI   R9,4		HAVE I PROCESSED 4?
	JNE  FINREG
	CLR  R9
FINREG	EQU  $
	LI   R0,>80+44*256	SET VIDEO REGISTER #
	MOVB R0,*R1
	B    *R11
*
*  ARGTBL : TABLE OF ALLOWABLE VALUES, ERROR TEXT IF NOT IN RANGE,
*	    AND 9938 REGISTER # ARG GOES TO.
*
*           THERE ARE TWO TABLES, BECAUSE THE 9938 CHIP HAS DIFFERENT
*	    REGISTERS FOR THE SOURCE AND DESTINATION POINTS.
*
ARLMCM	EQU  $
	DATA 511,'XC',32	X-COORDINATE
	DATA 1023,'YC',34	Y-COORDINATE
	DATA 511,'DX',40	# DOTS X
	DATA 1023,'DY',42	# DOTS Y
	DATA 'XD',45		X DIRECTION
	DATA 'YD'		Y DIRECTION
	DATA 'BR'		ARRAY
*
ARLMMC	EQU  $
	DATA 511,'XC',36	X-COORDINATE
	DATA 1023,'YC',38	Y-COORDINATE
	DATA 511,'DX',40	# DOTS X
	DATA 1023,'DY',42	# DOTS Y
	DATA 'XD',45		X DIRECTION
	DATA 'YD'		Y DIRECTION
	DATA 'BR'		ARRAY
*
DVIDXP	DATA VIDXOP		VIDEO XOP NUMBER
*
BASEAD	EQU  $
	BSS  22			4 BYTES TEMP + 18 BYTES ARG
COMMAN	DATA 0			COMMAND CODE (HIGH BYTE)
	END
