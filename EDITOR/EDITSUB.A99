	TITL 'EDITOR3 - PACK/UNPACK STRING'
	IDT  'PACK'
*
*   EDITSUB - Editor Assembly Language Subroutines
*
*   Support subroutines for the 99 FORTRAN editor, written in assembly
*   language for speed or size savings.
*
*   Update History:
*
*   v3.0:   June 07, 1987:  	Updated version number displayed.
*				Changed location of INTFLG.
*
*   V4.4     August 28, 1989: 	New GPL Version
*                               ENTABBED FILE (FOR CROSS-ASSEMBLER),
*				CHANGED MOVETO/MOVEFR TO ACCESS SUPER-
*				SPACE CARTRIDGE AREA.
*
*                               Allow 80-column mode.
*
GENEVE	EQU  0			TI-99 ONLY
	UNL
	COPY "EQUATES:FORTEX.EQ9"
	COPY "EQUATES:VID.EQ9"
	LIST
*
**************************
*			 *
*	PACK/UNPACK	 *
*	DISPSC		 *
*	MENURT		 *
*			 *
**************************
*
*  THIS SUBROUTINE PACKS AND UNPACKS STRINGS
*
*  CALLING SEQUENCE:
*
*	CALL PACK ( INPUT STRING, OUTPUT STRING )
*
*  OR
*
*	CALL UNPACK ( INPUT STRING, OUTPUT STRING )
*
	DEF  PACK
	DEF  UNPACK
*
PACK	EQU  $
	DATA -2			2 ARGUMENTS
	DATA TEMPS		TEMPORARY SAVE AREA
*
*  COMPUTE # OF BYTES IN INPUT ARRAY
*
	LI   R4,80
	MOV  @AARG1,R1		ADDRESS OF INPUT STRING
	MOV  @AARG2,R2		ADDRESS OF OUTPUT (COMPRESSED) STRING
	INCT R2			TEMP SKIP # WORDS HEADER
	CLR  R3			BLANK REPEAT COUNT
	CLR  R0
LOPPA1	EQU  $
	MOVB *R1+,R0
	JLT  NOTCHA		BRIF NOT A PRINTABLE CHAR
	CB   R0,@BLANK
	JGT  JUSTAC		IF LESS THAN >20, NOT A PRINTABLE CHAR
	JEQ  JUSTAC
NOTCHA	EQU  $			NOT A VALID CHARACTER
	MOVB @BLANK,R0		SUBSTITUTE A BLANK
JUSTAC	EQU  $
	CB   @BLANK,R0		CURRENT CHAR A BLANK ?
	JNE  JUSTCH		BRIF A CHARACTER
	INC  R3			ELSE, INC BLANK COUNT
	JMP  LOPDCH		AND TEST END OF LOOP
JUSTCH	EQU  $
	MOV  R3,R3	 	WAS I SAVING BLANKS?
	JEQ  SAVECH		BRIF NO
	AI   R3,>80		ELSE, SAVE BLANK REPEAT COUNT
	SWPB R3
	MOVB R3,*R2+		IN OUTPUT ARRAY
	CLR  R3
SAVECH	EQU  $
	MOVB R0,*R2+		SAVE NEW CHARACTER
LOPDCH	EQU  $
	DEC  R4			DONE ?
	JNE  LOPPA1		BRIF NO
	MOV  R3,R3	 	WAS A BLANK REPEAT IN PROGRESS ?
	JEQ  LOPDC1		BRIF NO
	AI   R3,>80
	SWPB R3
	MOVB R3,*R2+		YES, SAVE IT
LOPDC1	EQU  $
	INC  R2			COMPUTE WORD COUNT
	ANDI R2,>FFFE		TO GET EVEN BYTE ADDRESS
	MOV  @AARG2,R3
	S    R3,R2
	SRA  R2,1	  	BYTES TO WORDS
	MOV  R2,*R3		SAVE WORD COUNT
	JMP  PACDO2
*
*  UNPACK - UNPACK STRING
*
UNPACK	EQU  $
	DATA -2			2 ARGUMENTS
	DATA TEMPS
	MOV  @AARG1,R1
	MOV  *R1,R1		REPRESENT TRUE MEMORY OFFSET
	MOV  @AARG2,R2
	BL   @AUNPAC		UNPACK ARRAY
*
PACDO2	EQU  $
	MOV  @TEMPS,R3
	MOV  @TEMPS+2,R11
	B    *R11
	TITL 'SHIFT STRING ROUTINE'
*
**************************
*			 *
*	SHIFT		 *
*			 *
**************************
*
*  THIS ROUTINE SHIFTS A RECORD RIGHT OR LEFT IN RESPONSE
*  TO A INSERT CHARACTER OR DELETE CHARACTER REQUEST.
*
*  CALLING SEQUENCE:
*
*	CALL SHIFT ( RECORD, CURCHAR, DIRECTION )
*
*  WHERE:
*
*	RECORD	-  	IS AN 80 BYTE UNPACKED STRING OF NORMAL
*		   	ASCII CHARACTERS
*
*	CURCHAR   -  	IS THE POINTER INTO THE STRING, FROM 1 TO 80.
*
*	DIRECTION -  	IS  1 FOR INSERT CHARACTER
*		   	IS -1 FOR DELETE CHARACTER
*  DEFINITIONS:
*
	DEF  SHIFT
*
SHIFT	EQU  $
	DATA -3			3 ARGUMENTS
	DATA TEMPS	 	ADDRESS OF TEMPORARY SAVE AREA
	MOV  @AARG1,R1		GET RECORD START
	MOV  @AARG2,R2		GET OFFSET INTO RECORD
	MOV  *R2,R2
	DEC  R2			ZERO OFFSET
	A    R1,R2	 	DETERMINE START
	AI   R1,80	 	DETERMINE END
	MOV  R2,R4	 	NEXT CHARACTER OFFSET
	INC  R4			CURRENT POSITION + 1
	MOV  @AARG3,R5		GET DIRECTION
	MOV  *R5,R5
	JGT  SETSF1		BRIF INSERT
*
*  DELETE CHARACTER LOOP
*
SHFLOP EQU  $
	C    R4,R1	 	AT END ?
	JEQ  ENDBLA		BRIF YES, BLANK LAST CHAR
	MOVB *R4+,*R2+		MOVE A CHARACTER
	JMP  SHFLOP
*
*  INSERT CHARACTER LOOP
*
SETSF1	EQU  $
	MOV  R1,R4	 	END OF STRING
	DEC  R4			- 1
SHFLO1	EQU  $
	C    R1,R2	 	AT DESIRED CHARACTER ?
	JEQ  ENDBLA		BRIF YES
	MOVB *R4,*R1		ELSE, MOVE A CHARACTER
	DEC  R4			ADJUST POINTERS
	DEC  R1
	JMP  SHFLO1		AND GET NEXT CHARACTER
*
ENDBLA	EQU  $
	MOVB @BLANK,*R2  	BLANK LAST OR FIRST CHARACTER
	MOV  @TEMPS,R3		RESTORE BASE
	B    *R11	   	& RETURN
	TITL 'DISPLAY SCREEN SUBROUTINE'
*
**************************
*			 *
*	DISPSC		 *
*			 *
**************************
*
*  THIS SUBROUTINE IS CALLED BY THE EDITOR
*  TO DISPLAY A SCREEN OF TEXT INFORMATION.
*
*  CALLING SEQUENCE:
*
*   CALL DISPSC ( START, SCREEN, LINKS, OFFSET )
*
*  WHERE:
*
*   START  -  	IS THE STARTING LINE NUMBER TO DISPLAY
*
*   SCREEN -  	IS THE SCREEN OFFSET ( 1=SCREEN 1, 2 = SCREEN 2, 3=SCREEN 3 )
*
*   LINKS  -  	ARE THE CHAIN OF RECORDS
*
*   OFFSET -  	IS THE ARRAY CONTAINING THE MEMORY OFFSETS OF THE RECORDS.
*
*  DEFINITIONS:
*
	DEF  DISPSC
*
*  START
*
DISPSC	EQU  $
	DATA -6			6 ARGUMENTS
	DATA TEMPS	 	WORK AREA
	LIMI 0			INTERRUPTS OFF
	LI   R5,>4000		SET WRITE MODE
	SWPB R5
	MOVB R5,@VDPWA
	SWPB R5
	MOVB R5,@VDPWA
	MOV  @SET40F,R5		GET CURRENT SCREEN MODE
	CI   R5,TEXT2		80 COLUMN MODE?
	JNE  DISPS1		BRIF NO, USE MULTI-SCREEN
*
*  80 COLUMN MODE
*
	CLR  @SCRENO		STARTING OFFSET IS 0
	LI   R5,80
	MOV  R5,@NUMBYS		SET # OF BYTES PER LINE
	LI   R5,80*24
	MOV  R5,@ENDSCR		END OF SCREEN ADDRESS
	JMP  DISPS2
*
*  40 COLUMN MODE
*
DISPS1	EQU  $
	MOV  @ASCREE,R5   	SCREEN #
	MOV  *R5,R5		GET #
	DEC  R5			DETERMINE STARTING OFFSET
	MPY  @K20,R5		 INTO RECORD
	MOV  R6,@SCRENO
	LI   R5,40
	MOV  R5,@NUMBYS		NUMBER OF BYTES PER LINE
	LI   R5,40*24
	MOV  R5,@ENDSCR		END OF SCREEN ADDRESS
*
DISPS2	EQU  $
	MOV  @ASTART,R5   	STARTING RECORD #
	MOV  *R5,R5
	MOV  R5,@START
	CLR  R0			SCREEN OFFSET
	CLR  R6			END OF SCREEN FLAG
*
*  LOOP UNTIL SCREEN FULL
*
LOPSCR	EQU  $
	MOV  @START,R1		GET CURRENT RECORD #
	JEQ  FILLBL		NONE, FILL RECORD WITH BLANKS
	DEC  R1
	SLA  R1,1
	A    @AOFFSE,R1   	+ START OF OFFSET ARRAY
	MOV  *R1,R1		GET STARTING MEMORY OF RECORD
	JLT  JUSUNP		IF IN CPU RAM, JUST UNPACK
	CI   R1,>5FFF
	JGT  JUSUNP		BRIF IN MINI-MEMORY
*
	MOV  R0,R12		ELSE, SAVE SCREEN POSITION
	MOV  R1,R0	 	VDP RAM OFFSET
	INC  R0
	CLR  R1
	BLWP @CVSBR$		READ # WORDS
	MOV  R1,R2
	SWPB R2
	SLA  R2,1	  	CONVERT TO BYTES
	DEC  R0
	MOV  @APACBU,R1   	READ INTO PACK BUFFER
	BLWP @CVMBR$		READ RECORD
	MOV  R12,R0		RESTORE SCREEN OFFSET
	LI   R5,>4000		SET WRITE
	SOC  R0,R5
	SWPB R5
	MOVB R5,@VDPWA
	SWPB R5
	MOVB R5,@VDPWA
	MOV  @APACBU,R1   	FOR UNPACK ROUTINE
JUSUNP	EQU  $
	MOV  @ALINBU,R2
	BL   @AUNPAC		UNPACK THE STRING
	MOV  @ALINBU,R2
	A    @SCRENO,R2		LINE BUF + SCREEN OFFSET
	MOV  @NUMBYS,R4		GET # OF BYTES PER LINE
*
*  FILL CURRENT LINE WITH TEXT
*
LOPSC0	EQU  $
	MOVB *R2+,@VDPWD
	DEC  R4
	JNE  LOPSC0
	JMP  NXTREC
*
*  FILL CURRENT LINE WITH BLANKS
*
FILLBL	EQU  $
	MOV  R6,R6	 	DID I PROCESS EOF ?
	JEQ  FILLEO		BRIF NO
	MOV  @NUMBYS,R4		GET # OF BYTES PER LINE
LOPSC1	EQU  $
	MOVB @BLANK,@VDPWD
	DEC  R4
	JNE  LOPSC1
	JMP  NXTREC
*
*  FILL CURRENT LINE WITH <EOD> TEXT
*
FILLEO	EQU  $			MOVE RAM INTO VDP (32 BYTES)
	SETO R6			SET EOF WRITTEN FLAG
	LI   R3,EOFTXT
	LI   R4,19
LOPSC2	EQU  $
	MOVB *R3+,@VDPWD
	DEC  R4
	JNE  LOPSC2
	LI   R4,-19		CLEAR REST OF LINE
	A    @NUMBYS,R4		 + LENGTH OF A LINE
LOPSC3	EQU  $
	MOVB @BLANK,@VDPWD
	DEC  R4
	JNE  LOPSC3
	JMP  NXTREC
*
*  END OF RECORD, CHECK FOR NEXT
*
NXTREC EQU  $
	A    @NUMBYS,R0		INCREMENT SCREEN OFFSET
	C    @ENDSCR,R0		DONE?
	JEQ  JUSTEX		BRIF YES
*
	MOV  @START,R2		END OF RECORD CHAIN ?
	JEQ  LOPSCR		YES, JUST LOOP
	MOV  R2,R3	 	ELSE, GET NEXT IN CHAIN
	DEC  R3
	SLA  R3,1
	A    @ALINKS,R3		FROM LINKS
	MOV  *R3,@START
	JMP  LOPSCR
*
JUSTEX EQU  $
	LIMI 2			INTERRUPTS ON
	MOV  @TEMPS,R3
	MOV  @TEMPS+2,R11
	B    *R11	  	RETURN
	TITL 'ASSEMBLY UNPACK ROUTINE'
*
**************************
*			 *
*	AUNPAC		 *
*			 *
**************************
*
*  THIS SUBROUTINE IS CALLED BY UNPACK AND DISPSC TO UNPACK
*  A STRING INTO AN 80 BYTE ASCII ARRAY.
*
*  CALLING SEQUENCE:
*
*	LI   R1,INPUT_STRING
*	LI   R2,OUTPUT_STRING
*	BL   @AUNPAC
*
AUNPAC	EQU  $
	MOV  R0,R3	 	SAVE R0
	INCT R1			RAM OFFSET OF PACKET
	MOV  R1,R0	 	 INTO R0
	LI   R4,80	 	MAXIMUM RECORD LENGTH (EXPANDED)
	CLR  R1
LOPUN1	EQU  $
	MOV  R0,R0	 	GET RAM OFFSET
	JLT  CPURAM		BRIF >8000, CPU RAM
	CI   R0,>5FFF		IN MINI-MEMORY?
	JGT  CPURAM		BRIF YES
	BLWP @CVSBR$		ELSE, VDP RAM
	INC  R0
	JMP  GOTCOM
CPURAM	EQU  $
	MOVB *R0+,R1
GOTCOM	EQU  $
	MOV  R1,R1	 	CHARACTER IN R1
	JLT  EXPBLA		BRIF BLANK EXPANSION
	MOVB R1,*R2+		ELSE, JUST RESTORE CHARACTER
	DEC  R4
	JNE  LOPUN1		BRIF MORE TO PROCESS
	JMP  EXIAUN
EXPBLA	EQU  $			EXPAND BLANK CHARACTERS
	SWPB R1
	ANDI R1,>7F		GET REPEAT COUNT
EXPLOO	EQU  $
	MOVB @BLANK,*R2+  	EXPAND A BLANK
	DEC  R4			DECR CHARACTER COUNT
	JEQ  EXIAUN		BRIF DONE
	DEC  R1			DECR REPEAT COUNT
	JNE  EXPLOO		BRIF MORE
	JMP  LOPUN1		ELSE, MORE CHARACTERS TO PROCESS
EXIAUN	EQU  $
	MOV  R3,R0	 	RESTORE R0
	B    *R11
	TITL 'MOVE MEMORY ROUTINE'
*
**************************
*			 *
*	MOVEFR		 *
*	MOVETO		 *
*			 *
**************************
*
*  THIS ROUTINE MOVES MEMORY FROM THE USER PROGRAM
*  TO CPU OR VDP RAM VIA THE FOLLOWING ALGORITHM:
*
*  - IF THE RAM ADDRESS IS POSITIVE (<'8000'X), MEMORY IS MOVED
*    FROM/TO VDP RAM.
*
*  - IF THE RAM ADDRESS IS NEGATIVE (>'7FFF'X), MEMORY IS MOVED
*     FROM/TO CPU RAM.
*
*  IN THIS WAY, THE USER PROGRAM IS PROHIBITED FROM ACCESSING LOCATIONS
*  0000 TO 7FFF IN CPU MEMORY.
*
*  CALLING SEQUENCE:
*
*	CALL MOVEFR ( OFFSET, VARIABLE, # WORDS )
*	CALL MOVETO ( OFFSET, VARIABLE, # WORDS )
*
*  WHERE:
*
*	OFFSET   - IS THE VARIABLE NAME OR THE ARRAY NAME OF WHERE
*			 THE DATA IS TO BE MOVED FROM/TO
*
*	VARIABLE - IS THE STARTING ADDRESS IN CPU/VDP RAM WHERE THE
*			 DATA IS TO BE MOVED FROM/TO
*
*	# WORDS	- IS THE NUMBER OF WORDS TO BE MOVED
*
*  DEFINITONS:
*
	DEF  MOVEFR		MOVE FROM MEMORY
	DEF  MOVETO		MOVE TO MEMORY
*
MOVEFR	EQU  $
	DATA -3			3 ARGUMENTS
	DATA TEMPS	 	TEMPORARY STORAGE
	MOV  @ARAMAD,R1  	GET USER VARIABLE
	MOV  @ANOWRD,R2   	GET # WORDS TO MOVE
	MOV  *R2,R2
	SLA  R2,1	  	CONVERT TO BYTES
	MOV  @AVARAD,R0
	MOV  *R0,R0
	JLT  DOCPUR		BRIF CPU RAM
	CI   R0,>5FFF		IN MINI-MEMORY OR SUPERSPACE?
	JGT  DOCPUR		BRIF YES
	BLWP @CVMBR$		ELSE, JUST READ MEMORY
	JMP  MOVEDN
*
DOCPUR	EQU  $
	MOV  *R0+,*R1+		MOVE A WORD
	DECT R2
	JNE  DOCPUR		BRIF MORE
	JMP  MOVEDN
*
MOVETO	EQU  $
	DATA -3			3 ARGUMENTS
	DATA TEMPS	 	TEMPORARY STORAGE
	MOV  @ARAMAD,R1
	MOV  @ANOWRD,R2  	GET # WORDS TO MOVE
	MOV  *R2,R2
	SLA  R2,1
	MOV  @AVARAD,R0
	MOV  *R0,R0
	JLT  DOCPUW		BRIF WRITE TO CPU MEMORY
	CI   R0,>5FFF		IN MINI-MEMORY OR SUPERSPACE?
	JGT  DOCPUW		BRIF YES
*
	BLWP @CVMBW$	 	ELSE, VDP MEMORY WRITE
	JMP  MOVEDN
*
DOCPUW	EQU  $
	MOV  *R1+,*R0+
	DECT R2
	JNE  DOCPUW
*
MOVEDN EQU  $
	MOV  @TEMPS,R3		RESTORE RETURN VECTOR
	MOV  @TEMPS+2,R11
	B    *R11
	TITL 'GETKEY - WAIT FOR KEYBOARD'
*
**************************
*			 *
*	GETKEY		 *
*			 *
**************************
*
*  THIS SUBROUTINE IS PASSED THE CURRENT ROW/COLUMN, AND RETURNS
*  A KEY DEPRESSED.
*
*  CALLING SEQUENCE:
*
*	CALL GETKEY ( ROW, COLUMN, KEYCODE )
*
*
	DEF  GETKEY
*
GETKEY	EQU  $
	DATA -3			3 ARGUMENTS
	DATA TEMPS
	MOV  @SET40F,R5		GET SCREEN MODE
	CI   R5,TEXT2
	JNE  GETKE1
	LI   R5,80
	MOV  R5,@NUMBYS		SET 80 COLUMN MODE
	JMP  GETKE2
GETKE1	EQU  $
	LI   R5,40
	MOV  R5,@NUMBYS
GETKE2	EQU  $
	CLR  R1
	MOVB R1,@GPLSTA   	CLEAR GPL STATUS REGISTER
	LI   R1,>0500
	MOVB R1,@KEYUNT   	SET KEYBOARD #
	MOV  @NUMBYS,R0		40/80 COLUMN SCREEN
	MOV  @AROW,R1		GET ROW #
	MOV  *R1,R1
	DEC  R1
	MPY  R0,R1	 	* 40
	MOV  @ACOL,R1		+ COLUMN
	A    *R1,R2
	DEC  R2			- 1
	MOV  R2,R0	 	SET VDP SCREEN IMAGE ADDRESS
	BLWP @CVSBR$		GET CHAR AT ADDRESS
	MOV  R1,R5	  	 & SAVE
	LI   R6,30*256		BLOCK CURSOR CHAR NUMBER
	MOV  R6,R1	  	WRITE CURSOR FIRST
	BLWP @CVSBW$
RCOUNT	EQU  $
	MOV  @COUNDD,R4		GET MENU COUNTDOWN VALUE
KEYLOP	EQU  $
	BLWP @CKSCAN		SCAN THE KEYBOARD
	MOV  @GPLSTA,R1   	KEY DEPRESSED?
	ANDI R1,>2000
	JNE  KEYNEW		BRIF YES, EXIT
	CLR  R1
	MOVB @KEYFND,R1   	LOOK AT KEY IN UNIT #
	CI   R1,>FF00		WAS PREVIOUS KEY RELEASED?
	JEQ  KEYOLD		BRIF YES, NO KEY DEPRESSED
	MOV  @CLOCK2,R1   	SEE HOW LONG SINCE LAST KEY
	CI   R1,6	 	MUST BE AT LEAST 1 SECOND
	JGT  KEYREP
	MOV  @FIRREP,R1   	GET FIRST REPEAT FLAG
	MOV  R1,R1	 	IS IT SET?
	JEQ  KEYNON		BRIF NO, SKIP IT
	MOV  @CLOCK2,R1
	JGT  KEYREP
	JMP  KEYNON
KEYOLD	EQU  $
	CLR  @FIRREP		IF NO KEY DEPRESSED, THEN CLEAR FLAGS
	CLR  @CLOCK2		FOR REPEAT
KEYNON	EQU  $
	DEC  R4			ELSE, INCREMENT COUNTDOWN
	JNE  KEYLOP
	BLWP @CVSBR$		COUNTDOWN EXHAUSTED, READ CHAR AT LOCATION
	CB   R1,R6	 	IS IT THE CURSOR?
	JNE  NOTCUR		BRIF NO
	MOV  R5,R1	 	ELSE, SET CURSOR ON SCREEN
	JMP  RESTCX
NOTCUR	EQU  $
	MOV  R6,R1	 	ELSE, SET OLD CHARACTER ON SCREEN
RESTCX	EQU  $
	BLWP @CVSBW$
	JMP  RCOUNT
*
KEYREP	EQU  $
	SETO @FIRREP		SET REPEAT IN PROCESS FLAG
	JMP  KEYCOM
KEYNEW	EQU  $
	CLR  @FIRREP		CLEAR FIRST REPEAT FLAG
KEYCOM	EQU  $			KEYBOARD EXIT LOOP
	CLR  @CLOCK2		RESET CLOCK
	MOV  R5,R1	 	RESTORE OLD CHARACTER ON SCREEN
	BLWP @CVSBW$
	CLR  R1
	MOVB @KEYFND,R1
	SWPB R1
	MOV  R1,R1	 	MAKE SURE CHARACTER IN RANGE
	JEQ  RCOUNT
	CI   R1,>007F
	JLT  INCOUN		BRIF YES, IT IS AN ASCII OR CONTROL CHAR
	CI   R1,>0089		IS IT A TABSTOP (FOR GENEVE)
	JNE  RCOUNT		BRIF NO, GET ANOTHER CHAR
	LI   R1,1		MAKE EQUAL TO F7
INCOUN	EQU  $
	MOV  @AKEYC,R2
	MOV  R1,*R2		SAVE VALUE FOR USER
	MOV  @TEMPS,R3
	MOV  @TEMPS+2,R11
	B    *R11	  	RETURN
*
*  DATA AREA
*
TEMPS	BSS  4			TEMP STORAGE AREA
*
AVARAD	EQU  $
AARG1	EQU  $
AROW	EQU  $
ASTART	BSS  2			STARTING RECORD
*
ACOL	EQU  $
ARAMAD	EQU  $
AARG2	EQU  $
ASCREE	BSS  2			SCREEN NUMBER
*
AKEYC	EQU  $
ANOWRD	EQU  $
AARG3	EQU  $
ALINKS	BSS  2			LINKAGE
*
AOFFSE	BSS  2			OFFSETS INTO RECS
*
ALINBU	BSS  2			LINE BUFFER ADDRESS
APACBU	BSS  2			PACKED BUFFER ADDRESS
*
*  LOCAL VARIABLES:
*
SCRENO	BSS  2			SCREEN OFFSET INTO RECORD
START	BSS  2			CURRENT RECORD #
FIRREP	BSS  2			FIRST REPEAT FLAG
NUMBYS	BSS  2			# OF BYTES PER LINE
ENDSCR	BSS  2			END OF SCREEN ADDRESS
*
BLANK	TEXT '  '
EOFTXT	TEXT '<EOD> (Version 4.4)'
	EVEN
K20	DATA 20
	END
