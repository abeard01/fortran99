	TITL 'CALL SUBROUTINE OR INLINE FUNCTION'
	IDT  'CALL$'
*
*  CALL$  - THIS MODULE DOES FORTRAN CALLS TO SUBROUTINES
*  FUNCT$ - THIS MODULE DOES FORTRAN CALLS TO INLINE FUNCTIONS
*
*
*  THIS VERSION OPERATES PROPERLY WITH BOTH MDOS AND GPL VERSIONS.
*
*  Update History:
*
*    09-Dec-1988   Version 4.1   Initial Creation
*    22-May-1989   Version 4.4   Updated for new FORTRAN Equates
*    19-Jul-1989   Version 4.41  Changed Reference to FORTPAR
*
*  Copyright 1989 by LGMA Products
*
	DEF  CALL$		CALL SUBROUTINE ENTRY
	DEF  CALLI$		CALL SUBROUTINE/INDIRECT ENTRY
	DEF  FUNCT$		CALL INLINE FUNCTION ENTRY
	DEF  FUNCI$		CALL INLINE FUNCTION INDIRECT ENTRY
*
*  EQUATES:
*
	COPY "FORTPAR:"
	UNL
	COPY "EQUATES:FORTEX.EQ9"
	LIST
*
*  REGISTER USAGE WITHIN SUBROUTINE (TO SAVE MEMORY ALLOCATION):
*
ARGCN1	EQU  0			ARGUMENT #1
NOARGS	EQU  1			NUMBER OF ARGUMENTS
SUBLOC	EQU  2			SUBROUTINE LOCATION
ARGCN2	EQU  6			ARGUMENT #2
BITPTR	EQU  7			POINTER TO ARG LIST BITMAP
FROMPT	EQU  8			FROM POINTER
TOPTR	EQU  9			TO POINTER
DATLOC	EQU  12			DATA LOCATION
*
*  CALL/CALLI -
*
*  CALL & CALLI ARE EXECTED TO SETUP THE LINKAGE TO A SUBPROGRAM.  
*  KEYWORDS ARE USED TO DESCRIBE HOW TO COMPUTE THE ARGUMENT ADDRESSES
*  WHICH ARE TRANSFERED INTO THE SUBPROGRAM'S ARGUMENT TEMP AREA. THE
*  CALLING SEQUENCE IS AS FOLLOWS:
*
*	BL   @CALL/CALLI
*	DATA ADDRESS OF SUBPROGRAM
*	DATA KEYWOR	(M+11)/8 WORDS
*	DATA ARG1
*	.   .
*	.   .
*	DATA ARGM
*
*  WHERE THE FIRST KEYWORD HAS NUMBER OF ARGUMENTS IN FIRST BYTE AND
*  KEYWORD BIT PAIRS IN SECOND BYTE.  KEYWORD BIT PAIRS HAVE FOLLOWING
*  MEANING:
*
*	00 - NO MORE ARGUMENTS IN KEYWORD
*	01 - ARGUMENT PRESENT IN ARG LIST
*	10 - DIRECT ADR OF ARG PRESENT IN LIST
*	11 - INDIRECT ADR OF ARG PRESENT IN LIST
*
CALLI$  EQU  $
	MOV  *R11+,SUBLOC	GET SUBROUTINE/FUNCTION LOCATION
	MOV  *SUBLOC,SUBLOC
	JMP  CALLCO
*
CALL$	EQU  $
	MOV  *R11+,SUBLOC	GET SUBROUTINE/FUNCTION LOCATION
*
CALLCO	EQU  $
	MOV  @2(SUBLOC),DATLOC  GET $TEMPS ADDRESS
	MOV  DATLOC,TOPTR	POINTER TO WHERE TO PUT ARGS
	MOV  R3,*TOPTR+		SAVE CALLER'S POINTER TO DATA AREA
	MOV  DATLOC,R3		SET SUBROUTINE'S POINTER TO DATA AREA
	JMP  XFERAR
*
*  FUNCT is executed to setup the linkage to a statement
*  function.  Keywords are used for argument addresses as with CALL.
*
FUNCI$	EQU  $
	MOV  *R11+,SUBLOC	GET CALLING SEQUENCE ADDRESS
	MOV  *SUBLOC,SUBLOC
	JMP  FUNCCO
*
FUNCT$	EQU  $
	MOV  *R11+,SUBLOC	GET CALLING SEQUENCE ADDRESS
*
FUNCCO	EQU  $
	MOV  @2(SUBLOC),TOPTR	MOVE TO ADDRESS
*
*  XFERAR : ARGUMENT TRANSFER.  TRANSFERS THE ARGUMENT ADDRESSES FROM
*	    THE CALLER TO THE CALLEE.
*
XFERAR	EQU  $
	MOV  *R11,R5		GET # OF ARGUMENTS TO TRANSFER
	MOV  *R11,R4
	SWPB R4
	ANDI R4,>FF00
	ANDI R5,>FF00
	SWPB R5			GET # ARGS
	MOV  R5,NOARGS	 	SAVE + # OF ARGUMENTS
	AI   R5,11	 	COMPUTE # KEYWORDS (#ARGS+11/8)
	SRA  R5,3
	SLA  R5,1		MAKE SURE IT'S EVEN
	A    R11,R5
	MOV  R5,FROMPT		FROMPTR POINTS TO FIRST ARGUMENT LIST
	MOV  NOARGS,R6
	SLA  R6,1
	A    R6,R5		RETURN ADDRESS COMPUTED
	MOV  R11,BITPTR		USE R7 FROM NOW ON (TO POINT TO ARG LIST)
	MOV  R5,R11		SET RETURN IN R11 ALSO
	MOV  R5,*TOPTR+
	MOV  *SUBLOC+,R5
	JEQ  ARGX7	 	BRIF NO ARGS EXPECTED
	JLT  CNTOK
*
*  THE FIRST WORD OF THE SUBROUTINE OR FUNCTION SUBPROGRAM IS NOT
*  NEGATIVE OR ZERO.  DISPLAY AN EXECUTION ERROR 'SE', SUBROUTINE ERROR.
*
	MOV  R5,R1	 	DISPLAY OFFENDING WORD
	CLR  R6
	BLWP *R10		IF NOT NEGATIVE, THEN ROUTINE BOMBED
	DATA ERROR
	TEXT 'SE'
	IF   GENEVE		MAKE SURE I ABORT PROGRAM GRACEFULLY
	B    @RMENU$(R10)
	ELSE
	B    @CMENU$
	ENDIF
*
*  THE COUNT OF ARGUMENTS IS OK.  CONTINUE TRANSFERRING THE ARGUMENTS.
*
CNTOK	EQU  $			SAVE - ARGS EXPECTED
	MOV  R5,ARGCN2
	MOV  NOARGS,R5
	NEG  R5
	JEQ  ARGX8	 	BRIF NO ARGS TO BE PASSED
	MOV  R5,ARGCN1
	CLR  R5
*
ARGX5	EQU  $
	MOV  R4,R4
	JLT  ARGX1	 	BRIF DIRECT OR INDIRECT ARG
	SRC  R4,16-1
	JLT  ARGX3
	INCT BITPTR		GO GET NEXT KEYWORD
	MOV  *BITPTR,R4
	JMP  ARGX5
ARGX3	EQU  $
	MOV  FROMPT,R5
	JMP  ARGX4
ARGX1	EQU  $
	SRC  R4,16-1
	JLT  ARGX2	 	BRIF INDIRECT ARG
	MOV  *FROMPT,R5
	JMP  ARGX4	  	POINTED TO BY LIST ITEM
ARGX2	EQU  $
	MOV  *FROMPT,R5
	MOV  *R5,R5
ARGX4	EQU  $
	MOV  R5,*TOPTR+
	CLR  R5
	SLA  R4,1
	INCT FROMPT
	INC  ARGCN2
	JEQ  ARGX7
	INC  ARGCN1
	JNE  ARGX5
ARGX8	EQU  $			FLUSH PAST UNUSED ARGUMENTS
	MOV  ARGCN2,R6
ARGX9	EQU  $
	MOV  R5,*TOPTR+
	INC  R6
	JNE  ARGX9
*
*  DONE ARGUMENT TRANSFER.  ACTUALLY GO TO SUBROUTINE OR FUNCTION
*
ARGX7	EQU  $
	INCT SUBLOC
	B    *SUBLOC		GOTO SUBROUTINE
	END
