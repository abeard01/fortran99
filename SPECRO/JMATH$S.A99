	TITL 'JMATH$- INTEGER *4 MULTIPLY AND DIVIDE'
	IDT  'JMATH$'
*
*  JMATH$ - THIS MODULE CONTAINS THE 32-BIT MULTIPLY AND DIVIDE ROUTINES
*
*     J4MUL$ - INTEGER *4 MULTIPLICATION
*     J4DIV$ - INTEGER *4 DIVISION
*
*  CALLING SEQUENCE:
*
*               BL   @J4MUL$
*                   or
*               BL   @J4DIV$
*
*  ON ENTRY TO THESE ROUTINES, R5 AND R6 CONTAIN  THE MULTIPLICAND/DIVIDEND,
*			       R2        CONTAINS THE (MULTIPLIER  /DIVISOR)
*
*  ON EXIT FROM THIS ROUTINE:
*
*			       R5 AND R6 CONTAIN THE RESULT
*			       STATUS REGISTER CONTAINS THE SIGN OF R5,R6
*
*  THIS VERSION OPERATES PROPERLY WITH BOTH MDOS AND GPL VERSIONS.
*
*  Update History:
*
*    29-Nov-1988   Version 4.1   Corrected 32 bit divide
*    20-Oct-1989   Version 4.4   Corrected problem when high end of both
*				 values were zero, but low end one was
*				 positive and one was negative.
*
*  Copyright 1989 by LGMA Products
*
	DEF  J4MUL$		MULTIPLICATION
	DEF  J4DIV$		DIVISION
*
*  INTEGER *4 DIVISION
*
J4DIV$	EQU  $
	MOV  R11,R12		SAVE RETURN
	BL   @MAKPOS		MAKE ARGUMENTS POSITIVE
*
	MOV  R0,R0		IS DIVISOR ZERO?
	JNE  J4DIVA		BRIF NO
	MOV  R1,R1
	JNE  J4DIVA		BRIF NO
*
*  DIVISOR IS ZERO, RETURN MAXIMUM VALUE FOR RESULT
*
	CLR  R6
	LI   R5,>8000
	JMP  NOTMIN		RETURN
*
J4DIVA	EQU  $
	C    R0,R5		IF DIVISOR GREATER THAN DIVIDEND
	JGT  J4DIV0		 THEN SET RESULT TO ZERO
	JLT  J4DIVB	
	C    R1,R6		LIKEWISE WITH LOW END IF HIGH END EQUAL
*
*  FOLLOWING TWO STATEMENTS WERE CHANGED TO CORRECT A COMPARISON BUG
*  IN VERSION 4.4 OF 99/9640 FORTRAN.
*
	JH   J4DIV0
	JL   J4DIVB		(NOTE USE OF LOGICAL NOT ARITH COMPARATORS)
*
	CLR  R5			DIVISOR = DIVIDEND, RETURN 1 FOR ANSWER
	LI   R6,1
	JMP  RESMIN
*
J4DIVB	EQU  $			CHECK FOR SPECIAL USES OF DIVIDE INSTRUCTIONS
	MOV  R5,R5		IS DIVIDEND ONLY 16 BITS?
	JEQ  J4DIV6		BRIF YES, USE 16 BIT DIVIDE
	MOV  R0,R0		CHECK ON 16-BIT RESULT
	JNE  J4DIVD
	C    R5,R1
	JH   J4DIVC		CAN'T DO SIMPLE 16-BIT
	JEQ  J4DIVC		CAN'T DO SIMPLE 16-BIT 
*
*  HAVE DETERMINED THAT NORMAL 32/16 BIT DIVIDE WILL SUFFICE.  PERFORM
*  OPERATION.
*
J4DIV6	EQU  $
	DIV  R1,R5		DO 32BIT/16BIT DIVIDE
	MOV  R5,R6		SAVE 16 BIT RESULT
	CLR  R5
	JMP  RESMIN		RESTORE MINUS
*
*  THIS ALTERNATIVE IS A 32BIT/16BIT DIVIDE, WHERE THE 16BIT DIVISOR
*  IS LESS THAN THE MSW OF THE 32BIT DIVIDEND.
*
*  DIVIDE IS DONE IN TWO STEPS, DIVIDE MSW OF DIVIDEND, AND THEN LSW
*  OF DIVIDEND (WITH REMAINDER FROM MSW DIVIDE).
*
J4DIVC	EQU  $
	MOV  R6,R7		SAVE LSB OF DIVIDEND
	MOV  R5,R6
	CLR  R5
	DIV  R1,R5		DIVIDE MSW OF HIGH END
	DIV  R1,R6		DIVIDE LSW OF HIGH END
	JMP  RESMIN
*
*  DIVISOR IS 32 BITS, DIVIDEND IS 32 BITS, MUST DO ACTUAL LONG WORD DIVIDE
*
J4DIVD	EQU  $
	CLR  R2			CLEAR RESULT REGISTER
	CLR  R3
	CLR  R7			CLEAR SHIFT REGISTER
	LI   R8,1
*
J4DIVE	EQU  $
	SLA  R7,1		SHIFT R7,R8 LEFT ONCE
	SLA  R8,1
	JNC  J4DIVF
	INC  R7
J4DIVF	EQU  $
	SLA  R0,1
	SLA  R1,1		SHIFT DIVISOR LEFT ONCE
	JNC  J4DIVG
	INC  R0
J4DIVG	EQU  $
	C    R0,R5		SHIFTED DIVISOR > DIVIDEND?
	JNE  J4DIVH
	C    R1,R6
J4DIVH	EQU  $
	JL   J4DIVE		NO
	JEQ  J4DIVE
	JMP  J4DIVM		BRIF YES
*
J4DIVJ	EQU  $
	C    R0,R5		YUCK, DIVIDE A BIT AT A TIME
	JNE  J4DIVI
	C    R1,R6
J4DIVI	EQU  $
	JH   J4DIVM
	SOC  R7,R2		SET BIT IN RESULT REGISTER
	SOC  R8,R3
	MOV  R0,R4		DOUBLE SUBTRACT DIVISOR FROM DIVIDEND
	MOV  R1,R9
	INV  R4
	INV  R9			BY TWO'S COMPLEMENT ADD
	INC  R9
	JNC  J4DIVK
	INC  R4
J4DIVK	EQU  $
	A    R9,R6		ADD LOW END
	JNC  J4DIVL
	INC  R5
J4DIVL	EQU  $
	A    R4,R5
*
J4DIVM	EQU  $
	MOV  R0,R4		SAVE SHIFTED OUT BIT
	SRC  R4,1
	ANDI R4,>8000
	SRL  R0,1
	SRL  R1,1
	SOC  R4,R1		DOUBLE SHIFT LOGICAL RIGHT OF RESULT
*
	MOV  R7,R4
	SRC  R4,1
	ANDI R4,>8000
	SRL  R7,1
	SRL  R8,1
	SOC  R4,R8		DOUBLE SHIFT POWER OF TWO RIGHT ONCE
*
	MOV  R7,R7		IS POWER OF TWO ZERO?
	JNE  J4DIVJ
	MOV  R8,R8
	JNE  J4DIVJ
	MOV  R2,R5		SAVE RESULT
	MOV  R3,R6
	JMP  RESMIN		RESTORE MINUS PART
*
*  HAVE DETERMINED THAT A RESULT OF ZERO IS CALLED FOR.
*
J4DIV0	EQU  $
	CLR  R5
	CLR  R6
	JMP  NOTMIN		RETURN TO USER
*
*  INTEGER *4 MULTIPLICATION
*
J4MUL$	EQU  $
	MOV  R11,R12		SAVE RETURN
	BL   @MAKPOS
	MOV  R5,R7		SAVE TOP END OF MULTIPLICAND
	MOV  R6,R4		SAVE LS2
	MOV  R6,R5		3RD, 4TH DIGITS = LS1 x LS2
	MPY  R1,R5
*
	MPY  R1,R7		2ND, 3RD DIGITS = LS1 x MS2	
	A    R8,R5		ADD IN 3RD DIGIT
*
	MOV  R4,R7		GET LS2
	MPY  R0,R7		2ND, 3RD DIGITS = MS1 x LS2
	A    R8,R5		ADD IN 3RD DIGIT
*
*  RESTORE NEGATE FLAG
*
RESMIN	EQU  $
	ANDI R2,>8000		MASK NEGATE FLAG
	JEQ  NOTMIN		BRIF DON'T NEED A MINUS
	INV  R5
	INV  R6
	INC  R6
	JNE  NOTMIN
	INC  R5
*
*  RESTORE RETURN STATUS
*
NOTMIN	EQU  $
	MOV  @SAVBAS,R3		RESTORE BASE
	MOV  R5,R5		SET FIRST
	JNE  MULRET		BRIF DONE
	MOV  R6,R6		ELSE, MUST USE R6 FOR STATUS
MULRET	EQU  $
	B    *R12
*
*  MAKPOS : MAKE THE ARGUMENTS SPECIFIED POSITIVE.  THE SIGN FLAG IS
* 	    SAVED IN REGISTER R2.
*
MAKPOS	EQU  $
	MOV  R3,@SAVBAS		SAVE BASE (DESTROYED ON LONG MULTIPLY)
	MOV  *R2+,R0		GET MULTIPLIER/DIVISOR
	MOV  *R2+,R1
*
*  FIRST MAKE SURE BOTH ARGUMENTS ARE POSITIVE
*
	MOV  R0,R2		SAVE NEGATE FLAG
	XOR  R5,R2
	MOV  R0,R0		IS MULTIPLIER/DIVISOR NEGATIVE?
	JEQ  ARG1PL		BRIF NO
	JGT  ARG1PL
	INV  R0			NEGATE MULTIPLIER/DIVISOR
	INV  R1
	INC  R1
	JNC  ARG1PL
	INC  R0
ARG1PL	EQU  $
	MOV  R5,R5		CHECK MULTIPLICAND/DIVIDEND
	JEQ  ARG2PL
	JGT  ARG2PL
	INV  R5			NEGATE MULTIPLICAND/DIVIDEND
	INV  R6
	INC  R6
	JNC  ARG2PL
	INC  R5
ARG2PL	EQU  $
	B    *R11
*
SAVBAS	BSS  2			BASE SAVE FOR R3
	END
