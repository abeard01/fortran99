	TITL	'SINGLE/DOUBLE PRECISION MATH CONVERSIONS'
	IDT     'FCIF$'
*
*  FLOATING POINT CONVERSIONS, AS FOLLOWS:
*
*  TO USE ANY OF THESE ROUTINES, DO THE FOLLOWING:
*
*   1) PUT THE INTEGER *1 ARGUMENT IN R5 HIGH BYTE, OR
*   2) PUT THE INTEGER *2 ARGUMENT IN R5, OR
*   3) PUT THE INTEGER *4 ARGUMENT IN R5 AND R6, THEN
*   4) BRANCH AND LINK TO THE APPROPRIATE ROUTINE
*
*  FOR EXAMPLE, TO CONVERT THE VALUE 123 TO DOUBLE PRECISION, THEN DO:
*
*	LI  R5,123
*	BL  @IDCVT$
*
*		... THE RESULT IS RETURNED IN R5, R6, R7 AND R8
*
*  	IACVT$  -  INTEGER    TO SINGLE PRECISION
*  	IDCVT$  -  INTEGER    TO DOUBLE PRECISION
*  	KACVT$  -  BYTE       TO SINGLE PRECISION
*  	KDCVT$  -  BYTE       TO DOUBLE PRECISION
*  	JACVT$  -  INTEGER *4 TO SINGLE PRECISION
*  	JDCVT$  -  INTEGER *4 TO DOUBLE PRECISION
*
*  HISTORY:
*
*  REV LEVEL    DATE          WHO
*
*    4.0        29-AUG-88     A.L.BEARD    Initial Writing
*
*  NOTE:  THIS ROUTINE IS CODED TO WORK UNDER MDOS OR GPL WITH NO
*         DIFFERENCES (OBJECT LEVEL COMPATIBLE).
*
*  Copyright 1990 by LGMA Products
*
	DEF  IACVT$
	DEF  IDCVT$
	DEF  JACVT$
	DEF  JDCVT$
	DEF  KACVT$
	DEF  KDCVT$
*
*  NOTES:
*
*   1. ON ENTRY TO THESE ROUTINES, THE REGISTERS ARE SET FOR:
*
*	  INTEGER *1,  R5 HIGH BYTE HAS ARGUMENT
*	  INTEGER *2,  R5 HAS ARGUMENT
*	  INTEGER *4,  R5, R6 HAVE ARGUMENTS
*
*      THE VALUE IS CONVERT TO AN INTEGER *4 FOR CONVERSION, AND
*      LEFT IN REGISTERS R5, R6, R7 AND R8.  SINGLE VS. DOUBLE
*      OUTPUT DOESN'T MATTER.
*
*  KACVT$ - CONVERT BYTE TO SINGLE PRECISION
*  KDCVT$ - CONVERT BYTE TO DOUBLE PRECISION
*
KACVT$	EQU  $
KDCVT$	EQU  $
	SRA  R5,8		CONVERT TO INTEGER *2
*
*  IACVT$ - CONVERT INTEGER TO SINGLE PRECISION
*  IDCVT$ - CONVERT INTEGER TO DOUBLE PRECISION
*
IACVT$	EQU  $
IDCVT$	EQU  $
	MOV  R5,R6		CONVERT TO INTEGER *4
	SRA  R5,15		SIGN EXTEND
*
*  KACVT$ - CONVERT INTEGER *4 TO SINGLE PRECISION
*  KDCVT$ - CONVERT INTEGER *4 TO DOUBLE PRECISION
*
JACVT$	EQU  $
JDCVT$	EQU  $
	CLR  R1			RESET NEGATE FLAG
	LI   R4,RAD100		RADIX 100 OUTPUT
	MOV  R5,R5		IS VALUE NEGATIVE?
	JGT  DIGLOP		BRIF NO, START CONVERSION
	JEQ  DIGLOP
	SETO R1			SET NEGATE FLAG
	INV  R5
	INV  R6			DO DOUBLE NEGATE
	INC  R6
	JNE  DIGLOP
	INC  R5
*
*  THE FOLLOWING DIVIDES THE DOUBLE WORD QUANTITY IN R5 AND R6 BY
*  100, UNTIL THE VALUE REMAINING IS ZERO.  EACH RADIX 100 DIGIT IS
*  SAVED IN THE RAD100 ARRAY (POINTED TO BY R4).
*
DIGLOP	EQU  $
	MOV  R6,R8		ANYTHING REMAINING?
	JNE  DIGLO1		BRIF YES
	MOV  R5,R5
	JEQ  DIGDON		BRIF DONE, NOTHING REMAINING
DIGLO1	EQU  $
	MOV  R5,R6		DIVIDE HIGH END BY 100
	CLR  R5
	DIV  @K100,R5		TO GET NEW HIGH END
	MOV  R5,R7		SAVE NEW HIGH END
	MOV  R6,R5		DIVIDE NEW LOW END
	MOV  R8,R6		AGAIN BY 100
	DIV  @K100,R5
	SWPB R6			PUT RADIX 100 DIGIT (REMAINDER) IN
	MOVB R6,*R4+		 RADIX 100 ARRAY
	MOV  R5,R6		SET NEW LOW END
	MOV  R7,R5		AND NEW HIGH END
	JMP  DIGLOP		
*
*  NOW THE RAD100 ARRAY CONTAINS UP TO 6 RADIX 100 DIGITS.
*  CALCULATE THE EXPONENT, AND MOVE EACH DIGIT TO THE RADIX 100
*  ARRAY.  CHECK FOR ZERO, IT'S SPECIAL.
*
DIGDON	EQU  $
	CLR  R5			CLEAR RESULTING FAC
	CLR  R6
	CLR  R7
	CLR  R8
	LI   R5,RAD100		RADIX 100 START AGAIN
	S    R4,R5		WAS ANYTHING STORED?
	JEQ  CIFRET		BRIF NO, JUST RETURN
	NEG  R5			SINCE NEGATIVE RESULT, MUST MAKE POS
	AI   R5,>003F		FORM EXPONENT
	SWPB R5
	STWP R2			SET R2 AS A POINTER INTO R5+1
	AI   R2,11
FACLOP	EQU  $
	DEC  R4
	MOVB *R4,*R2+		MOVE A RADIX 100 DIGIT
	CI   R4,RAD100		AT THE BEGINNING?
	JNE  FACLOP		NO, DO ANOTHER
*
*  GOOD POSITIVE RADIX 100 VALUE IN R5,R6,R7,R8.  SEE IF NEED
*  TO NEGATE.
*
	MOV  R1,R1		CHECK NEGATE FLAG
	JEQ  CIFRET		BRIF DONE
	NEG  R5			ELSE, NEGATE RESULT
CIFRET  EQU  $
	MOV  R5,R5		SET STATUS
	B    *R11		AND RETURN
*
RAD100	DATA 0,0,0		MAXIMUM OF 6 RADIX 100 DIGITS
*				(FOR MAXIMUM I*4 INTEGER OF 2,147,483,648)
K100    DATA 100                A CONSTANT
        END
