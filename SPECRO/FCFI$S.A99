	TITL	'SINGLE/DOUBLE PRECISION MATH CONVERSIONS'
	IDT     'FCFI$'
*
*  FLOATING POINT CONVERSIONS, AS FOLLOWS:
*
*  AICVT$  -  SINGLE PRECISION TO INTEGER
*  DICVT$  -  DOUBLE PRECISION TO INTEGER
*  AKCVT$  -  SINGLE PRECISION TO BYTE
*  DKCVT$  -  DOUBLE PRECISION TO BYTE
*  AJCVT$  -  SINGLE PRECISION TO INTEGER *4
*  DJCVT$  -  DOUBLE PRECISION TO INTEGER *4
*
*  HISTORY:
*
*  REV LEVEL    DATE          WHO
*
*    4.0        29-AUG-88     A.L.BEARD    Initial Writing
*
*  NOTE:  THIS ROUTINE IS CODED TO WORK UNDER MDOS OR GPL WITH NO
*         DIFFERENCES (OBJECT LEVEL COMPATIBLE).
*
*  Copyright 1989 by LGMA Products
*
	DEF  AICVT$
	DEF  DICVT$
	DEF  AJCVT$
	DEF  DJCVT$
	DEF  AKCVT$
	DEF  DKCVT$
*
*  NOTES:
*
*   1. ON ENTRY TO THESE ROUTINES, THE REGISTERS ARE SET FOR:
*
*	  SINGLE PRECISION, R5 AND R6 HAS ARGUMENTS
*	  DOUBLE PRECISION, R5, R6, R7 AND R8 HAVE ARGUMENTS
*
*   2. ON EXIT, THE REGISTERS ARE SET AS FOLLOWS ACCORDING TO TYPE:
*
*	  INTEGER *1,  R5 HIGH BYTE HAS ARGUMENT
*	  INTEGER *2,  R5 HAS ARGUMENT
*	  INTEGER *4,  R5, R6 HAVE ARGUMENTS
*
*   3. STATUS REGISTER IS SET ACCORDING TO FLOATING POINT VALUE
*
*
*  AKCVT$ - CONVERT SINGLE PRECISION TO BYTE
*  DKCVT$ - CONVERT DOUBLE PRECISION TO BYTE
*
AKCVT$	EQU  $
	CLR  R7
	CLR  R8
DKCVT$	EQU  $
	SETO R4			RESULT IS INTEGER *1
	JMP  CFICON
*
*  AICVT$ - CONVERT SINGLE PRECISION TO INTEGER *2
*  DICVT$ - CONVERT DOUBLE PRECISION TO INTEGER *2
*
AICVT$	EQU  $
	CLR  R7
	CLR  R8
DICVT$	EQU  $
	CLR  R4			RESULT IS INTEGER *2
	JMP  CFICON
*
*  AJCVT$ - CONVERT INTEGER *4 TO SINGLE PRECISION
*  DJCVT$ - CONVERT INTEGER *4 TO DOUBLE PRECISION
*
AJCVT$	EQU  $
	CLR  R7
	CLR  R8
DJCVT$	EQU  $
	LI   R4,1		SET RESULT TO INTEGER *4
*
*  COMMON PART OF CONVERT FLOATING TO INTEGER.
*
*  FLOATING POINT VALUE IS IN R5,R6,R7 AND R8.
*  FLAG FOR RESULT (-1=K, 0=I, 1=J) IS IN R9.
*  WORKING RESULT IS IN R0,R1, FINAL IS TO PLACE IN R5,R6
*
CFICON	EQU  $
	MOV  R4,@FLAGTY		FLAG TYPE OF VALUE
	MOV  R5,@SIGNFL		SAVE SIGN OF FAC
	CLR  R0			CLEAR RESULT
	CLR  R1
	ABS  R5			SET FAC POSITIVE
	STWP R2			OFFSET TO FAC
	AI   R2,10		R5,LOW BYTE
	CLR  R4
	MOVB *R2+,R4		GET EXPONENT
	SWPB R4
	AI   R4,->0040		ZERO BASE IT
	JLT  DIGDON		BRIF TOO SMALL
	CI   R4,5		TRY FOR MAXIMUM
	JGT  DIGDON		BRIF TOO LARGE
	INC  R4			SO END DECR WILL WORK PROPERLY
DIGLOP	EQU  $
	MOV  R1,R9		SAVE LOW END
	MPY  @K100,R0		MULTIPLY HIGH END
	MOV  R1,R8		SAVE NEW HIGH END
	MOV  R9,R0		GET LOW END
	MPY  @K100,R0		MULTIPLY AGAIN
	A    R8,R0		ADD IN OLD HIGH END
	CLR  R8
	MOVB *R2+,R8		MAKE FIRST NON-RADIX 100 DIGIT
	SWPB R8
	A    R8,R1
	JNC  DIGLO1
	INC  R0
DIGLO1	EQU  $
	DEC  R4
	JGT  DIGLOP
*
*  R0 AND R1 NOW CONTAIN A POSITIVE INTEGER *4 NUMBER.  CHECK IF
*  MINUS REQUIRED.
*
DIGDON	EQU  $
	MOV  @SIGNFL,R4		CHECK SIGN FLAG
	JEQ  DIGDO2
	JGT  DIGDO2
	INV  R1			DO DOUBLE WORD NEGATE
	INV  R0
	INC  R1
	JNC  DIGDO2
	INC  R0
DIGDO2	EQU  $
	MOV  R1,R6		MOVE DOUBLE WORD RESULT
	MOV  R0,R5
	MOV  @FLAGTY,R4		TYPE OF RESULT DESIRED
	JGT  INTER4		DO INTEGER *4 RETURN (EASY)
	JEQ  INTER2		DO INTEGER *2 RETURN (A LITTLE HARDER)
*
INTER1	EQU  $			DO INTEGER *1 RETURN (JUST SO EASY)
	MOV  R6,R5
	CLR  R6
	SLA  R5,8
	B    *R11
*
INTER2	EQU  $
	MOV  R6,R5
	CLR  R6
	B    *R11
*
INTER4	EQU  $
	MOV  R5,R5		SET STATUS
	JNE  CFIRET		BRIF NOT EQUAL, DONE
	MOV  R6,R6
CFIRET	EQU  $
	B    *R11
*
SIGNFL	DATA 0			SAVE OF FAC 1ST WORD (FOR SIGN RESULT)
FLAGTY	DATA 0			FLAG HOLDING TYPE OF RESULT DESIRED
K100    DATA 100                A CONSTANT
        END
