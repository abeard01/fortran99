	TITL	'COMPLEX *8 PRECISION MATH'
	IDT     'CMATH$'
*
*  COMPLEX *8 ADDITION, SUBTRACTION, COMPARE, LOAD, AND STORE.
*
*  ON ENTRY, R5 AND R6 CONTAIN THE REAL FAC, R7 AND R8 CONTAIN
*  THE IMAGINARY FAC.   R2 POINTS TO A FOUR WORD ARGUMENT WHICH
*  CONTAINS THE REAL & IMAGINARY ARGUMENT.
*
*  HISTORY:
*
*    4.4        28-AUG-89     INITIAL VERSION
*    4.41       19-SEP-89     FIXES
*    4.42       29-NOV-89     ADD AIMAG AND CMPLX ROUTINES
*
*  COPYRIGHT 1989 BY LGMA PRODUCTS
*
	DEF  CADD$		COMPLEX ADDITION
	DEF  CSUB$		COMPLEX SUBTRACTION
	DEF  CCMP$		COMPLEX COMPARE
	DEF  AIMAG		IMAGINARY EXTRACT
	DEF  CMPLX		BUILD COMPLEX NUMBER ROUTINE
*
	COPY "FORTPAR:"
*
	UNL
	IF   GENEVE
	COPY "EQUATES:MATH.EQ9"
	ENDIF
	COPY "EQUATES:FORTEX.EQ9"
	LIST
*
*  CCMP$ - COMPLEX COMPARE.  THIS COMPARE JUST COMPARES THE REAL
*	   VALUES, PROBABLY NOT THE RIGHT THING TO DO, BUT ALL
*	   I CAN THINK OF FOR NOW.
*
CCMP$	EQU  $
	C    R5,*R2+		; CHECK FIRST VALUE
	JNE  CCMPR
	MOV  R5,R5		; CHECK FIRST WORD OF COMPARE
	JEQ  CCMP2
	JGT  CCMP1		; IF >0, THEN DO NORMAL COMPARE
	C    *R2+,R6		; ELSE, MUST REVERSE COMPARE
	JMP  CCMPR
CCMP1	EQU  $
	C    R6,*R2+		; CHECK SECOND VALUE
	JMP  CCMPR
CCMP2	EQU  $
	DECT R2
	C    R5,*R2+		; RESET EQUAL STATUS
	INCT R2
CCMPR	EQU  $
	STST R4			; SAVE STATUS
*
*  COMPARE IMAGINARY PORTION
*
	C    R7,*R2+		; COMPARE IMAGINARY
	JNE  ICMPR		; IF DIFFERENT, DONE DEAL
	MOV  R7,R7		; CHECK FIRST WORD OF COMPARE
	JEQ  ICMP2
	JGT  ICMP1		; IF >0 THEN DO NORMAL COMPARE
	C    *R2+,R8		; ELSE MUST DO REVERSE COMPARE
	JMP  ICMPR
ICMP1	EQU  $
	C    R8,*R2+		; NORMAL COMPARE
	JMP  ICMPR
ICMP2	EQU  $
	DECT R2
	C    R7,*R2+
ICMPR	EQU  $
	STST R2			; SAVE STATUS
	INV  R2
	SZC  R2,R4		; TO GET FINAL STATUS (R2 & R4)
*
*  EXTRACT EQUAL BIT AND ARITHMETIC GREATER THAN BIT
*
	MOV  R4,R2		; SAVE STATUS BYTE
	ANDI R2,>2000		; EXTRACT EQUAL BIT
	JNE  ICMPEQ		; IT IS EQUAL
*
	ANDI R2,>4000		; EXTRACT ARITHMETIC GREATER THEN
	JNE  ICMPGT		; BRIF GREATER THEN
*
	SETO R4			; ELSE, SET LESS THAN
	JMP  ICMPDN
*
ICMPEQ	EQU  $
	CLR  R4			; SET EQUAL
	JMP  ICMPDN
*
ICMPGT	EQU  $
	LI   R4,1		; SET GREATER THAN
*
ICMPDN	EQU  $
	MOV  R4,R4		; SET STATUS
	B    *R11		; & RETURN
*
*  ADD TOGETHER TWO COMPLEX *8 NUMBERS.  THIS IS DONE BY THE
*  FORMULA:      (a + c ) + i( b + d )
*
CADD$	EQU  $
	LI   R0,FADD		; SET ADD
	JMP  SINCOM
*
*  SUBTRACT TWO COMPLEX *8 NUMBERS.   THIS IS DONE BY THE FORMULA:
*		( a - c ) + i( b - d )
*
CSUB$	EQU  $
	LI   R0,FSUB		; SET SUBTRACT
*
*  SINGLE PRECISION COMMON LOAD.  SET FAC & ARG
*
SINCOM	EQU  $
	MOV  R2,R9		; SAVE POINTER TO DATA
	MOV  R0,@XMLFUN		; SAVE FUNCTION CODE
	LI   R1,ARG
	MOV  R5,*R1+		; SET FAC
	MOV  R6,*R1+
	CLR  *R1+
	CLR  *R1
	LI   R1,FAC
	MOV  *R9+,*R1+		; SET ARG
	MOV  *R9+,*R1+
	CLR  *R1+
	CLR  *R1
*
*  FOR GENEVE, CALL THE MATH XOP TO PERFORM THE ADD/SUBTRACT
*
	IF   GENEVE
	MOV  R3,R12		; SAVE MY BASE
	LI   R1,RESULT
	LI   R2,FAC
	LI   R3,ARG
	XOP  @DMATXP,0		; DO IT
	MOV  R12,R3		; RESTORE BASE
	LI   R2,RESULT		; SET RESULT
	MOV  *R2+,R5
	MOV  *R2+,R6
	ELSE
*
*  TI-99 VERSION OF RADIX 100, CALL THE CONSOLE F.P. ROUTINES
*
	MOV  R0,@XMLFU1		; SET 2ND CALL TO CONSOLE LINKAGE
	BLWP @CXMLLN
XMLFUN	DATA 0			; FUNCTION CODE (DYNAMIC)
	LI   R2,FAC
	MOV  *R2+,R5
	MOV  *R2+,R6
	ENDIF
*
*  REAL PART HAS BEEN ADDED.  NOW PERFORM THE SAME OPERATION ON THE
*  IMAGINARY PORTION.
*
	LI   R1,ARG
	MOV  R7,*R1+
	MOV  R8,*R1+
	CLR  *R1+
	CLR  *R1
	LI   R1,FAC
	MOV  *R9+,*R1+
	MOV  *R9,*R1+
	CLR  *R1+
	CLR  *R1
	IF   GENEVE
	MOV  R3,R12		; SAVE MY BASE
	MOV  @XMLFUN,R0		; RESTORE R0
	LI   R1,RESULT
	LI   R2,FAC
	LI   R3,ARG
	XOP  @DMATXP,0		; DO IT
	MOV  R12,R3		; RESTORE BASE
	LI   R2,RESULT		; SET RESULT
	MOV  *R2+,R7
	MOV  *R2,R8
	ELSE
*
*  TI-99 VERSION OF RADIX 100, CALL THE CONSOLE F.P. ROUTINES
*
	BLWP @CXMLLN
XMLFU1	DATA 0			; FUNCTION CODE (DYNAMIC)
	LI   R2,FAC
	MOV  *R2+,R7
	MOV  *R2,R8
	ENDIF
	MOV  R5,R5		; SET STATUS BITS
	JNE  STARET
	MOV  R7,R7		; IF REAL 0, CHECK IMAGINARY
STARET	EQU  $
	B    *R11		; AND RETURN
*
*  AIMAG - RETURN IMAGINARY PORTION OF COMPLEX NUMBER AS REAL PART.
*	   CODED IN ASSEMBLY FOR SPEED.
*
AIMAG	EQU  $
	DATA -1			; 1 ARGUMENT
	DATA TEMPS		; TEMPS AREA
	MOV  @AARG,R2		; GET ARGUMENT ADDRESS
	AI   R2,4		; SKIP REAL PORTION
	MOV  *R2+,R5
	MOV  *R2,R6
	CLR  R7
	CLR  R8
	MOV  @TEMPS,R3
	MOV  R5,R5		; SET STATUS
	B    *R11		; RETURN
*
*  CMPLX - GIVEN TWO REAL *8 NUMBERS, RETURN A COMPLEX NUMBER
*
CMPLX	EQU  $
	DATA -2			; 2 ARGUMENTS
	DATA TEMPS
	MOV  @AARG,R2		; GET 1ST ARGUMENT
	MOV  *R2+,R5
	MOV  *R2,R6
	MOV  @AARG1,R2		; GET 2ND ARGUMENT
	MOV  *R2+,R7
	MOV  *R2,R8
	MOV  @TEMPS,R3		; RETURN COMPLEX NUMBER IN R5,R6,R7,R8
	MOV  R5,R5
	B    *R11
*
TEMPS	BSS  4
AARG	BSS  2
AARG1	BSS  2
*
	IF   GENEVE
DMATXP	DATA MATXOP		; MATH XOP LIBRARY NUMBER
FAC	DATA 0,0,0,0		; MY FAC
ARG	DATA 0,0,0,0		; MY ARG
RESULT	DATA 0,0,0,0		; MY RESULT
XMLFUN	DATA 0			; FUNCTION CODE SAVE
	ENDIF
	END
