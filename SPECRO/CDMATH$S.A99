	TITL	'COMPLEX *16 PRECISION MATH'
	IDT     'CDMATH$'
*
*  COMPLEX *16 ADDITION, SUBTRACTION, COMPARE, LOAD, AND STORE.
*
*  ON ENTRY, R5, R6, R7 AND R8 CONTAIN THE REAL ARGUMENT, MY
*  FACIM$ CONTAINS THE IMAGINARY ARGUMENT.   R2 POINTS TO
*  THE 8 WORD REAL & IMAGINARY ARGUMENT.
*
*  NOTE THAT MY FACIM$ IS DEF'D, THIS ALLOWS OTHER ROUTINES TO USE IT.
*
*  HISTORY:
*
*    4.4        28-AUG-89     INITIAL VERSION
*    4.41       15-NOV-89     FIXES TO COMPARE FROM ELMER C.
*    4.42       29-NOV-89     ADD DIMAG & DCMPLX ROUTINES
*
*  COPYRIGHT 1989 BY LGMA PRODUCTS
*
	DEF  CDADD$		COMPLEX ADDITION
	DEF  CDSUB$		COMPLEX SUBTRACTION
	DEF  CDCMP$		COMPLEX COMPARE
	DEF  CDLOA$		COMPLEX LOAD
	DEF  CDSTO$		COMPLEX STORE
	DEF  DIMAG		COMPLEX IMAGINARY TO REAL CONVERSION
	DEF  DCMPLX		BUILD COMPLEX *16 NO FROM TWO REAL *8
	DEF  FACIM$		IMAGINARY PORTION OF ACCUMULATOR
*
	COPY "FORTPAR:"
*
	UNL
	IF   GENEVE
	COPY "EQUATES:MATH.EQ9"
	ENDIF
	COPY "EQUATES:FORTEX.EQ9"
	LIST
*
*  CDLOA$ - COMPLEX LOAD.  JUST LOAD THE ARGUMENT POINTED TO BY R2
*	    INTO THE REGISTERS R5, R6, R7, AND R8 (REAL), AND THE
*	    IMAGINARY PART INTO FACIM$.  SET STATUS BITS FOR RESULT.
*
CDLOA$	EQU  $
	MOV  *R2+,R5		; LOAD REAL PORTION
	MOV  *R2+,R6
	MOV  *R2+,R7
	MOV  *R2+,R8
	LI   R1,FACIM$		; LOAD IMAGINARY PORTION
	MOV  *R2+,*R1+
	MOV  *R2+,*R1+
	MOV  *R2+,*R1+
	MOV  *R2,*R1
	JMP  DCSTAT
*
*  CDSTO$ - COMPLEX STORE.  JUST STORE THE VALUE IN R5, R6, R7, R8
*           (REAL) AND FACIM$ (IMAGINARY) INTO THE FOUR WORD VARIABLE
*	    POINTED TO BY R2.  SET STATUS BITS ACCORDING TO VALUE.
*
CDSTO$	EQU  $
	MOV  R5,*R2+		; STORE REAL PORTION
	MOV  R6,*R2+
	MOV  R7,*R2+
	MOV  R8,*R2+
	LI   R1,FACIM$		; STORE IMAGINARY PORTION
	MOV  *R1+,*R2+
	MOV  *R1+,*R2+
	MOV  *R1+,*R2+
	MOV  *R1,*R2
DCSTAT	EQU  $
	MOV  R5,R5		; SET RETURN STATUS
	JNE  DCSTA1
	MOV  @FACIM$,@FACIM$
DCSTA1	EQU  $
	B    *R11
*
*  CDCMP$ - COMPLEX COMPARE.  THIS COMPARE JUST COMPARES THE REAL
*	    VALUES, PROBABLY NOT THE RIGHT THING TO DO, BUT ALL
*	    I CAN THINK OF FOR NOW.
*
CDCMP$	EQU  $
	MOV  R2,R0		; SAVE R2 START
	AI   R0,8		; SAVE START TO 2ND VALUE
	C    R5,*R2+		; CHECK FIRST VALUE
	JNE  DCCMPR
	MOV  R5,R5		; CHECK FIRST WORD OF COMPARE
	JEQ  DCCMP2
	JGT  DCCMP1		; IF >0, THEN DO NORMAL COMPARE
	C    *R2+,R6		; ELSE, MUST REVERSE COMPARE
	JNE  DCCMPR		; IF NOT EQUAL, EXIT
	C    *R2+,R7
	JNE  DCCMPR
	C    *R2+,R8
	JMP  DCCMPR
DCCMP1	EQU  $
	C    R6,*R2+		; CHECK SECOND VALUE
	JNE  DCCMPR
	C    R7,*R2+
	JNE  DCCMPR
	C    R8,*R2+
	JMP  DCCMPR
DCCMP2	EQU  $
	DECT R2
	C    R5,*R2		; RESET EQUAL STATUS
DCCMPR	EQU  $
	STST R4			; SAVE STATUS
	MOV  R0,R2		; GET OFFSET TO IMAGINARY PORTION
	LI   R1,FACIM$		; GET OFFSET TO IMAGINARY FAC
	C    *R1+,*R2+		; CHECK FIRST VALUE
	JNE  ICCMPR
	DECT R1
	C    *R1,*R1+		; CHECK FIRST WORD OF COMPARE
	JEQ  ICCMP2
	JGT  ICCMP1		; IF >0, THEN DO NORMAL COMPARE
	C    *R2+,*R1+		; ELSE, MUST REVERSE COMPARE
	JNE  ICCMPR		; IF NOT EQUAL, EXIT
	C    *R2+,*R1+
	JNE  ICCMPR
	C    *R2,*R1
	JMP  ICCMPR
ICCMP1	EQU  $
	C    *R1+,*R2+		; CHECK SECOND VALUE
	JNE  ICCMPR
	C    *R1+,*R2+
	JNE  ICCMPR
	C    *R1,*R2
	JMP  ICCMPR
ICCMP2	EQU  $
	DECT R1
	DECT R2
	C    *R1,*R2		; RESET EQUAL STATUS
ICCMPR	EQU  $
	STST R2			; SAVE IMAGINARY STATUS
	INV  R2
	SZC  R2,R4		; TO GET FINAL STATUS (R2 & R4)
*
*  EXTRACT EQUAL BIT AND ARITHMETIC GREATER THAN BIT
*
	MOV  R4,R2		; SAVE STATUS BYTE
	ANDI R2,>2000		; EXTRACT EQUAL BIT
	JNE  ICMPEQ		; IT IS EQUAL
*
	ANDI R2,>4000		; EXTRACT ARITHMETIC GREATER THEN
	JNE  ICMPGT		; BRIF GREATER THEN
*
	SETO R4			; ELSE, SET LESS THAN
	JMP  ICMPDN
*
ICMPEQ	EQU  $
	CLR  R4			; SET EQUAL
	JMP  ICMPDN
*
ICMPGT	EQU  $
	LI   R4,1		; SET GREATER THAN
*
ICMPDN	EQU  $
	MOV  R4,R4		; SET STATUS
	B    *R11		; & RETURN
*
*  ADD TOGETHER TWO COMPLEX *8 NUMBERS.  THIS IS DONE BY THE
*  FORMULA:      (a + c ) + i( b + d )
*
CDADD$	EQU  $
	LI   R0,FADD		; SET ADD
	JMP  DOUCOM
*
*  SUBTRACT TWO COMPLEX *8 NUMBERS.   THIS IS DONE BY THE FORMULA:
*		( a - c ) + i( b - d )
*
CDSUB$	EQU  $
	LI   R0,FSUB		; SET SUBTRACT
*
*  COMPLEX *16 COMMON LOAD.  SET FAC & ARG
*
DOUCOM	EQU  $
	MOV  R2,R9		; SAVE POINTER TO 2ND ARG
	MOV  R0,@XMLFUN		; SAVE FUNCTION CODE
	LI   R1,ARG
	MOV  R5,*R1+		; SET FAC
	MOV  R6,*R1+
	MOV  R7,*R1+
	MOV  R8,*R1
	LI   R1,FAC
	MOV  *R9+,*R1+		; SET ARG
	MOV  *R9+,*R1+
	MOV  *R9+,*R1+
	MOV  *R9+,*R1+
*
*  FOR GENEVE, CALL THE MATH XOP TO PERFORM THE ADD/SUBTRACT
*
	IF   GENEVE
	MOV  R3,R12		; SAVE MY BASE REGISTER
	LI   R1,RESULT
	LI   R2,FAC
	LI   R3,ARG
	XOP  @DMATXP,0		; DO IT
	MOV  R12,R3		; RESTORE MY BASE REGISTER
	LI   R2,RESULT		; SET RESULT
	MOV  *R2+,R5
	MOV  *R2+,R6
	MOV  *R2+,R7
	MOV  *R2+,R8
	ELSE
*
*  TI-99 VERSION OF RADIX 100, CALL THE CONSOLE F.P. ROUTINES
*
	MOV  R0,@XMLFU1		; SET 2ND CALL TO CONSOLE LINKAGE
	BLWP @CXMLLN
XMLFUN	DATA 0			; FUNCTION CODE (DYNAMIC)
	LI   R2,FAC
	MOV  *R2+,R5
	MOV  *R2+,R6
	MOV  *R2+,R7
	MOV  *R2+,R8
	ENDIF
*
*  REAL PART HAS BEEN ADDED (OR SUBTRACTED).  NOW PERFORM THE SAME
*  OPERATION ON THE IMAGINARY PORTION.
*
	LI   R1,ARG
	LI   R4,FACIM$
	MOV  *R4+,*R1+		; MOVE IMAGINARY PORTION OF FAC
	MOV  *R4+,*R1+
	MOV  *R4+,*R1+
	MOV  *R4,*R1
*
	LI   R1,FAC		; MOVE IMAGINARY PORTION OF ARG
	MOV  *R9+,*R1+
	MOV  *R9+,*R1+
	MOV  *R9+,*R1+
	MOV  *R9,*R1
*
	IF   GENEVE
	MOV  R3,R12		; SAVE MY BASE REGISTER
	MOV  @XMLFUN,R0		; RESTORE FUNCTION CODE
	LI   R1,RESULT
	LI   R2,FAC
	LI   R3,ARG
	XOP  @DMATXP,0		; DO IT
	MOV  R12,R3
	LI   R2,RESULT		; SET RESULT
	ELSE
*
*  TI-99 VERSION OF RADIX 100, CALL THE CONSOLE F.P. ROUTINES
*
	BLWP @CXMLLN
XMLFU1	DATA 0			; FUNCTION CODE (DYNAMIC)
	LI   R2,FAC
	ENDIF
	LI   R1,FACIM$
	MOV  *R2+,*R1+
	MOV  *R2+,*R1+
	MOV  *R2+,*R1+
	MOV  *R2,*R1
	B    @DCSTAT		; GO SET STATUS
*
*  DIMAG - CONVERT COMPLEX *16 PORTION TO REAL PART
*
DIMAG	EQU  $
	DATA -1			; 1 ARGUMENT
	DATA TEMPS
	MOV  @AARG,R2		; GET ARGUMENT ADDRESS
	AI   R2,8		; SKIP REAL PART
	MOV  *R2+,R5		; GET IMAGINARY PART
	MOV  *R2+,R6
	MOV  *R2+,R7
	MOV  *R2+,R8
	MOV  @TEMPS,R3		; GET BASE
	MOV  R5,R5		; SET STATUS
	B    *R11
*
*  DCMPLX - BUILD A COMPLEX *16 FROM TWO REAL *8
*
DCMPLX	EQU  $
	DATA -2			; 2 ARGUMENTS
	DATA TEMPS
	MOV  @AARG,R2		; GET 1ST ARGUMENT
	MOV  *R2+,R5
	MOV  *R2+,R6
	MOV  *R2+,R7
	MOV  *R2,R8
*
	MOV  @AARG1,R2		; GET 2ND ARGUMENT
	LI   R4,FACIM$		; GET IMAGINARY PORTION
	MOV  *R2+,*R4+
	MOV  *R2+,*R4+
	MOV  *R2+,*R4+
	MOV  *R2,*R4
*
	MOV  @TEMPS,R3		; RESTORE BASE
	MOV  R5,R5
	B    *R11
*
TEMPS	BSS  4
AARG	BSS  2
AARG1	BSS  2
*
	IF   GENEVE
DMATXP	DATA MATXOP		; MATH XOP LIBRARY NUMBER
FAC	DATA 0,0,0,0		; MY FAC
ARG	DATA 0,0,0,0		; MY ARG
RESULT	DATA 0,0,0,0		; MY RESULT
XMLFUN	DATA 0			; FUNCTION CODE
	ENDIF
FACIM$	DATA 0,0,0,0		; IMAGINARY PORTION OF FAC
	END
