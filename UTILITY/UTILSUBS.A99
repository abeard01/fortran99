	TITL 'SAVE INTERFACE FOR TI-99/4A'
	IDT  'PROGIN'
*
*  PROGIN - PROGRAM FILE INTERFACE FOR TI-99/4A
*
*  Update History:
*
*    v4.4       1-Sep-89        Version 4.4 baseline
*
*  This module contains two subroutines which can be used to
*  save/restore program type of file images.  There are two
*  entry points:
*
*     CALL SAVE ( FILE_NAME, VDP_ADDRESS, LENGTH, ERROR )
*
*  where:
*
*     FILE_NAME:  is the file name to save
*
*     ADDRESS:    is the VDP address where to start storing
*
*     LENGTH :    is the length of the image to save
*
*     ERROR  :    is any error code returned
*
	DEF  SAVE
*
*  EQUATES:
*
GENEVE  EQU  0
*
	UNL
	COPY "EQUATES:FORTEX.EQ9"
	LIST
*
SAVE    EQU  $
	DATA -4		 	4 ARGUMENTS
	DATA TEMPS	      	TEMP SAVE AREA
	MOV  @LENGTH,R5
	MOV  *R5,@NOBYTE	SET # BYTES TO SAVE/RESTORE
	MOV  @ADDRES,R5
	MOV  *R5,@VADRES	VDP ADDRESS
	MOV  @FILENM,R5	 	GET FILE NAME START
	LI   R6,NMLENG+1	TO PAB SHELL
	CLR  R4
MOVLOP  EQU  $
	MOVB *R5+,R3
	CB   R3,@BLANK	  	IS IT A TERMINATOR?
	JEQ  MOVEND	     	BRIF YES, DONE
	MOVB R3,*R6+	    	ELSE, MOVE TO END
	INC  R4		 	INCR # OF BYTES MOVED
	CI   R4,40	      	TOO MANY CHARS?
	JNE  MOVLOP
MOVEND  EQU  $
	MOV  R4,R4	      	ANY BYTES MOVED?
	JNE  MOVEN1	     	BRIF YES, I'M OK
	LI   R0,1	       	ELSE, SET ERROR 1, BAD DEVICE NAME
	JMP  NOERR1	     	AND RETURN WITH ERROR
MOVEN1  EQU  $
	SWPB R4
	MOVB R4,@NMLENG	 	SAVE FILE NAME LENGTH
	LI   R0,PATPTR	  	WRITE PAB TO RAM
	LI   R1,OPCODE
	LI   R2,>30
	BLWP @CVMBW$
	AI   R0,9
	MOV  R0,@DSRPTR	 	SAVE DSR POINTER
	BLWP @CDSRL$	    	GO DO IT
	DATA 8
	JNE  NOERR
	SWPB R0
	ANDI R0,>00FF
	INC  R0		 	FORTRAN OFFSET
	JMP  NOERR1
NOERR   EQU  $
	CLR  R0
NOERR1  EQU  $
	MOV  @AERROR,R1
	MOV  R0,*R1	     	SAVE ERROR CODE
	MOV  @TEMPS,R3
	MOV  @TEMPS+2,R11
	B    *R11
*
TEMPS	DATA 0	  		R3 SAVE
	DATA 0	  		RETURN LEVEL SAVE
AVDP	EQU  $
FILENM	DATA 0	  		FILE NAME
ACPU	EQU  $
ADDRES	DATA 0	  		ADDRESS IN CPU RAM
ABYTES	EQU  $
LENGTH	DATA 0	  		LENGTH TO SAVE/RESTORE
AERROR	DATA 0	  		RETURNED ERROR STATUS
*
OPCODE	DATA >0600  		0 PAB OPCODE & FLAGS
VADRES	DATA 0		    	2 VDP RAM AREA START
	DATA 0	  		4 UNUSED
NOBYTE  DATA 0	  		6 BYTES TO BE SAVED/LOADED
	BYTE 0	  		8 SCREEN OFFSET
NMLENG  BYTE 0	  		9 FILE NAME LENGTH
	BSS  40
BLANK   BYTE >20		ASCII BLANK
	EVEN
*
*  AVMBW - SAME AS VMBW EXCEPT 2ND ARGUMENT IS ADDRESS OF ADDRESS OF CPU AREA,
*	   NOT JUST ADDRESS.
*
	DEF  AVMBW
*
*  MAIN ENTRY:
*
AVMBW	EQU  $			VDP MULTI-BYTE WRITE
	DATA -3			3 ARGUMENTS
	DATA TEMPS
	MOV  @AVDP,R0		GET VDP ADDRESS
	MOV  *R0,R0
	MOV  @ACPU,R1		GET CPU RAM OFFSET
	MOV  *R1,R1
	MOV  @ABYTES,R6
	MOV  *R6,R2
	BLWP @CVMBW$		ELSE, WRITE IT
	MOV  @TEMPS,R3		RESTORE R3
	B    *R11		WHEN DONE, RETURN
	END
