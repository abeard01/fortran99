	TITL 'FORTRAN BOOT ROUTINE'
*
*************************
*			*
*	BOOT		*
*			*
*************************
*
*  THIS IS A STAND ALONE ROUTINE WHICH BOOTS THE FORTRAN MENU IMAGE.
*
*  IT IS LOADED INTO LOW CORE @3500 AND DOES THE FOLLOWING:
*
*  1. READS IN THE UTIL1 IMAGE AT @A000
*  2. COPIES THE UTIL1 IMAGE DOWN TO >2000
*  3. BRANCHES TO >2000 AND STARTS EXECUTING THE MENU
*
*  UPDATE HISTORY:
*
*     ????           Initial Release
*     27-Dec-89      Rewritten for version 4.4 of 99 FORTRAN
*     15-Mar-90      Enlarge VDP area for load, MENU got larger then
*                    >1000 bytes.
*
	DEF  BOOT
*
*  EQUATES
*
VDPRD	EQU  >8800		VDP READ DATA
VDPWA	EQU  >8C00		VDP WRITE ADDRESS
VDPWD	EQU  >8C02		VDP WRITE DATA
GPLWS	EQU  >83E0		GPL WORKSPACE
DSRPTR	EQU  >8356		DEVICE SERVICE ROUTINE POINTER
*
*WSP	EQU  >8300		MY WORKSPACE
MENU	EQU  >2000		MENU START
MENULN	EQU  >1000		LENGTH OF THE MENU IMAGE
PABSTA	EQU  >0F80		VDP RAM PAB START
VDPSTA	EQU  >1000	 	VDP RAM BUFFER START
STATUS 	EQU  >837C	 	GPL STATUS BYTE
*DSRWRK	EQU  >8320	 	DSR WORKING CELLS
*
*  ENTRY:
*
	AORG >3500
BOOT	EQU  $
	LIMI 0			DISABLE INTERRUPTS
	LWPI WSP	   	GET MY REGISTERS
*
	LI   R0,PABSTA		PAB START
	LI   R1,PDATA		CPU RAM IMAGE
	LI   R2,>30
	BLWP @VMBW	 	WRITE IT
*
	AI   R0,9
	MOV  R0,@DSRPTR   	SET POINTER
	CLR  R0
	BLWP @DSRLNK		READ SEGMENT
	DATA 8
*
	LI   R0,VDPSTA+6
	LI   R1,MENU
	LI   R2,MENULN	 	READ MENU OBJECT
	LIMI 0
	SWPB R0			READ EACH BYTE (EMULATE VMBR)
	MOVB R0,@VDPWD
	SWPB R0
	MOVB R0,@VDPWD
	NOP
*
MOVNXT	EQU  $
	MOVB @VDPRD,*R1+  	MOVE A BYTE INTO CPU RAM
	NOP			GIVE SOME TIME
	DEC  R2
	JNE  MOVNXT
	CLR  R0
	MOVB R0,@STATUS
	B    @MENU	 	EXECUTE MENU
*
*  THE FOLLOWING ROUTINES EMULATE DSRLNK & VMBW WHEN THE
*  UTILITIES AREN'T THERE.
*
VSBR   	EQU  $
	DATA WORKS1
	DATA BVSBR
*
VMBW   	EQU  $
	DATA WORKS1
	DATA BVMBW
*
DSRLNK 	EQU  $
	DATA WORKS2
	DATA BDSRLN
*
*  OTHER DATA CELLS
*
PERIOD TEXT '.'
IMHERE BYTE >AA
SETVAL DATA >2000
*
*  VSBR - VDP SINGLE BYTE READ
*
BVSBR  	EQU  $
	BL   @VSETUR
	MOVB @VDPRD,@2(R13)
	RTWP
*
*  VMBW - VDP MULTI BYTE WRITE
*
BVMBW  	EQU  $
	BL   @VSETUW
MBWNXT 	EQU  $		WRITE UNTIL BYTE COUNT EXHAUSTED
	MOVB *R1+,@VDPWA
	DEC  R2
	JNE  MBWNXT
	RTWP
*
*  VSETUR - SETUP FOR VDP READ
*  VSETUW - SETUP FOR VDP WRITE
*
VSETUR 	EQU  $
	CLR  R1
	JMP  VSETUC
VSETUW 	EQU  $
	LI   R1,>4000
VSETUC 	EQU  $
	LIMI 0
	MOV  *R13,R2
	MOVB @WORKS1+5,@>8C02
	SOC  R1,R2
	MOVB R2,@>8C02
	MOV  @2(R13),R1
	MOV  @4(R13),R2
	B    *R11
*
*  DSRLNK - LINK TO DEVICE SERVICE ROUTINE
*
BDSRLN 	EQU  $
	MOV  *R14+,R5
	SZCB @SETVAL,R15  	RESET EQUAL STATUS
	MOV  @DSRPTR,R0
	MOV  R0,R9
	AI   R9,>FFF8		GET START OF PAB
	BLWP @VSBR
	MOVB R1,R3
	SRL  R3,8
	SETO R4
	LI   R2,DSRWRK		GET PERIPHERAL NAME IN CPU RAM
READNX 	EQU  $
	INC  R0
	INC  R4
	C    R4,R3
	JEQ  READDN
	BLWP @VSBR	 	READ A CHARACTER
	MOVB R1,*R2+		& SAVE
	CB   R1,@PERIOD   	IS IT A PERIOD ?
	JNE  READNX
READDN 	EQU  $			HAVE DSR NAME IN WORKSPACE
	MOV  R4,R4
	JEQ  RETBAD		SET BAD RETURN IF NO NAME
	CI   R4,7	 	 > 7 CHARACTERS ?
	JGT  RETBAD		BRIF YES, BAD RETURN
	CLR  @>83D0
	MOV  R4,@>8354
	MOV  R4,@DSRSV1
	INC  R4
	A    R4,@>8356
	MOV  @>8356,@DSRSV2
	LIMI 0
	LWPI GPLWS		GET GRAPHICS WORKSPACE
	CLR  R1
	LI   R12,>0F00
NXTDSR	EQU  $			LOOP THROUGH DSR'S
	MOV  R12,R12
	JEQ  SKIPSE
	SBZ  0
SKIPSE	EQU  $
	AI   R12,>0100		TRY NEXT DSR
	CLR  @>83D0
	CI   R12,>2000
	JEQ  RETBA0
	MOV  R12,@>83D0
	SBO  0			MAP IN DSR
	LI   R2,>4000
	CB   *R2,@IMHERE  	IS DSR HERE ?
	JNE  NXTDSR		BRIF NO
	A    @WORKS2+10,R2
	JMP  SKISBO
SETSBO 	EQU  $
	MOV  @>83D2,R2
	SBO  0
SKISBO 	EQU  $
	MOV  *R2,R2
	JEQ  NXTDSR
	MOV  R2,@>83D2
	INCT R2
	MOV  *R2+,R9
	MOVB @>8355,R5
	JEQ  FNDDSR
	CB   R5,*R2+		CHECK NAME
	JNE  SETSBO		NOT THIS ONE
	SRL  R5,8
	LI   R6,DSRWRK
TRYCHA 	EQU  $
	CB   *R6+,*R2+
	JNE  SETSBO		NOT HERE
	DEC  R5			ANY MORE TO TRY ?
	JNE  TRYCHA
FNDDSR 	EQU  $
	INC  R1			FOUND IT
	MOV  R1,@DSRSV3   	SAVE POINTER
	MOV  R9,@DSRSV0
	MOV  R12,@DSRSVV
	BL   *R9	   	EXECUTE DSR
	JMP  SETSBO
	SBZ  0
	LWPI WORKS2
	MOV  R9,R0
	BLWP @VSBR
	SRL  R1,13	 	ANY ERROR ?
	JNE  RETBA1		BRIF YES
	RTWP			ELSE, RETURN
RETBA0 	EQU  $
	LWPI WORKS2
RETBAD 	EQU  $
	CLR  R1
RETBA1 	EQU  $
	SWPB R1
	MOVB R1,*R13
	SOCB @SETVAL,R15  	SET EQUAL BIT SAYING BAD
	RTWP			RETURN
*
PDATA  	EQU  $
	DATA >0500
	DATA VDPSTA		VDP RAM START
	DATA 0
	DATA MENULN+6		# BYTES TO LOAD
	BYTE 0,18
	TEXT 'DSK.FORTCOMP.UTIL1'
	TEXT 'PATCH AREA IS HERE TO PATCH IN YOUR OWN NAME'
	EVEN
*
*  WORKSPACES
*
WORKS1	EQU  $
	BSS  6
WORKS2	EQU  $
	BSS  32
WORKS3	EQU  $
	BSS  32
WSP	EQU  $
	BSS  32
*
*  DSR SAVE CELLS
*
DSRSVV	BSS  2
DSRSV0	BSS  2
DSRSV1	BSS  2
DSRSV2	BSS  2
DSRSV3	BSS  2
*
DSRWRK	BSS  8
	END
