	TITL 'FORTRAN SYSTEM MENU'
	IDT  'MENU'
*
*  The menu executive contains:
*
*  1. The FORTRAN MENU display and execution logic
*  2. Utility routines for all programs
*  3. Initialization and I/O Control
*
*  Change History:
*
*  03-Apr-87   Version 2.1.2 updated version number (menua)
*  16-Apr-87   Version 2.1.3 updated version number (menua)
*  19-Apr-87   Changed compiler load for new expanded length of FORTCD
*  12-Jun-87    a) Version 3.0, converted to cross assembler, and removed
*	           the CIF routine (moved to exctime)
*	        b) Added the preferences interface area
*	        c) Forced 3 files to be opened on every entrance to MENU
*		d) Added load & run menu entry for function
*		e) Reorganized the SAVE/LOAD for (d), and for future CALL
*		   program entrance.
*		f) Fixed the darn call to FILES, changed DSRLNK subr call
*		   to >0A (from >10).
*		g) Rearranged MENU screen for clarity
*		h) Made a RAMDISK (type RD) a DISK device type
*		i) redid screen output (for speed)
*  10-Oct-87    a) Moved workspaces 1 & 2 internal to this routine, to
*		   see if Geneve can be better behaved.
*		b) Moved some variables from PAD to internal
*		c) Removed "write EOF" function code from I/O
*  18-Oct-87    a) Fixed "Elmer's" no LF on print problem
*  02-Feb-89  4.2   Version 4.2
*  22-May-89        Implement New 'blank line' command in screen output.
*  04-Jan-90  4.43  Change copyright year
*
	TITL 'COMMON VARIABLE POOL & ENTRY POINTS'
*
	DEF  START
	DEF  SEND
*
*  SYSTEM EQUATES:
*
GENEVE	EQU  0			; TI-99 GPL ONLY
	UNL
	COPY "EQUATES:FORTEX.EQ9"
	COPY "EQUATES:VID.EQ9"
	LIST
*
*  MACROS
*
CURSOR	MACRO
	BYTE >1B,>3D,%1+>20,%2+>20
	ENDM
*				GENERATE AN IN PLACE BLANK LINE
BLALIN	MACRO
	BYTE >1B,>FE
	ENDM
*
*  EQUATES
*
MODSTA	EQU  >0C00		FREE AREA - VDP RAM
PABSTA	EQU  >0800		PAB START (FOR MY OWN)
*
*  LOW CORE FIXED POINTERS & DATA CELLS
*
START   EQU  $
	B    @BMENUI	00 INITIAL ENTRY (FROM E/A)
SETMOD	EQU  $
	DATA WORKS3	04 SET MODE
	DATA ESETMO	06
*
FILEOP	DATA >3300	08 # OF FILES TO OPEN
BLANK	DATA >2020	0A TWO BLANKS
XON	BYTE >13	0C SCROLL ON (XON)
XOFF	BYTE >11	0D SCROLL OFF (XOFF)
XTAB27	DATA XMLRTN	0E GPL RETURN
PERIOD  TEXT '.'        10
IMHERE  BYTE >AA	11	I'M HERE WORD
COUNTT	DATA -6		12 CLOCK COUNTDOWN (1/10 SECOND)
SETVAL	DATA >2000	14 SET VALUE
K100  	DATA 100	16 DECIMAL 100
KX100	DATA >0100	18 A BYTE 1
*
COUNTD	DATA 400	1A COUNTDOWN FOR CURSOR (geneve=400, ti=200)
MENSIZ	DATA SEND-START	1C ACTUAL SIZE OF MENU IMAGE
CHARSE	DATA 1		1E RESTORE CHARACTER SET (1) OR NOT (0)
*
	DATA 0		20 DEBUGGER TRANSFER ADDRESS
DSET40	DATA GRAPH1     22 32(2)/40(0)/80(1) COLUMN FLAG
BREAKL  BL   *R0        24 GO TO PROGRAM
        JMP  MENU       26 WHEN DONE, RE-INITIALIZE
*
DCLOCK1	DATA 0		28 DOUBLE WORD CLOCK 1
DCLOCK2	DATA 0		2A DOUBLE WORD CLOCK 2
*
DMENVDP	DATA 0		2C POINTER TO VDP END
DIOTBU	DATA 0		2E I/O BUFFER ADDRESS
DCRTXY	DATA 0		30 CURRENT SCREEN CURSOR ADDRESS
	DATA NOIOTA	32 NUMBER OF I/O TABLES GENNED
	DATA RESFIL     34 POINTER TO RESTORE FILE NAME
	DATA 56		36 NUMBER LINES PER PRINTED PAGE (56)
DPRINT	DATA -1		38 HOLD ON PRINT FLAG
	DATA 132	3A LENGTH OF LINE
*
*  SUBROUTINE ENTRY POINTS:
*
XMLLNK	EQU  $		3C CONSOLE LINKAGE
	DATA WORKS1
	DATA BXMLLN
KSCAN	EQU  $		40 KEY SCAN ENTRY
	DATA WORKS1
	DATA BKSCAN
VSBW	EQU  $		44 VDP SINGLE BYTE WRITE ENTRY
	DATA WORKS1
	DATA BVSBW
VMBW	EQU  $		48 VDP MULTI BYTE WRITE ENTRY
	DATA WORKS1
	DATA BVMBW
VSBR	EQU  $		4C VDP SINGLE BYTE READ ENTRY
	DATA WORKS1
	DATA BVSBR
VMBR	EQU  $		50 VDP MULTI BYTE WRITE ENTRY
	DATA WORKS1
	DATA BVMBR
VWTR	EQU  $		54 VDP WRITE REGISTERS ENTRY
	DATA WORKS1
	DATA BVWTR
DSRLNK	EQU  $		58 DEVICE SERVICE ROUTINE ENTRY
	DATA WORKS2
	DATA BDSRLN
*
VRFR	EQU  $		5C READ VDP STORED REGISTERS
	DATA WORKS1
	DATA BVRFR
MENU	EQU  $
	B    @ENTRY	60 MENU ENTRY
SCROUT	EQU  $		64 SCREEN OUTPUT
	DATA WORKS2
	DATA ESCROU
SCRIN	EQU  $		68 SCREEN INPUT
	DATA WORKS2
	DATA ESCRIN
EWAIT	EQU  $		6A ENTRY INTO WAIT
	DATA WORKS3
	DATA WAIT
EOPFIL	EQU  $		6C ENTRY INTO OPFILE
	DATA WORKS3
	DATA OPFILE
EIO	EQU  $		6E ENTRY INTO I/O PROCESSOR
	DATA WORKS3
	DATA IO
EFILES	EQU  $
	DATA RESFIL	78 I/O RE-MAP
	DATA FILES
FSCROU	EQU  $		7C FORTRAN SCREEN OUTPUT ROUTINE
	DATA WORKS2
	DATA EFSCRO
TSCROU	EQU  $ 		80 TEMP SCREEN OUTPUT ROUTINE
	DATA WORKS2
	DATA ETSCRO
*
GPLLNK	DATA GLNKWS 	84    Set up BLWP Vectors
	DATA GLINK1 	86
*
CALPRO	B    @ECALPR	88    CALL PROGRAM ENTRY
*
*  The following items are specifically for the PREFERENCES program
*
	DATA IOTABL	8C I/O TABLES ADDRESS
	DATA 6		8E EXECUTION TIME DEVICE WILDCARD BINDING
RES40F  DATA GRAPH1	90 DEFAULT 32 (2) COL OR 40 (0) COL OR 80 (1) COL
DCOLDEF	DATA >2100      92 DEFAULT COLOR DEFINITION (GREEN ON BLACK)
BLOCKC  DATA >5F00      94 DEFAULT CHARACTER FOR CURSOR
DEFFIL  DATA >3300      96 DEFAULT # OF FILES TO OPEN
ENCHAR  DATA >0A00      98 CHARACTERS (UP TO 2) TO PUT AT END OF EVERY LINE
TERCHA  DATA 0          9A TERMINATING PRINTER CHARACTER
PRTLBL	DATA 9		9C PRINTER DEFAULT LABEL
STAADR	DATA 0		9E START ADDRESS OF PROGRAM
PRTADD	DATA PRTOPE	A0 PRINTER NAME ADDRESS
LASTAS	DATA 0		A2 LAST OPTION RAN
JUSBOT	DATA 0		A4 NORMAL MENU (0) OR AUTOBOOT (1)
PBOTSH	DATA DBOTSH	A6 BOOT DISK SHELL NAME
MEMMAP	DATA 2		A8 MEMORY MAP OPTION (0=E/A; 1=MINI; 2=SUPER)
TABADR	DATA SCRMO0	AA ADDRESS OF VDP LOCATIONS TABLE
*
*  END FIXED LOCATION CELLS
*
*
LIBSHE	EQU  $			NAME OF LIBRARY DISK FOR LINKER
DBOTSH	EQU  $			NAME OF BOOT DISK FOR MENU
	TEXT 'DSK.FORTCOMP.   '
	EVEN
PRTOPE  TEXT '                          '
	EVEN
*
*  TABLE OF LOCATIONS TO RESTORE ON RESTART
*
CELRES	EQU  $
	DATA SCROUT+2,ESCROU
	DATA SCRIN+2,ESCRIN
	DATA TSCROU+2,ETSCRO
	DATA FSCROU+2,EFSCRO
	DATA COUNTT
COUNTS	DATA -6
	DATA USERIN,CLKINT
	DATA DPRINT,-1
	DATA 0
*
*  TABLE OF LOCATIONS TO ZERO ON RESTART
*
	DATA DEBUGT
	DATA CLOCK1
	DATA CLOCK2
	DATA 0
*
*
* TEXT MESSAGES (FOR SCREEN)
*
*	copy "version.a99"
HELLO	EQU  $
	BYTE >0C
	CURSOR 1,11
	TEXT '99 FORTRAN'
	CURSOR 24,4
*	BYTE >1F
	TEXT '(c) 1990 LGMA V4.4'
	BYTE >FF
*
HELL1D	EQU  $			CLEAR SCREEN
	BYTE >0C,>FF
*
LOADFI	EQU  $
	CURSOR 4,1
	TEXT 'File to Load?'
	CURSOR 5,1
	BLALIN
	BYTE >FF
*				MAIN MENU
HELL2	EQU  $
	CURSOR 7,3
	TEXT '1 Edit'
	CURSOR 9,3
	TEXT '2 Compile'
	CURSOR 11,3
	TEXT '3 Link'
	CURSOR 13,3
	TEXT '4 Run'
	CURSOR 15,3
	TEXT '5 Run/Debug'
	CURSOR 7,19
	TEXT '6 Librarian'
	CURSOR 9,19
	TEXT '7 Load'
	CURSOR 11,19
	TEXT '8 USER'
	CURSOR 13,19
        TEXT '9 Utilities'
	CURSOR 21,10
	BYTE >FF
	EVEN
*				WAIT FOR I/O LIST
PLSWAI	EQU  $
	CURSOR 13,3
	TEXT 'Please Wait'
	BYTE >FF
*				USER REQUESTED WAIT LIST
CARRN   EQU  $
REQCON	BYTE >0D,>0D
	BLALIN
	TEXT 'Press ENTER to Continue'
	BYTE >0D,>FF
*				I/O ERROR 
IOERR	BYTE >0D
	TEXT 'I/O Error'
	BYTE >0D
	BYTE >FF
*				CAN'T LOAD DEBUGGER
NOROOM	BYTE >0D
	TEXT 'No Room/Debug'
	BYTE >FF
*				Call Program Failure
NOMAKI	BYTE >0D
	TEXT 'Prog Load Err'
*
BLNKIT	BYTE >FE		BLANK A LINE ON THE SCREEN
	EVEN
*
*  DEFAULT DISK NAME FOR BOOT DISK LOADS
*
COMPDI  EQU  $
	TEXT 'FORT4A'
B1	BYTE >01
	EVEN
*
*  PAB FOR SET FILES ROUTINE
*
FILPAB	EQU  $
	DATA >C801
PAFILE	DATA >30B6
	BYTE 0,0,0,0,0
	BYTE 5
	TEXT 'FILES'
	EVEN
*
*  END OF FILE MARKER
*
BEOD	EQU  $
	TEXT '>EOD'
	EVEN
*
*  SPECIAL CLOSE FILES COMMAND STACK
*
ALCLOS	EQU  $
	DATA >00FE		CLOSE FILE
	DATA 0			DYNAMIC FILE #
*
*  PARAMETERS FOR 32/40/MU/80 MODES (MUST BE CONTIGOUS)
*
ASCRMO	EQU  $
	DATA SCRMO0		MODE 0 = TEXT 1
	DATA SCRMO1		MODE 1 = TEXT 2
	DATA SCRMO3		MODE 2 = MULTICOLOR
	DATA SCRMO3		MODE 3 = GRAPHICS
*
*  SCREEN SETTINGS FOR MODE 0 (40 COLUMN)
*
SCRMO0	EQU  $
	DATA 40	   		00 40 CHARS/LINE
	DATA 40*24		02 END OF SCREEN ADDRESS
*
	DATA >0000		04 COLOR TABLE START (NONE)
	DATA >0800		06 PATTERN TABLE
	DATA >0000		08 SCREEN IMAGE TABLE
	DATA >0000		0A SPRITE ATTRIBUTE TABLE
	DATA >0000		0C SPRITE PATTERN TABLE
	DATA >0000		0E SPRITE MOTION TABLE
*
	DATA >00F0		10 WTR 0,1
	DATA >000E		12     2,3
	DATA >0106		14     4,5
	DATA >0000		16     6
*
*  SCREEN SETTINGS FOR MODE 1 (80 COLUMNS)
*
SCRMO1	EQU  $
	DATA 80			00 80 CHARS/LINE
	DATA 80*24		02 END OF SCREEN ADDRESS
*
	DATA >1000		04 COLOR TABLE START
	DATA >0800		06 PATTERN TABLE
	DATA >0000		08 SCREEN IMAGE TABLE
	DATA >0000		0A SPRITE ATTRIBUTE TABLE
	DATA >0000		0C SPRITE PATTERN TABLE
	DATA >0000		0E SPRITE MOTION TABLE
*
	DATA >04F0		10 WTR 0,1
	DATA >0340		12     2,3
	DATA >0100		14     4,5
	DATA >0108		16     6,8
	DATA >0000		18     9,10
*
*  SCREEN SETTINGS FOR MODE 3 (GRAPHICS)
*
SCRMO3	EQU  $
	DATA 32			00 32 CHARS/LINE
	DATA 32*24		02 END OF SCREEN ADDRESS
*
	DATA >0380		04 COLOR TABLE START
	DATA >0800		06 PATTERN TABLE START
	DATA >0000		08 SCREEN IMAGE TABLE
	DATA >0300		0A SPRITE ATTRIBUTE TABLE
	DATA >0400		0C SPRITE PATTERN TABLE
	DATA >0780		0E SPRITE MOTION TABLE
*
	DATA >00E0		10 WTR 0,1
	DATA >000E		12     2,3
	DATA >0106		14     4,5
	DATA >0000		16     6
*
*  FOLLOWING WORD CONTAINS A BIT FOR EACH MENU ENTRY, AND SAYS WHETHER
*  TO LOAD THE FORTRAN RUNTIME IMAGE (FORT44A) AFTER LOADING REST OF
*  FILE OR NOT.
*
*				 1    56  89
LOAFLA	DATA >46C0		0100 0110 1100 0000
RUNTBY	TEXT '4A'		RUNTIME IMAGE LAST TWO BYTES
*
*  COPYRIGHT TEXT CHARACTER
*
*COPYRI	EQU  $
*	DATA >3C42,>BDB1,>B1BD,>423C
*
*  RESTORE PAB LIST OF FILE ITEMS
*
RESLIS	EQU  $
	DATA >0500,MODSTA,>2000
*
	TITL 'INITIAL ENTRY'
	PAGE
*
*  BMENUI:  CLEAR MY DATA AREA AND RESTART ENTRY
*
BMENUI	EQU  $
	LWPI WSP		LOAD MY WORKSPACE REGISTERS
	LI   R0,SEND
BMENUC	EQU  $
	CLR  *R0+		CLEAR A WORD
	CI   R0,ENDME1
	JNE  BMENUC
*
	SETO @LASTAS		RESET LAST TASK RAN
	JMP  ENTRY1
*
*  ENTRY : RE-ENTER PART OF MENU
*
ENTRY	EQU  $
	LWPI WSP
	BL   @CLOSAL		CLOSE ALL OPEN FILES
	ABS  @JUSBOT		WAS THIS A STANDALONE BOOT?
	JEQ  ENTRY1		BRIF NO
	B    @QUITIT		ELSE, QUIT
*
*   1. INITIALIZE SCREEN SETUP
*   2. DISPLAY WELCOME MESSAGE
*   3. SCREEN IS INITIALIZED FOR 32 OR 40 OR 80 CHARACTER MODE
*
ENTRY1	EQU  $
*
*  SET THE DEFAULT SCREEN MODE
*
	MOV  @RES40F,R1		GET DEFAULT SCREEN MODE
	BLWP @SETMOD		SET SCREEN MODE ACCORDING TO DEFINITION
*
* DO FIRST I/O. PUT UP HELLO MESSAGE
*
	ABS  @JUSBOT		AM I RUNNING STANDALONE?
	JNE  FORLDX		BRIF YES, GO START PROGRAM
*
	BLWP @TSCROU		SAY HELLO TO USER
	DATA HELLO
*
* GET OPTIONS ROUTINE
*
	BLWP @TSCROU
	DATA HELL2
*
* GET OPTION SELECTION
*
	LI   R3,1
	LI   R4,SELOPT
	BLWP @SCRIN
	JNE  ENTRY		BRIF REDO OR BACK
*
EXEOPT	EQU  $
	BLWP @TSCROU		CLEAR SCREEN & PUT TITLE
	DATA HELLO
*
EXEOP1  EQU  $
	LI   R2,DBOTSH		MOVE FROM ADDRESS (DSK.FORTCOMP.)
	LI   R3,RESFIL+1	MOVE TO ADDRESS (FILE NAME)
COMPLO  EQU  $
	CB   *R2,@BLANK		IS THIS THE END OF IT?
	JEQ  COMPEN		BRIF YES
	MOVB *R2+,*R3+		ELSE, MOVE A BYTE
	JMP  COMPLO
COMPEN  EQU  $			DSK.FORTCOMP. MOVED, NOW MOVE FILE NAME
	LI   R2,COMPDI
	MOVB *R2+,*R3+		MOVE IT
	MOVB *R2+,*R3+
	MOVB *R2+,*R3+
	MOVB *R2+,*R3+
	MOVB *R2+,*R3+
	MOV  R3,R9		SAVE POINTER TO LAST 2 CHARS OF FILE NAME
	MOVB @SELOPT+1,*R3+	MOVE NUMBER SELECTED
	MOVB *R2+,*R3		PLUS FINAL LETTER
	AI   R3,-RESFIL		DETERMINE BYTE COUNT
	SWPB R3
	MOVB R3,@RESFIL		SAVE IT
*	
	MOV  @SELOPT,R1		GET THE OPTION SELECTED AGAIN
	ANDI R1,>00FF		MASK LOW BYTE
	AI   R1,->0031		IS IT <1 ?
	JLT  ENTRY
	CI   R1,9	  	IS IT >10 ?
	JGT  ENTRY
	MOV  R1,@SELOPT
	CI   R1,6
	JNE  FORLD
	SETO @LASTAS		ZAP THE LAST THING I RAN
*
*  RESTORE A FILE
*
	BLWP @TSCROU		DISPLAY 'FILE TO LOAD' PROMPT
	DATA HELLO
*
	BLWP @TSCROU		GET THE FILE NAME TO LOAD
	DATA LOADFI
*
*  NOW GET THE FILE NAME TO LOAD, PUT IT IN THE PAB BUFFER
*
	LI   R3,40		40 CHARACTERS MAXIMUM
	LI   R4,RESFIL		FILE TO RESTORE
	BLWP @SCRIN		GET THE FILE NAME
	MOV  R0,R0		ANY ERROR?
	JNE  RETMEN		BRIF YES, JUST RETURN (AFTER WAIT)
*
	BLWP @TSCROU
	DATA PLSWAI		DISPLAY 'LOADING FILE' MESSAGE
*
	BL   @LOADSU		AND LOAD THE FILE VIA LOAD SUBR
	JEQ  RETMEN		BRIF NO
*
	BLWP @TSCROU		ELSE, DISPLAY ERROR
	DATA IOERR
*
RETMEN	EQU  $
	BLWP @EWAIT		WAIT TO RETURN
	JMP  ENTRY		RETURN
*
*  FORLD - FORTRAN LOAD, CLEAR SCREEN & ISSUE PLEASE WAIT
*
*  NOTE:  IN 80 COLUMN MODE, THE COMPILER MUST BE RELOADED EVERY TIME,
*	  SINCE THE 9938 CHIP USES VDP MEMORY CURRENTLY WHICH IS ALSO
*	  USED BY THE COMPILER.   OTHER ROUTINES SHOULD BE OK.
*
*         ALSO, RELOAD EVERY TIME A USER ROUTINE IS CALLED (FCTN 8)
*         SINCE IT IS POSSIBLE A USER ROUTINE COULDN'T RERUN (LIKE PR)
*
FORLD	EQU  $
	MOV  @SELOPT,R4		GET SELECTED OPTION
	CI   R4,7		IS IT THE USER ROUTINE (8)
	JEQ  RELOAD		BRIF YES
	CI   R5,TEXT2		IS IT 80 COLUMN MODE?
	JNE  FORLD0		BRIF NO
	MOV  @SELOPT,R5		GET CURRENT SELECTED OPTION
	CI   R4,1		IS THIS THE COMPILER?
	JEQ  RELOAD		BRIF YES, RELOAD IT
FORLD0	EQU  $
	C    @LASTAS,R4		IS THIS TASK THE SAME AS LAST?
	JEQ  FORLD1		BRIF YES, SKIP THE LOAD
RELOAD	EQU  $
	SETO @LASTAS		ZAP THE CURRENT PROGRAM
*
	BLWP @TSCROU		PLEASE WAIT
	DATA PLSWAI
*
	BL   @LOADSU		LOAD THE SEGMENT
	JNE  IOABOR		BRIF I/O ERROR, ABORT IT
*
	MOV  @SELOPT,R0		GET SELECTED OPTION
	INC  R0
	MOV  @LOAFLA,R1		LOAD FLAG
	SLA  R1,0		DO I NEED TO LOAD RUNTIME?
	JEQ  FORLD1		BRIF NO
	JGT  FORLD1
*
*  I MUST LOAD THE FORTRAN RUNTIME WITH THIS OPTION.  MOVE THE
*  LAST TWO CHARACTERS OF THE RUNTIME NAME INTO MY FILE NAME,
*  AND RECALL THE LOAD SUBROUTINE
*
	MOV  @RUNTBY,R1		GET RUNTIME BYTE
	MOVB R1,*R9+
	SWPB R1
	MOVB R1,*R9
	BL   @LOADSU		RECALL LOAD SUBROUTINE
	JNE  IOABOR
*
*  THE PROGRAM HAS BEEN SUCCESSFULLY LOADED.  SAVE THE SELECTED OPTION
*  AS THE LAST OPTION SELECTED, IN CASE I WANT TO RERUN PROGRAM
*
FORLDX	EQU  $
	LI   R5,PROGST
	MOV  R5,@STAADR		SET START ADDRESS
FORLD1  EQU  $
	MOV  @SELOPT,@LASTAS	TELL EVERYBODY I MADE IT
FORLD2  EQU  $
	MOV  @FILEOP,R0		GET # OF FILES TO OPEN
	BLWP @EFILES		DO IT
	BLWP @TSCROU
	DATA HELL1D		CLEAR THE SCREEN
*
FORLD3	EQU  $
	LWPI GPLWS
	MOV  @STAADR,R0		GET START ADDRESS
	LIMI 0			MAKE SURE INTERRUPTS ARE DISABLED
	B    @BREAKL		GOTO HANDY BREAK LOCATION
*
*  CALL PROGRAM ENTRY, CALL ANOTHER PROGRAM VIA CALL CHAIN SUBROUTINE
*
ECALPR	EQU  $
	BL   @CLOSAL		CLOSE ALL FILE CONNECTIONS
	BL   @LOADSU		LOAD THE PROGRAM
	JEQ  FORLD3		GO START NEW PROGRAM
	JMP  CALABO		ELSE, ABORT RECALL
*
*  FILES : RESET # OF FILES.   # OF FILES IS PASSED IN R1
*
FILES	EQU  $
	BL   @CLOSAL		CLOSE ALL OPEN FILES
	MOVB *R13,@PAFILE	GET # OF FILES TO OPEN
	LI   R1,FILPAB
	BL   @SETDSR		SET DEVICE SERVICE STUFF
	LI   R3,PABSTA-7
	MOV  R3,@FILPTR
	BLWP @DSRLNK		CALL SUBROUTINE
	DATA >000A	 	TO RESET # FILES (FIXED ON V3.0)
*
*  IOMAP  - REMAP I/O TABLES BASED ON VDP END LOCATION
*
IOMAP	EQU  $
	MOV  @VDPEND,R5   	GET VDP END LOCATION
	ANDI R5,>FFFE		ROUND OFF (MAKE EVEN)
	AI   R5,->180		OFFSET TO I/O BUFFER
*	AI   R5,->284		OFFSET TO I/O BUFFER
	MOV  R5,@DIOTBU   	SAVE I/O BUFFER ADDRESS
	AI   R5,->180		48 BYTES PER PAB FOR 8 PAB'S TOTAL
	MOV  R5,@MENVDP   	SAVE VDP END ADDRESS
	INCT R5	   		START OF VDP RAM WORKSPACE
	LI   R0,NOIOTA		# OF I/O TABLE ENTRIES
	LI   R1,IOTABL		I/O TABLE START
IOMAP1	EQU  $
	CLR  *R1+	 	CLEAR I/O ENTRY
	MOV  R5,*R1+		PAB START ADDRESS
	AI   R5,9	 	POINT TO NAME START
	MOV  R5,*R1+
	CLR  *R1+	 	CLEAR DEVICE TYPE
	AI   R5,>30->9		>30 BYTES PER PAB (48 WORDS)
	DEC  R0
	JNE  IOMAP1		BRIF MORE
	RTWP			RETURN
*
* IOABOR - I/O ERROR HAS OCCURRED, THE ERROR IS IN R1
*
INPFUL	EQU  $			NO ROOM FOR DEBUGGER
	BLWP @TSCROU
	DATA NOROOM
	JMP  BWAIRT		GO WAIT & REENTER
*
CALABO	EQU  $
	BLWP @TSCROU
	DATA NOMAKI		DIDN'T MAKE CALL PROGRAM
*
IOABOR	EQU  $
	BLWP @TSCROU
	DATA IOERR
BWAIRT	EQU  $
	BLWP @CWAIT$		WAIT FOR KEY
EXEABO  EQU  $
	B    @ENTRY
*
*  LOADSU : LOAD AN E/A 5 PROGRAM FILE, AND RETURN
*
*  THIS SUBROUTINE LOADS AN E/A 5 PROGRAM FILE INTO MEMORY, GIVEN A
*  STARTING FILE NAME IN 'RESFIL'.   AN E/A 5 FILE HAS THE FOLLOWING
*  FORMAT IN THE FIRST THREE WORDS OF THE FILE:
*
*	R5 WORD 1   :   0000 (END MODULE), FFFF (CONTINUATION)
*	R6 WORD 2   :   # OF BYTES TO LOAD
*	R7 WORD 3   :   START ADDRESS TO LOAD
*
*  MODULES ARE LOADED UNTIL THE FIRST BYTE OF THE FILE IS A '00', INDICATING
*  THE END MODULE.
*
*  AN ERROR WILL SET THE ERROR WORD IN R0, THEN WILL RETURN TO THE USER.
*
*  A SPECIAL MODIFICATION TO WORD 3, WHEN WORD 3 IS SET TO '0000', THEN
*  THE LOADING WILL STOP WITH NO ERROR, AND THE MODULE WILL BE LEFT IN
*  VDP RAM WITHOUT MOVING THE DATA TO CPU RAM.
*
*  ALSO, IF THE HEADER WORD IS 'DE', THEN THIS IS THE DEBUG MODULE.  THE
*  DEBUG MODULE IS DYNAMICALLY RELOCATED EITHER INTO THE MINI-MEMORY OR
*  SUPERCART AT LOCATION >7000 (IF PRESENT), OR INTO THE SPACE BETWEEN
*  THE LOGIC AREA END AND DATA AREA START SPECIFIED BY THE FORTRAN 
*  PROGRAM.  THE TRANSFER VECTOR DEBUGT IS ALSO SET TO THE APPROPRIATE
*  VALUE.
*
LOADSU	EQU  $
	MOV  R11,R12		SAVE RETURN
	CLR  @STAADR		CLEAR START ADDRESS
LOADS0	EQU  $
	LI   R0,RESPAB		SET UP RESTORE PAB
	LI   R1,RESLIS		RESTORE LIST
	MOV  *R1+,*R0+		OPCODE
	MOV  *R1+,*R0+		MODULE START
	CLR  *R0+		UNUSED
	MOV  *R1+,*R0+		MAX SIZE OF A PROGRAM MODULE
*
	LI   R1,RESPAB		MOVE PAB TO VDP RAM
	BL   @SETDSR		SETUP DEVICE SERVICE ROUTINE
	BLWP @DSRLNK		LINK TO DEVICE SERVICE ROUTINE
	DATA 8
	JEQ  INPERR		BRIF INPUT ERROR OCCURRED
*
*  GET FIRST THREE LOCATIONS OF MODULE IN REGISTERS R5, R6, AND R7.
*
	LI   R0,MODSTA		MODULE START IN VDP RAM
	STWP R1
	AI   R1,10		POINT TO R5 START
	LI   R2,6
	BLWP @VMBR		READ 6 BYTES
*
	CI   R5,'DE'		IS THIS THE DEBUGGER?
	JNE  LOADSA		BRIF NO
*
	SETO @LASTAS		RESET LAST TASK RAN (CAN'T RESTART)
*
	LI   R7,MINIST		MINI MEMORY START
	CLR  R5			DON'T LOAD ANY OTHER MODULES
	ABS  @MEMMAP		IS THIS EDITOR/ASSEMBLER MEMORY MAP?
	JNE  MAPMIN		BRIF NO, MAP IN MINI-MEMORY
	MOV  @DATSTR,R8		GET DATA START
	MOV  @LOGEND,R7		GET LOGIC END
	S    R7,R8		IS THERE ROOM?
	CI   R8,>1004		 (NEED FULL 4K OF SPACE)
	JLT  INPFUL		BRIF NO, NO ROOM
MAPMIN	EQU  $
	MOV  R7,@DEBUGT		SET DEBUGGER TRANSFER ADDRESS
*
LOADSA	EQU  $
	MOV  R7,R7		IS CPU LOCATION TO READ ZERO?
	JEQ  INPDON		BRIF YES, I'M DONE
*
	MOV  @STAADR,R4		ANY START ADDRESS SPECIFIED YET?
	JNE  LOADS1		BRIF YES, NOT FIRST MODULE
	MOV  R7,@STAADR		ELSE, SET NEW STARTING ADDRESS
LOADS1	EQU  $
	MOV  R7,R1		GET # OF BYTES SPECIFIED TO CPU RAM
	MOV  R6,R2
	LI   R0,MODSTA+6
	BLWP @VMBR		DO IT
	ANDI R5,>FF00		IS FIRST BYTE ZERO?
	JEQ  INPDON		BRIF YES, I'M DONE
*
	LI   R0,RESFIL		RESTORE FILE NAME START
	CLR  R1
	MOVB *R0,R1
	SWPB R1
	A    R1,R0		DETERMINE END FILE NAME
	AB   @KX100,*R0		INCREMENT THE FILE NAME AND
	JMP  LOADS0		 LOAD ANOTHER MODULE
*
INPERR	EQU  $
	AI   R0,>0100
	JMP  INPRET
INPDON	EQU  $
	CLR  R0
INPRET	EQU  $
	MOV  R0,R0
	B    *R12
*
*  SETDSR - SETUP FOR DEVICE SERVICE ROUTINE ACCESS.  MOVES THE PAB
*	    INTO VDP RAM (AT PABSTA) AND SETS THE DSR POINTER.
*
SETDSR	EQU  $
	LI   R0,PABSTA
SETDS1	EQU  $
	LI   R2,>30
	BLWP @VMBW
	AI   R0,9
	MOV  R0,@DSRPTR
	B    *R11
*
* WAIT - WAIT for ENTER key depressed on keyboard
*
WAIT  	EQU   $
	BLWP @TSCROU
	DATA REQCON
KEYLO1	EQU  $
	BLWP @KSCAN		GET A KEY
	MOVB @GPLSTA,R1  	KEY DEPRESSED ?
	ANDI R1,>2000
	JEQ  KEYLO1		BRIF NO
	CLR  R1
	MOVB @KEYFND,R1
	CI   R1,>0D00		IS IT ENTER ?
	JNE  KEYLO1
	RTWP		 	ELSE, RETURN
*
*  CLEAR THE I/O TABLES, CLOSE EACH FILE WHICH MAY BE OPEN.
*
CLOSAL  EQU  $
	LI   R9,NOIOTA		# OF I/O TABLES
	LI   R10,IOTABL   	I/O TABLE START
INILOP	EQU  $
	MOV  *R10,@ALCLOS+2
	LI   R4,ALCLOS
	BLWP @EIO		CLOSE THE FILE
	CLR  *R10		ENSURE LOGICAL DEVICE # ZAPPED
	AI   R10,8		SKIP TO NEXT
	DEC  R9	   		DECR TABLE #
	JNE  INILOP		BRIF MORE
	B    *R11		DONE, RETURN
*
	TITL 'I/O ROUTINES'
	PAGE
*
*  THIS MODULE CONTAINS THE GENERAL I/O ROUTINES.
*
*  SYSGEN EQUATES:
*
NOIOTA	EQU  8	    	8 I/O TABLE PACKETS
IOTLEN	EQU  8		SIZE OF AN I/O TABLE PACKET
*
*  USER COMMAND STACK EQUATES:
*
IOORDE	EQU  0		ORDER CODE
IOFUNC	EQU  1		FUNCTION CODE
IOLABE	EQU  2		FILE # (>1,<65536)
IOBUFA	EQU  4		ADDRESS OF USER BUFFER
IOBYTE	EQU  6		BYTE COUNT
IORCNO	EQU  8		RELATIVE RECORD #
*
*  I/O ERROR NUMBER	EQUATES:
*
INVDEV	EQU  1		INVALID DEVICE NAME
INVCAL	EQU  3		INVALID OPERATION ON DEVICE
BUFFUL	EQU  5		BUFFER FULL OR TOO MANY FILES
IEOFER	EQU  6		END OF FILE ON INPUT
ERBACK	EQU  9		FCTN/BACK PRESSED
ERREDO	EQU  10	   	FCTN/REDO PRESSED
*
*  I/O TABLE START.  8 POSSIBLE FILES, EACH PACKET AS FOLLOWS:
*
*  0  -  LABEL # (0=NONE)
*  1  -  VDP RAM ADDRESS OF PAB
*  2  -  VDP RAM ADDRESS OF DSR NAME
*  3  -  DEVICE TYPE (0=DISK,1=CASSETTE,2=CRT,3=PRINTER,0=RAMDISK)
*
*  I/O TABLE DEFINITION	EQUATES:
*
IOTLAB	EQU  0		FILE LABEL
IOTPAB	EQU  2		PAB START VDP ADDRESS
IOTDSR	EQU  4		DSR POINTER START ADDRESS
IOTTYP	EQU  6		TYPE OF FILE
*
*  TYPE OF DEVICE EQUATES:
*
DSKTYP	EQU  0		DISK TYPE
CASTYP	EQU  1		CASSETTE TYPE
SCRTYP	EQU  2		SCREEN TYPE
LISTYP	EQU  3		LISTING (PRINTER) TYPE
*
*  OPFILE - OPEN A FILE ROUTINE
*
*  THIS ROUTINE IS CALLED TO OPEN A FILE FOR ACCESS.
*
*  CALLING SEQUENCE:
*
*	LI  R0,FILE#	NUMBER OF FILE TO OPEN
*	LI  R1,PABADR	PAB ADDRESS IN CPU RAM
*       BLWP @OPFILE    OPEN FILE
*
*  OPFILE WILL ADD THE REQUESTED DEVICE TO THE IOTABL, AND
*  OPEN THE FILE VIA THE DSRLNK ROUTINE.
*
*  ERRORS ARE RETURNED IN R1 (LOBYTE, RIGHT JUSTIFIED)
*
*  NOTE:  OPEN LOGIC EXTENDED SO THAT IF DEVICE IS NOT CRT, RS232, OR PIO,
*         AND DISK DRIVE IS NOT SPECIFIED, THEN DEFAULT TO BOOT DIRECTORY.
*
OPFILE	EQU  $
	MOV  @2(R13),R1		GET USER R1
	MOV  *R13,R0		GET USER R0
	JEQ  INVDVE		INVALID DEVICE
	BL   @FNDFRR		FIND FREE PACKET
	JMP  SETFRR		SET FREE PACKET
	NOP			ALREADY EXISTS
INVDVE	EQU  $
	CLR  R2
	LI   R1,BUFFUL		RETURN ERROR
	JMP  BIORRT
*
SETFRR	EQU  $			FOUND FREE I/O TABLE SLOT
	MOV  R0,*R6		SET FILE #
*				SET VDP BUF ADDRESS IN PAB
	MOV  @DIOTBU,@2(R1)	PUT IN ADDRESS OF I/O BUFFER IN USER PAB
*
*  TRANSFER THE PAB TO VDP MEMORY (VDP PAB MAY CHANGE IF DISK FILE)
*
	MOV  @IOTPAB(R6),R0	VDP START ADDRESS OF PAB
	BL   @SETDS1		SETUP FOR DSR ACCESS
*
	INC  R0			POINT TO FILE NAME START IN VDP
	AI   R1,9		POINT TO FILE NAME START IN CPU
*
	LI   R7,DSKTYP
	MOV  R7,@IOTTYP(R6)	SET DEFAULT TYPE OF DEVICE
*
	CLR  R2
	MOVB *R1+,R2		GET THE FILE NAME BYTE COUNT
	SWPB R2
	JEQ  OPRETU		IF NULL FILE, THEN I'M DONE
*
*  CHECK THE DEVICE NAME FOR THE DEVICES 'RS232', 'PIO', OR 'CRT'.
*  IF ANY ONE OF THESE NAMES, SET THE APPROPRITE DEVICE TYPE.  OTHERWISE,
*  CHECK THE DISK NAME TO SEE IF IT HAS A PREPEND (E.G. DSK.).  IF SO,
*  LEAVE ALONE, OTHERWISE, PREPEND THE BOOT DISK NAME AND MOVE TO PAB.
*
	LI   R8,SCANTB		SCAN TABLE OF DEVICE NAMES
SCANS1	EQU  $
	MOV  *R8+,R5		GET NEXT TABLE ADDRESS
	JEQ  SCANEX		BRIF DONE
	MOV  *R8+,R7		GET TYPE OF DEVICE
	MOV  R1,R3		START OF USER DEVICE NAME
	MOV  R2,R4		LENGTH OF USER DEVICE NAME
SCANS2	EQU  $
	MOVB *R5,*R5		END OF TABLE?
	JEQ  SCANDN		BRIF YES, FOUND DEVICE NAME
	CB   *R5+,*R3+		IS THIS THE DEVICE?
	JNE  SCANS1		BRIF NO, TRY NEXT DEVICE
	DEC  R4			DECR # OF BYTES IN USER PAB
	JNE  SCANS2
	JMP  SCANDN		BRIF DONE, DEVICE TYPE IN R6
*
*  COULD NOT FIND DEVICE.  IT IS PROBABLY A DISK DEVICE.  SCAN FOR A
*  PERIOD, INDICATING THE USER SPECIFIED A STARTING DISK NAME LIKE
*  'DSK.'.  OTHERWISE, PREPEND MY OWN DEVICE NAME.
*
SCANEX	EQU  $
	MOV  R1,R3
	MOV  R2,R4
	LI   R7,DSKTYP		SET DISK DEVICE TYPE
SCANS3	EQU  $
	CB   *R3+,@PERIOD	IS THIS A PERIOD?
	JEQ  SCANDN		BRIF YES, IT IS A DISK DEVICE
	DEC  R4
	JNE  SCANS3		TRY NEXT CHARACTER
*
*  DEVICE NAME DOES NOT INCLUDE A PERIOD.  INSERT THE BOOT DISK NAME
*  IN THE PAB.
*
	LI   R3,DBOTSH		MY DISK NAME
	MOV  R1,R4		SAVE POINTER TO CPU FILE NAME
SCANS4	EQU  $
	CB   *R3,@BLANK		IS NEXT CHARACTER A BLANK?
	JEQ  SCANS5		BRIF YES, DONE WITH BOOT STRING
	MOVB *R3+,R1		GET THE NEXT CHARACTER
	BLWP @VSBW		WRITE IT
	INC  R0			INCREMENT TO NEXT SLOT
	JNE  SCANS4
*
*  NOW INSERT THE USER DISK NAME
*
SCANS5	EQU  $
	MOV  R4,R1		REGAIN POINTER TO CPU FILE NAME
	BLWP @VMBW		WRITE REST OF FILE NAME
	A    R0,R2		UPDATE POINTER TO FILE NAME
	MOV  @IOTDSR(R6),R0
	S    R0,R2
	DEC  R2			-1 BYTE FOR SIZE BYTE
	MOV  R2,R1
	SWPB R1
	BLWP @VSBW		WRITE THE FINAL BYTE LENGTH
*
SCANDN	EQU  $
	MOV  R7,@IOTTYP(R6)	SET I/O TYPE
	CI   R7,SCRTYP		IS IT THE SCREEN?
	JEQ  OPRETU		BRIF YES, SKIP DSR LINKAGE
*
JMPIOT	EQU  $
	BLWP @DSRLNK		CALL DEVICE SERVICE ROUTINE
	DATA 8
	JNE  OPRETU		BRIF ERROR
	CLR  *R6	  	CLEAR MY TABLE
	SWPB R0	   		GET ERROR CODE
	INC  R0
	MOV  R0,R1		SET ERROR IN R1
	JMP  IORRT1
*
OPRETU	EQU  $			ERROR FREE RETURN
	CLR  R1
	JMP  IORRT1
BIORRT	EQU  $
	JMP  IORRT2
*
*  IO - INPUT/OUTPUT ROUTINE
*
*  THIS ROUTINE HANDLES GENERAL PURPOSE I/O FROM A USER PASSED COMMAND LIST.
*
*  CALLING SEQUENCE:
*
*	LI   R4,CMDLST
*	BLWP @IO
*
*  WHERE:
*
*	CMDLST - IS AN UP TO FIVE WORD COMMAND LIST AS FOLLOWS:
*
*		0  -  FUNCTION		 (ALL)
*		1  -  FILE NUMBER	 (ALL)
*		2  -  I/O BUFFER ADDRESS (FOR READS/WRITES)
*		3  -  # BYTES OF I/O     (FOR READS/WRITES)
*		4  -  RECORD # 		 (FOR REL. I/O ONLY)
*
*	RETURNS:
*		a. Returned I/O buffer at I/O buffer address
*		b. R0 - # bytes actually read (0 to 255, reads only)
*		c. R1 - any error condition (0=none, 1 to 10)
*		d. R2 - if error, has pointer to VDP file name
*
IO  	EQU  $
	MOV  @8(R13),R4		GET OLD USER R4
*
REIOEN	EQU  $
	MOV  @IOLABE(R4),R0
	JEQ  SETINV		0 LABEL INVALID
	BL   @FNDFRR		SEARCH I/O TABLE FOR #
	JMP  SETINV		FREE PACKET FOUND
	JMP  IOTFND		FILE FOUND
SETINV	EQU  $			ALL PACKETS IN USE
	CLR  R2
	LI   R1,INVDEV		INVALID DEVICE OR FILE
	JMP  IORRT2		RETURN
*
IOTFND	EQU  $			FOUND IO TABLE PACKET
	MOV  @IOTDSR(R6),R0
	BL   @QVSBR		DOES A FILE EXIST (NOT DUMMY)
	JEQ  IORRT1		BRIF DUMMY FILE HERE
	MOV  *R4,R3		GET I/O LABEL
	ANDI R3,>800		RELATIVE I/O ?
	JEQ  NOTREL		BRIF NOT
*				MOVE RECORD NUMBER
	MOV  @IOTPAB(R6),R0
	AI   R0,4	 	GET BYTE COUNT
	BL   @QVSBR		READ IT
	SWPB R1	   		FIX USER BYTE COUNT TO OPENED VALUE
	MOV  R1,@IOBYTE(R4)
	INCT R0	   		NOW SET THE RECORD NUMBER IN PAB
	MOV  @IORCNO(R4),R1
	BL   @QVSBW		WRITE IT
	INC  R0
	SWPB R1
	BL   @QVSBW
*
NOTREL	EQU  $
	LI   R7,PFORMA		SEARCH FORMAT CODE
	MOV  *R4,R3		GET FUNCTION/TYPE
	ANDI R3,>FF		MASK FUNCTION
FORLOP	EQU  $			FIND FUNCTION
	C    *R7,R3		IS IT THE SAME ?
	JEQ  FOREND		BRIF YES
	AI   R7,6	 	ELSE, SKIP TO NEXT
	MOV  *R7,R5
	JGT  FORLOP		BRIF MORE
	LI   R1,INVCAL		ELSE, INVALID CALL
	JMP  IORRT2		RETURN
FOREND	EQU  $
	CLR  R1	   		CLEAR ERROR
	INCT R7	   		CALL PRE-FORMAT ROUTINE
	MOV  *R7,R2
	B    *R2
*				CALL DSRLNK FOR I/O
CALDSR  EQU  $
	MOV  @IOTPAB(R6),R0
	BL   @QVSBW		WRITE FUNCTION
	MOV  @IOTTYP(R6),R2
	SLA  R2,1	 	*2
	AI   R2,BTYPET		BRANCH TABLE
	MOV  *R2,R2
	B    *R2	  	EXECUTE FUNCTION
*
RETDSR  EQU  $
	JNE  IORRT2		BRIF I/O ERROR OCCURED
	INCT R7			BUMP POINTER TO POST FORMAT ROUTINE
	MOV  *R7,R2		GET ROUTINE ADDRESS
	JEQ  IORRT1		BRIF NONE
	CLR  R1			ELSE, EXECUTE ROUTINE
	B    *R2	  	EXECUTE POST-FORMAT ROUTINE
*
IORRT1  EQU  $
	MOV  R1,R1
	JEQ  IORRT3		BRIF NO ERROR
IORRT2  EQU  $
	MOV  @IOTDSR(R6),R2	GET PAB ADDRESS IN VDP ARM
	MOV  R2,@4(R13)		MOVE TO USER R2
IORRT3  EQU  $
	ANDI R1,>FF		SET EQUAL BIT
	MOV  R1,@2(R13)		PUT ERROR CODE (IF ANY) IN USER R1
	STST R15		SAVE STATUS
	RTWP			RETURN
*
**************************
*			 *
*  PRE- FORMAT ROUTINES  *
*			 *
**************************
*
PRREAD	EQU  $			PRE-READ FORMAT
	LI   R1,>0200		SET FUNCTION=READ
	JMP  PRERET
*
PRREWI	EQU  $
	LI   R1,>0400		PRE-REWIND FORMAT
	JMP  PRERET
*
PRCLOS	EQU  $			PRE-CLOSE FILE
	LI   R1,>0100		SET FUNCTION=CLOSE
	JMP  CLARET
*
PRDELE	EQU  $			PRE-DELETE FILE
	LI   R1,>0700		SET FUNCTION=DELETE
CLARET	EQU  $
	CLR  *R6	  	CLEAR THIS IOTABLE (UNUSED)
PRERET	B    @CALDSR		RETURN
*
PRWRIB	EQU  $			PRE-WRITE BINARY
	MOV  @IOBUFA(R4),R2	GET BUFFER ADDRESS
	MOV  @IOBYTE(R4),R3	GET NUMBER OF BYTES
	JMP  PRWRAB		DON'T TRIM ANYTHING
*
PRWRIA	EQU  $			PRE-WRITE ASCII
	MOV  @IOTTYP(R6),R3
	CI   R3,DSKTYP		IS IT LISTING TYPE ?
	JNE  ISTPRI		BRIF PRINTER
	MOV  @IOBUFA(R4),R2     GET BUFFER ADDRESS
	MOV  @IOBYTE(R4),R3	GET NUMBER OF BYTES
	BL   @TRIMBY		TRIM BYTES FROM BUFFER
	INC  R3			ADD BACK IN 1ST BYTE
PRWRAB  EQU  $
	MOV  @DIOTBU,R0
	MOV  R2,R1		SAVE I/O BUFFER ADDRESS
	MOV  R3,R2		NUMBER OF BYTES OF I/O
	JNE  PRWRAA		BRIF SOMETHING HERE
	INC  R2			MUST BE AT LEAST ONE BYTE
PRWRAA  EQU  $
	BLWP @VMBW		WRITE ONLY AS MUCH AS I NEED
	MOV  R2,R1		GET BYTE COUNT
	JMP  NOMOV2		CLEANUP & EXIT
*
*  PRINTER FORMAT CONTROL LOOP
*
ISTPRI	EQU  $
	CI   R3,SCRTYP
	JEQ  NOMOV3		IF SCREEN, SKIP PRINTER STUFF
	MOV  @IOBUFA(R4),R2	GET CPU RAM BUFFER ADDRESS
*
*  PRINTER OUTPUT CONTROL PRE-FORMATTER (FOR ASCII)
*
ISTPR1	EQU  $
	MOV  @DIOTBU,R0
	LI   R8,BPRINT		SEARCH BPRINT TABLE FOR CHAR
*
BPRLOP	EQU  $
	MOV  *R8+,R5		GET THE CHARACTER TO COMPARE
	JLT  UNRECO		UNRECOGNIZED CHAR
	CB   *R2,R5		IS IT THE SAME ?
	JEQ  BPRLO1		BRIF FOUND
	INCT R8			SKIP DATA WORD
	JMP  BPRLOP
UNRECO  EQU  $
	DECT R8			BACK UP TO PREVIOUS DEFAULT
BPRLO1  EQU  $
	BL   @WRITER		WRITE TERMINATOR
	MOV  @IOBYTE(R4),R3     GET BYTE COUNT FROM USER
	BL   @TRIMBY		TRIM BYTE COUNT (DON'T INCLUDE BLANKS)
	MOV  @IOBUFA(R4),R1	CPU RAM USER BUFFER ADDRESS
	INC  R1			+1 TO SKIP 1ST CHARACTER
	MOV  R3,R2		RESULTANT BYTE COUNT (NOT INCLUDING 1ST)
	JEQ  NOMOVE		BRIF NOTHING TO MOVE
	BLWP @VMBW		WRITE REST OF BUFFER
NOMOVE  EQU  $
	A    R2,R0		BUMP VDP RAM ADDRESS
	BL   @WRITER		WRITE TERMINATOR
	S    @DIOTBU,R0		DETERMINE RESULTANT BYTE COUNT
	MOV  R0,R1		AND PUT IT IN PAB
NOMOV2  EQU  $
	SWPB R1
	MOV  @IOTPAB(R6),R0
	AI   R0,5
	BL   @QVSBW		SET BYTE COUNT IN PAB
NOMOV3  EQU  $
	LI   R1,>0300
	B    @CALDSR		RETURN
*
**************************
*			 *
*	I/O DRIVERS	 *
*			 *
**************************
*
*  THE FOLLOWING CONTAINS I/O DRIVERS BY DEVICE TYPE.
*
*  DSKIO:   DISK I/O
*  CASIO:   CASSETTE I/O (UNIMPLEMENTED)
*  LISIO:   LISTING (PRINTER OR OTHER DSR) I/O
*  SCRIO:   SCREEN I/O
*
DSKIO	EQU  $
CASIO	EQU  $
LISIO	EQU  $
	MOV  @IOTDSR(R6),@DSRPTR
	CLR  R0
	BLWP @DSRLNK
	DATA 8
	JNE  IOEER2		BRIF NO I/O ERROR
	MOV  R0,R1
	SWPB R1
	INC  R1
	CI   R1,6	 	IS IT AN EOF ?
	JNE  IOEER1		BRIF NO
	MOV  @DIOTBU,R0
	LI   R1,BEOD
	LI   R2,4
	BLWP @VMBW		SET BUFFER TO >EOD
	MOV  R2,R1
	SWPB R1
	MOV  @IOTPAB(R6),R0
	AI   R0,5	 	SET BYTE COUNT READ
	BL   @QVSBW		SET 4 BYTES READ
IOEER2	EQU  $
	CLR  R1
*	
IOEER1	EQU  $
	MOV  R1,R1		SET STATUS FOR USER
	B    @RETDSR		RETURN
*
*  SCREEN I/O ROUTINE
*
SCRIO	EQU  $
	CI   R1,>0200		WAS IT A READ ?
	JNE  NOTRES		BRIF NO
*
*  ITS A READ ( FUNC CODE 2 )
*
TRYAGA	EQU  $
	MOV  @IOBYTE(R4),R3     MAXIMUM LENGTH OF READ
	MOV  @IOBUFA(R4),R4
	BLWP @SCRIN		GET SCREEN BUFFER
	MOV  @8(R13),R4		RESTORE OLD R4
	MOV  R0,R0		ANY ERROR?
	JEQ  SCROKR		READ OK
	JGT  REDOER		BRIF REDO
	LI   R1,ERBACK		ELSE, BACK ERROR (9)
	JMP  SCRRER		RETURN ERROR
REDOER	LI   R1,ERREDO		ELSE, REDO ERROR (10)
	JMP  SCRRER
SCROKR	EQU  $
	MOV  @DIOTBU,R0
	MOV  @IOBUFA(R4),R1
	CLR  R2
	MOVB *R1+,R2
	SWPB R2	   		# BYTES READ
	MOV  R2,*R13		SAVE IN USER R0
	JEQ  SETBYT		BRIF NO BYTES READ
	BLWP @VMBW		WRITE BUFFER
SETBYT	EQU  $			SET BYTE COUNT IN PAB
	MOV  @IOTPAB(R6),R0
	AI   R0,5
	MOV  R2,R1		SET BYTE COUNT
	SWPB R1
	BL   @QVSBW
	JMP  READRE		RETURN
*
NOTRES	EQU  $
	CI   R1,>0300		IS IT A WRITE ?
	JNE  READRE		BRIF NO
*
*  SCRWRT - SCREEN WRITE HANDLES FORTRAN I/O BUFFER DIRECTLY
*
SCRWRT	EQU  $			WRITE COMMAND
	MOV  @IOBYTE(R4),R3	GET BYTE COUNT FROM USER COMMAND STACK
	MOV  @IOBUFA(R4),R4     GET I/O BUFFER ADDRESS
	BLWP @FSCROU		DO SCREEN OUTPUT
	MOV  @8(R13),R4		RESTORE COMMAND STACK ADDRESS
READRE  EQU  $
	CLR  R1	   		CLEAR ERROR CONDITION
SCRRER	EQU  $
	MOV  R1,R1		ERROR ONLY POSSIBLE FOR REDO OR BACK
	B    @RETDSR		RETURN
*
**************************
*			 *
*  POST-FORMAT ROUTINES  *
*			 *
**************************
*
*  ROUTINES EXECUTED AFTER I/O PERFORMED
*
*  POREAD:  POST READ ROUTINE.  PADS WITH BLANKS & CHECKS FOR EOD.
*
POREAD	EQU  $
	MOV  @IOTPAB(R6),R0
	AI   R0,5	 	GET # BYTES ACTUALLY READ
	BL   @QVSBR
	SWPB R1
	MOV  R1,*R13		SAVE IN USER R0
	MOV  R1,R2		# BYTES READ
	MOV  @DIOTBU,R0
	MOV  @IOBUFA(R4),R1
	MOV  R2,R2		BRIF NOTHING READ
	JEQ  NOREAD
	BLWP @VMBR		READ BUFFER INTO CPU RAM
NOREAD  EQU  $
	A    @IOBYTE(R4),R1     GET EOB ADDRESS
	DEC  R1
	S    @IOBYTE(R4),R2	GET # BYTES TO PAD
	JEQ  CHKEOD
	JGT  CHKEOD
PADLOP	EQU  $
	MOVB @BLANK,*R1   	PAD A BYTE
	DEC  R1	   		DECR # BYTES
	INC  R2
	JNE  PADLOP
*
CHKEOD	EQU  $			CHECK FOR END OF DATA
	MOV  @IOBUFA(R4),R1
	C    @BEOD,*R1+
	JNE  POREEN		NOT >EOD
	C    @BEOD+2,*R1
	JNE  POREEN
	LI   R1,IEOFER		ELSE, RETURN EOF ERROR
	JMP  CHKEO1
POREEN  EQU  $
	CLR  R1
CHKEO1	EQU  $
	B    @IORRT1		RETURN
*
*  PRE,POST FORMAT BY FUNCTION CODE
*
PFORMA	EQU  $
	DATA >06	  06 = READ
	DATA PRREAD
	DATA POREAD
	DATA >3B	  3B = REWIND
	DATA PRREWI
	DATA 0
	DATA >FE	  FE = CLOSE FILE
	DATA PRCLOS
	DATA 0
	DATA >FF	  FF = DELETE FILE
	DATA PRDELE
	DATA 0
	DATA >01	  01 = WRITE BINARY
	DATA PRWRIB
	DATA 0
	DATA >05	  05 = WRITE ASCII
	DATA PRWRIA
	DATA 0
	DATA -1	   	TERMINATOR
*
*  BRANCH TABLE FOR I/O TYPE DEVICE
*
BTYPET	EQU  $
	DATA DSKIO	DISK I/O
	DATA CASIO	CASSETTE I/O
	DATA SCRIO	SCREEN I/O
	DATA LISIO	LISTING (PRINTER) I/O
*
*  PRINTER FORMAT CONTROL CHARACTERS
*
*  1ST WORD:   High byte is carriage control FORTRAN character
*  2ND WORD:   High byte is leading byte, low byte is trailing byte
*
BPRINT	EQU  $
	TEXT '1 '	  '1' - NEW PAGE
	DATA >0C0D
	TEXT '0 '	  '0' - DOUBLE SKIP
	DATA >0D0D
	TEXT '+ '	  '+' - NO CARRIAGE CONTROL
	DATA >0000
	TEXT '  '	  ' '  - SINGLE SKIP (DEFAULT) (MUST BE LAST)
	DATA >000D
	DATA -1	   	END OF LIST
*
*  TABLE OF LISTING DEVICE NAMES.  SCANNED BY OPEN ROUTINE
*
PIODEV	EQU  $
	TEXT 'PIO'
	BYTE 0
RS2DEV	EQU  $
	TEXT 'RS232'
	BYTE 0
CRTDEV	EQU  $
	TEXT 'CR'
	BYTE 0
	EVEN
*
SCANTB	EQU  $
	DATA PIODEV,LISTYP
	DATA RS2DEV,LISTYP
	DATA CRTDEV,SCRTYP
	DATA 0			END OF LIST
*
*  FNDFRR - FIND FREE PACKET
*
*  GIVEN FILE # IN R0, SEARCH I/O TABLE FOR FREE PACKET
*
*  CONDITIONS RETURNED:
*
*   CALLER + 2 - FOUND FREE PACKET, ADDRESS
*		 IN R6.
*   CALLER + 4 - FILE EXISTS, ADDRESS OF
*		 FILE ADDRESS IN R6.
*   CALLER + 8 - NO FREE I/O FILE ADDRESSES
*	 	 EXIST.
*
FNDFRR	EQU  $
	LIMI 0			DISABLE INTERRUPTS (I'M USING FAST VDP)
	LI   R6,IOTABL    	I/O TABLE START
	LI   R3,NOIOTA    	# OF I/O TABLE PACKETS
	CLR  R2	   		FREE PACKET ADDRESS
FRELOP	EQU  $
	MOV  *R6,R5		GET ENTRY
	JNE  NFDNFR		BRIF THIS ONE EMPTY
FNDFRE	EQU  $	    		FOUND FREE PACKET
	MOV  R6,R2
NFDNFR	EQU  $
	C    R5,R0		IS IT THE FILE REQUESTED ?
	JEQ  RETEXI		YES, RETURN EXISTS
INCFRE	EQU  $
	AI   R6,IOTLEN		SKIP TO NEXT PACKET
	DEC  R3
	JNE  FRELOP		BRIF MORE TO SEARCH
	MOV  R2,R6		ANY FREE PACKETS FOUND ?
	JNE  RETFRE		BRIF YES
RETFUL	EQU  $			FULL CONDITION
	INCT R11
RETEXI	EQU  $			FOUND FILE CONDITION
	INCT R11
RETFRE	EQU  $			FOUND FREE PACKET CONDITION
	B    *R11
*
*  TRIMBY - Trim byte count (eliminate trailing blanks)
*
*	    R2 has I/O buffer address in CPU RAM
*	    R3 has byte count from user
*
TRIMBY  EQU  $
	MOV  R2,R1
	A    R3,R1		Determine ending buffer address
	DEC  R1
TRIMLA  EQU  $
	CB   *R1,@BLANK		is this a blank?
	JNE  TRIMEN		brif no, done
	DEC  R1			look at previous
	DEC  R3			decrement byte count
	JNE  TRIMLA		don't go negative
	INC  R3			make sure at least one byte
TRIMEN  EQU  $
	DEC  R3
	B    *R11		return	
*
*  WRITER - WRITE TERMINATOR
*
*	    ON ENTRY:   R8 HAS POINTER TO NEXT TERMINATOR (PRE/POST)
*	 	        R0 POINTS TO CURRENT VDP BUFFER ADDRESS
*
WRITER  EQU  $
	MOV  R11,R10		SAVE RETURN
	CLR  R1
	MOVB *R8+,R1		GET LEADING CHARACTER
	JEQ  BPRLO2		BRIF NULL
	BL   @QVSBW		ELSE, WRITE IT	
	INC  R0			INC I/O BUFFER ADDRESS
	CB   R1,@CARRN		DID I WRITE A CARRIAGE RETURN?
	JNE  BPRLO2		BRIF NO
	MOVB @ENCHAR,R1		GET ADDITIONAL LINE ENDING CHARACTER
	JEQ  BPRLO2		BRIF NOTHING HERE
	BL   @QVSBW
	INC  R0			INCREMENT BYTE COUNT AGAIN
BPRLO2  EQU  $
	B    *R10
	TITL 'SCREEN INPUT/OUTPUT ROUTINES'
	PAGE
*
*  THIS MODULE CONTAINS THE SCREEN INPUT/OUTPUT HANDLERS.
*  THERE ARE FOUR ENTRY POINTS:
*
*  	SETMOD -  SET SCREEN MODE
*  	FSCROU -  FORTRAN I/O BUFFER TO SCREEN
*  	SCROUT -  CPU BUFFER TO SCREEN
*  	TSCROU -  CPU BUFFER TO SCREEN (POINTED TO BY R14)
*  	SCRIN  -  SCREEN TO CPU BUFFER
*
*
*  SETMOD :  SET UP COLORS BASED ON VDP MODE
*
*  ON ENTRY :   R1 HAS DESIRED SCREEN MODE
*
ESETMO	EQU  $
	LI   R0,CELRES		RESTORE CELLS
ENTCLR	EQU  $
	MOV  *R0+,R1		GET LOCATION TO RESTORE
	JEQ  ENTDON		BRIF DONE
	MOV  *R0+,*R1		AND RESTORE IT
	JMP  ENTCLR
ENTDON	EQU  $
	MOV  *R0+,R1		GET LOCATION TO ZERO
	JEQ  ENTDO1		BRIF DONE
	CLR  *R1
	JMP  ENTDON
ENTDO1	EQU  $
*
	CLR  R0
	MOVB R0,@NUMSPR   	RESET # SPRITES IN MOTION
*
	MOV  @COLDEF,R5		GET FOREGROUND/BACKGROUND COLOR BYTE
	MOV  @2(R13),R6		GET DESIRED SCREEN MODE
	ANDI R6,3		GET TABLE ADDRESS
	MOV  R6,@DSET40		SET CURRENT SCREEN MODE
	SLA  R6,1
	MOV  @ASCRMO(R6),R7
	MOV  R7,@TABADR		SAVE ADDRESS OF VDP LOCATIONS START
*
	SRA  R6,1		GET SCREEN MODE BACK AGAIN
	CI   R6,GRAPH1		FOR 40/80 COLUMN MODE, MUST SET FORE & BACK
	JNE  SETVDC		FOR 32 COLUMN MODE, MUST SET FORE ONLY
*
* 32 COLUMN MODE
*
	ANDI R5,>0F00		FORM NEW COLOR BYTE BASED
	MOV  R5,R8		 ON FOREGROUND COLOR
	SLA  R5,4
	SOC  R8,R5
*
* SET VDP SCREEN MODE
*
SETVDC  EQU  $
	MOV  R7,R4		GET SCREEN DESCRIPTOR START
	AI   R4,16		 + OFFSET
	MOVB @1(R4),@REFSCR	FIRST, SET LOC >83D4 TO VR1
	CLR  R1			REGISTER #
*
*  SET REGISTERS 0-6
*
SETVDD	EQU  $
	MOV  R1,R0		GET REGISTER #
	MOVB *R4+,R0		GET THE NEXT VALUE BYTE
	SWPB R0
	BLWP @VWTR		WRITE THE REGISTER
	INC  R1			INCREMENT REGISTER #
	CI   R1,7		LAST REGISTER?
	JNE  SETVDD
*
*  SET REGISTER 7 (THE COLOR BYTE)
*
	MOV  R1,R0		GET REGISTER # (7)
	MOVB R5,R0		SET COLOR BYTE
	SWPB R0
	BLWP @VWTR
*
	CI   R6,TEXT1		IS THIS 40-COLUMN MODE?
	JEQ  SETVD5		YES, SKIP FOLLOWING MESS
	CI   R6,TEXT2		IS THIS 80-COLUMN MODE?
	JNE  SETVD1		BRIF NO
*
*  80-COLUMN MODE SPECIFIC SETTINGS
*
SETVDA	EQU  $			SET REMAINING REGISTERS 8,9,10
	INC  R1
	MOV  R1,R0
	MOVB *R4+,R0
	SWPB R0
	BLWP @VWTR
	CI   R1,10		DID I DO LAST REGISTER?
	JNE  SETVDA
	JMP  SETVD5
*
*  32-COLUMN MODE SPECIFIC SETTINGS
*
SETVD1	EQU  $
	MOV  @10(R7),R0		GET ADDRESS OF SPRITE TABLE
	LI   R1,>D000		INACTIVE SPRITE VALUE
SETVD2	EQU  $
	BLWP @VSBW	 	RESET A SPRITE
	AI   R0,4
	C    R0,@4(R7)		END OF TABLE ?
	JNE  SETVD2		BRIF NO
*
* LOAD COLOR TABLE WITH DEFAULT DEFINITIONS
*
SETVD3	EQU  $
	MOV  @DCOLDEF,R1	DEFAULT COLOR DEFINITION
	LI   R2,30		# OF BYTES TO WRITE
SETVD4	EQU  $
	BLWP @VSBW		WRITE A CHARACTER GROUP
	INC  R0
	DEC  R2
	JNE  SETVD4
*
* RELOAD CHARACTER SET
*
SETVD5	EQU  $
	ABS  @CHARSE		RESTORE CHARACTER SET?
	JEQ  SETVD6
	MOV  @6(R7),R0		PATTERN TABLE START
	AI   R0,>0100		OFFSET TO >20 (ASCII BLANK)
	MOV  R0,@FAC		SET IT
	BLWP @GPLLNK		USING GPL LINKAGE
	DATA >0018		RELOAD THE CHARACTER SET IN VDP RAM
*
	AI   R0,>0200		OFFSET TO LOWER CASE
	MOV  R0,@FAC
	BLWP @GPLLNK		LOAD THE LOWER CASE
	DATA >004A
*
* SETUP COPYRIGHT CHARACTER
*
*	LI   R0,8*31		SETUP CHARACTER >1F (31 DEC.)
*	A    @6(R7),R0		 + BASE OF PATTERN TABLE
*	LI   R1,COPYRI
*	LI   R2,8
*	BLWP @VMBW		WRITE THE CHARACTER DEFINITION
*
*  CLEAR THE SCREEN
*
SETVD6	EQU  $
	BLWP @TSCROU
	DATA HELL1D		CLEAR THE SCREEN
	RTWP
*
*  ESCRIN : ENTRY TO SCREEN INPUT ROUTINE
*
ESCRIN	EQU  $
	BL   @SCRSET		SETUP FOR SCREEN INPUT
	INC  R4	   		ADD 1 TO BUFFER START
	CLR  R5	   		# BYTES READ
*
SETBLK	EQU  $
	BL   @CHKSCR		SEE IF X-Y OFF SCREEN
	MOV  @BLOCKC,R6   	GET BLOCK CURSOR CHAR #
	MOV  R6,R2
SETCRR	EQU  $
	MOV  @COUNTD,R0   	COUNT DOWN FOR CURSOR
KEYLOA	EQU  $
	BL   @KEYSET
	JNE  KEYDEP		BRIF KEY DEPRESSED
	DEC  R0	   		COUNTDOWN REACHED ?
	JNE  KEYLOA		BRIF NO
	MOV  *R7,R0		GET CURRENT X-Y
	C    R2,R6		ELSE, WANT CURSOR ?
	JNE  WAASCI		BRIF NO
	BL   @QVSBR		& READ CHAR
	MOV  R1,R2		SAVE CHAR
	MOV  R6,R1
	BL   @QSCRW		WRITE CURSOR
	JMP  SETCRR		& REDO COUNTDOWN
*
WAASCI	EQU  $
	MOV  R2,R1
	BL   @QSCRW		RESTORE CHAR
	JMP  SETBLK
*
*  FOLLOWING CHECK MAKES SURE THAT I DON'T LEAVE CURSOR HANGING AFTER
*  A CHARACTER IS ENTERED.
*
KEYDEP	EQU  $
	MOV  *R7,R0		GET X-Y
	C    R2,R6		CURSOR BEING DISPLAYED?
	JEQ  SCROK1		BRIF NO
	MOV  R2,R1
	BL   @QSCRW		WRITE OLD ASCII CHAR
*
*  THE SCREEN IS NOW REFERESHED WITH NO CURSOR.  SEARCH MY SPECIAL CHARACTER
*  TABLE TO SEE IF THE CHARACTER WAS SOMETHING NOT RELATED TO ACTUAL DATA.
*
SCROK1	EQU  $
	LI   R12,TABSTR   	TABLE START
SCRCLO	EQU  $
	MOVB *R12+,R1		GET CHARACTER
	JEQ  SCRCL1		BRIF A NULL
	CB   @KEYFND,R1		IS THIS A SPECIAL KEY?
	JNE  SCRCLO		BRIF NO, TRY THE NEXT ONE
*
*  A SPECIAL KEY WAS FOUND AND MATCHED IN THE TABLE.  JUMP TO
*  ASSOCIATED PROCESS ROUTINE WHICH MATCHES THE KEY.
*
	DEC  R12
	LI   R1,TABSTR		GET TABLE START
	S    R1,R12		GET OFFSET INTO TABLE
	SLA  R12,1
	MOV  @TABJMP(R12),R12	GET ROUTINE ADDRESS
	B    *R12		AND DO IT
*
*  WASN'T A SPECIAL KEY.   SEE IF SOME TYPE OF OTHER SPECIAL CHARACTER,
*  IF SO, THEN EXIT THIS.
*
SCRCL1	EQU  $
	CLR  R1
	MOVB @KEYFND,R1		GET CHARACTER AGAIN
	CI   R1,>1000
	JLT  BEXITI		BRIF STILL SPECIAL
	C    R5,R3		MAX # BYTES READ?
	JEQ  SETBLK		BRIF YES
	BL   @QSCRW		WRITE THE READ CHAR TO SCREEN
	INC  R5			INCR # OF BYTES READ
	MOVB R1,*R4+		SAVE CHAR
	INC  *R7	  	INC X-Y OFFSET
	JMP  SETBLK
BEXITI  B    @EXITIT
*
*
*  DELIT - DELETE LAST CHARACTER ENTERED
*
DELIT	EQU  $
	MOV  R5,R5		ANY BYTES READ
	JEQ  SETBLK		BRIF NO
	DEC  *R7	  	DECR X-Y POSITION
	MOV  @DSET40,R2
	CI   R2,TEXT1
	JEQ  DELIT1		BRIF 40 COLUMN MODE
	CI   R2,TEXT2
	JEQ  DELIT1		BRIF 80 COLUMN MODE
	MOV  *R7,R2
	CLR  R1
	DIV  R8,R1		BEGINNING OF LINE ?
	MOV  R2,R2
	JNE  DELIT1
	DECT *R7	  	GO TO PREVIOUS LINE
DELIT1	EQU  $
	BL   @QBSCR		BLANK THE CHARACTER
	DEC  R4	   		DECR BUFFER POINTER
	DEC  R5	   		DECR # OF BYTES READ
	JMP  SETBLK		& RETURN
*
*  QUIT - UNCONDITIONAL ABORT
*
QUITIT	EQU  $
	LIMI 2			RESTORE INTERRUPTS
	LWPI GPLWS		GPL WORKSPACE
	BLWP @>0000		RESTART
*
*  REDO - RECALL SCREEN
*
REDOIT	EQU  $			ERROR 01 - REDO
	LI   R0,1
	B    @EXITCO
*
*  BACK - ABORT EXIT
*
BACKIT	EQU  $
	SETO R0
	B    @EXITCO
*
*  FSCROU - CPU SCREEN OUTPUT (FORTRAN I/O BUFFER)
*  TSCROU - CPU SCREEN OUTPUT (POINTED TO BY R14)
*  SCROUT - CPU SCREEN OUTPUT
*
EFSCRO  EQU  $
	BL   @SCRSET		SETUP FOR SCREEN OUTPUT
	MOV  R4,R2		TRIM BYTE COUNT
	BL   @TRIMBY		 IN R3
	MOV  R3,R6		SAVE AS MAXIMUM BYTE COUNT
	LI   R3,BPRINT		DETERMINE WHAT TO DO WITH PRINT CONTROL
FSCRO1	EQU  $
	MOV  *R3+,R5		GET NEXT CHARACTER
	JLT  FSCRO2		BRIF NOT FOUND
	CB   *R4,R5		IS THIS THE ONE?
	JEQ  FSCRO3
	INCT R3
	JMP  FSCRO1		BRIF NO
FSCRO2  EQU  $
	DECT R3			GO BACK TO DEFAULT SINGLE <CR>
	DECT R3
FSCRO3  EQU  $
	INC  R4			SKIP THIS PRE-CHARACTER
	MOV  *R3,R1		GET PRE/POST CHARACTERS
	MOV  *R3,@TERCHA	SAVE ANY TERMINATING CHARACTER
	ANDI R1,>FF00		CLEAR EXCESS BYTES
	JMP  SCRLO0		GO DO LOOP	
*	
ETSCRO	EQU  $
	MOV  *R14+,@8(R13) 	SET OLD R4 TO ENTRY
*
ESCROU	EQU  $
	BL   @SCRSET		SETUP FOR SCREEN OUTPUT
	LI   R6,256		MAXIMUM # OF BYTES TO USE
*
SCRLOU	EQU  $
	BL   @GETBYT
SCRLO0	EQU  $
	MOVB R1,R1		IS IT A NULL?
	JEQ  SCRLOU		BRIF YES, GO GET ANOTHER
	LI   R2,SPOUTC
SCRLO1	EQU  $
	MOVB *R2+,R3		GET NEXT CHARACTER FROM TABLE
	JEQ  SCRWRS		BRIF END OF TABLE
	CB   R1,R3		IS THIS A SPECIAL CHARACTER?
	JEQ  JMPSPE		BRIF YES
	JMP  SCRLO1		BRIF NO, TRY NEXT CHARACTER
*
*  NOT A SPECIAL CHARACTER, WRITE IT TO SCREEN
*
SCRWRS	EQU  $
	BL   @QSCRW		WRITE CHAR TO SCREEN
	INC  *R7
	JMP  JMPLI1		CHECK SCREEN FOR NEXT
*
JMPSPE	EQU  $
	LI   R3,SPOUT1		DETERMINE END OF TABLE
	S    R3,R2
	SLA  R2,1
	MOV  @SPOUTT(R2),R2	GET SPECIAL FUNCTION ADDRESS
	B    *R2
*
*  CLEAR SCREEN CONTROL
*
CLS 	EQU  $
	CLR  *R7	  	CLEAR TOP OF SCREEN POINTER
CLSLOP	EQU  $
	BL   @QBSCR		CLEAR A BYTE
	INC  *R7
	C    *R7,R9
	JNE  CLSLOP		BRIF MORE
	CLR  *R7
	JMP  JMPLI1		CHECK CURSOR & RETURN
*
*  POSITION CURSOR CONTROL (ESC = R C)
*
POSCUR	EQU  $
	BL   @GETBYT		SWALLOW THE EQUAL SIGN
	CB   R1,@BLNKIT		BLANK A LINE?
	JEQ  BLNKCU		YES, BLANK IT
	CB   R1,@EQUALS		IS IT AN EQUAL SIGN?
	JNE  SCRLOU		BRIF NO
	BL   @GETBYT		GET ROW POSITION
	SWPB R1
	AI   R1,->0021		ZERO BASE
	MOV  R1,R5		& SAVE
	BL   @GETBYT
	SWPB R1
	AI   R1,->0020		ZERO BASE
	MOV  R1,R2
	MOV  R5,R1		SWAP ROW AND COLUMN
	MOV  R2,R5
	MPY  R8,R1		Y * LINE LENGTH
	A    R5,R2		 + X
	MOV  R2,*R7		 = CRTXY
JMPLI1	EQU  $
	BL   @CHKSCR		CHECK VDP X-Y
	JMP  SCRLOU
*
*  BLNKCU - BLANK A CRT LINE "IN-PLACE".  THIS IS A SPECIAL ROUTINE
*	    JUST FOR INTERNAL FORTRAN TASKS TO REDUCE THE SPACE
*	    REQUIREMENTS FOR THINGS LIKE THE LINKER.  IT JUST BLANKS
*	    THE CURRENT CRT LINE.
*
BLNKCU	EQU  $
	MOV  *R7,R0		GET THE CURRENT LINE START
	LI   R1,'  '		FILL WITH BLANKS
	MOV  R8,R2		@ OF BYTES TO CLEAR
BLNKLP	EQU  $
	BL   @QVSBW		WRITE A BYTE
	INC  R0			INCREMENT TO NEXT SCREEN LOCATION
	DEC  R2			DECR # OF BYTES TO WRITE
	JNE  BLNKLP		BRIF MORE
	JMP  SCRLOU		AND GO GET ANOTHER BYTE
*
*  EXIT OUT OF LOOP
*
SCRLRE	EQU  $
	ABS  @DPRINT		SHALL I DO HOLD AFTER PRINT CHECK?
	JEQ  KEYRET		BRIF NO
	BL   @KEYSET		SEE IF KEY DEPRESSED
	JEQ  KEYRET
	CB   @KEYFND,@XON	IS THIS A CONTROL/S?
	JNE  KEYRET		BRIF NO
KEYLO2	EQU  $
	BL   @KEYSET		ELSE, KEY WAS DEPRESSED, WAIT
	JEQ  KEYLO2		FOR ANOTHER
	CB   @KEYFND,@XOFF	IS THIS A CONTROL/Q?
	JNE  KEYLO2
KEYRET	EQU  $
	JMP  EXITI1		RETURN
*
*  EXIT - SAVE BUFFER & EXIT PROGRAM
*
EXITIT	EQU  $
	S    R5,R4		GET BUFFER START
	DEC  R4
	SWPB R5	   		# BYTES READ
	MOVB R5,*R4		& SAVE IN BUFFER
	BL   @INCLIN		INCREMENT TO NEXT LINE START
EXITI1	EQU  $
	CLR  R0
*
EXITCO	EQU  $
	MOV  R0,*R13		SAVE R0 VALUE IN RETURN
	STST R15
	RTWP			RETURN W/WORKSPACE POINTER
*
*  JMPLIN - SKIP TO NEXT LINE
*
JMPLIN	EQU  $
	BL   @INCLIN		INCREMENT LINE
	JMP  SCRLOU
*
*  SUBROUTINES FOR SCRIN/SCROUT
*
*  SCRSET  -  SETUP FOR SCREEN INPUT OR OUTPUT
*  CHKSCR  -  CHECK FOR VALID SCREEN POSITION
*  INCLIN  -  INCREMENT X-Y TO START OF NEXT LINE
*  GETBYT  -  GET BYTE FROM CPU OR VDP RAM
*  QVSBR   -  QUICK VDP SINGLE BYTE READ
*  QVSBW   -  QUICK VDP SINGLE BYTE WRITE
*  KEYSET  -  SCAN KEYBOARD AND RETURN STATUS
*
*  SCRSET : SETUP FOR SCREEN INPUT OR OUTPUT.  PASSED THE FOLLOWING:
*
*    R13    : POINTS TO USER WORKSPACE
*    DCRTXY : POINTS TO CURRENT CRT X-Y CURSOR POSITION
*    
*  RETURNS:
*
*    R3     : CONTENTS OF USER R3 (WAS # BYTES TO INPUT)
*    R4     : CONTENTS OF USER R4 (WAS PTR TO STRING TO READ/WRITE)
*    R7     : POINTER TO CRT X-Y CURSOR POINTER
*    R8     : LENGTH OF A LINE ON THE SCREEN
*    R9     : END OF SCREEN ADDRESS IN VDP RAM
*
SCRSET	EQU  $
	MOV  @6(R13),R3   	GET OLD R3
	MOV  @8(R13),R4   	GET OLD R4
	LI   R7,DCRTXY		X-Y CURSOR POSITION
	MOV  @TABADR,R5		GET VDP LOCATIONS TABLE START
	MOV  *R5+,R8		LINE LENGTH
	MOV  *R5,R9		END OF SCREEN ADDRESS
	LIMI 0			DISABLE INTERRUPTS
	B    *R11	 	RETURN
*
*  INCLIN : INCREMENT CURSOR ADDRESS TO NEXT LINE.  IF OFF SCREEN,
*	    DOES SCROLL OPERATION.
*
INCLIN	EQU  $			INCREMENT VDP X-Y TO START OF NEXT LINE
	MOV  *R7,R2		PERFORM DIVIDE
	CLR  R1
	DIV  R8,R1		DIVIDE X-Y OFFSET
	INC  R1	   		INCR LINE #
	MPY  R8,R1		* WIDTH
	MOV  R2,*R7		& SAVE IN X-Y
*
*  CHKSCR - CHECK SCREEN OFFSET FOR WRITE SUBROUTINE; IF OFF SCREEN,
*	    THEN DOES SCROLL OPERATION.
*
CHKSCR	EQU  $
	MOV  R11,R12		SAVE RETURN
	MOV  @DSET40,R2   	GET 32/40 CHAR FLAG
	CI   R2,GRAPH1
	JNE  CHKOFF		BRIF 40/80 COLUMN MODE, USE WHOLE SCREEN
*
*  FOLLOWING CHECKS TO SEE IF ON COLUMN 1 OF SCREEN, WHICH IS HARD TO
*  SEE IN 32 COLUMNS.  IF SO, THEN SKIP TO COLUMN 2.
*
	MOV  *R7,R2		GET CURRENT VDP X-Y
	CLR  R1
	DIV  R8,R1		SEPERATE X-Y
	MOV  R2,R2		ON FIRST COLUMN?
	JNE  CHKEND		BRIF NO, THATS OK
	INC  *R7	 	 ELSE, INCR X-Y OFFSET
CHKEND	EQU  $
	INC  R2
	C    R8,R2		ON LAST COLUMN?
	JNE  CHKOFF		BRIF NO
	INCT *R7	  	ELSE, INC PAST LAST COLUMN
*
*  CHECK TO SEE IF OFF SCREEN
*
CHKOFF	EQU  $
	C    R9,*R7		OFF SCREEN ?
	JGT  CHKRET		BRIF NO, JUST RETURN
*
*  I AM OFF THE SCREEN, DO A SCROLL OPERATION LINE BY LINE
*
	MOV  R8,R0		ELSE, SCROLL THE SCREEN
	NEG  R0	  		 - LINE SIZE
SCROL1	EQU  $
	A    R8,R0		DOWN 2 LINES
	A    R8,R0
	BL   @SETVDP		SETUP FOR VDP READ/WRITE
SCROL2	EQU  $
	MOVB @VDPRD,*R1+  	READ A BYTE
	DEC  R2
	JNE  SCROL2		BRIF MORE
*
SCROL3	EQU  $
	C    R0,R9		END OF SCREEN?
	JLT  SCROL6
	JEQ  SCROL4
	S    R8,*R7		ELSE, ADD 1 LINE & CHECK AGAIN
	JMP  CHKOFF
*
SCROL4	EQU  $
	BL   @SETCPU
SCROL5	EQU  $
	MOVB @BLANK,*R1+
	DEC  R2
	JNE  SCROL5
SCROL6	EQU  $
	S    R8,R0		WRITE TO PREVIOUS LINE
	ORI  R0,>4000		OR IN WRITE BIT
	BL   @SETVDP		SETUP VDP REGISTERS
SCROL7	EQU  $
	MOVB *R1+,@VDPWD  	WRITE A BYTE TO SCREEN
	DEC  R2
	JNE  SCROL7		BRIF MORE
	JMP  SCROL1
*
CHKRET	EQU  $
	B    *R12	 	RETURN
*
*  GETBYT - GET A BYTE FROM CPU RAM I/O BUFFER.  WATCHES OUT FOR
*	    EXCEEDED BYTE COUNT, AND TERMINATING CHARACTER.
*
GETBYT	EQU  $
	CLR  R1
	DEC  R6			DECREMENT BYTE COUNT
	JLT  GETBY1		IF TOO MANY, TERMINATE
	MOVB *R4+,R1		GET A CHAR FROM I/O BUFFER
	B    *R11
GETBY1  EQU  $
	MOVB @TERCHA+1,R1	GET TERMINATING CHARACTER
	JEQ  GETBY2		BRIF NONE, I'M DONE
	CLR  @TERCHA
	B    *R11		RETURN TERMINATING CHARACTER
*	
GETBY2  EQU  $	
	LI   R1,>FF00		PRETEND I READ A TERMINATOR
	B    *R11
*				QUICK VDP SINGLE BYTE BLANK
QBSCR	EQU  $
	MOV  @BLANK,R1
*				QUICK SCREEN WRITE (W/X-Y OFFSET)
QSCRW	EQU  $
	MOV  *R7,R0
*				QUICK VDP SINGLE BYTE WRITE
QVSBW	EQU  $
	ORI  R0,>4000
	SWPB R0
	MOVB R0,@VDPWA
	SWPB R0
	MOVB R0,@VDPWA
	ANDI R0,>3FFF
	MOVB R1,@VDPWD
	B    *R11
*				QUICK VDP SINGLE BYTE READ
QVSBR	EQU  $
	CLR  R1
	SWPB R0
	MOVB R0,@VDPWA
	SWPB R0
	MOVB R0,@VDPWA
	NOP
	MOVB @VDPRD,R1
	B    *R11
*
*  KEYSET : KEYBOARD SCAN ROUTINE
*
KEYSET	EQU  $
	LIMI 2			ENABLE INTERRUPTS
	LWPI GPLWS
	LIMI 0			DISABLE INTERRUPTS
	BL   @SCAN		SCAN KEYBOARD
	LWPI WORKS2		RELOAD OLD WORKSPACE
	LI   R1,>8000		MASK THE FOUND KEY IN KEYFND
	SZCB R1,@KEYFND		CAUSE GENEVE MESSES IT UP
	MOVB @GPLSTA,R1
	ANDI R1,>2000		MASK KEY DEPRESSED OR NOT FLAG
	B    *R11		 & RETURN
*
*  SETVDP : SET VDP REGISTERS ROUTINE
*
SETVDP	EQU  $
	SWPB R0
	MOVB R0,@VDPWA		SET WRITE ADDRESS
	SWPB R0
	MOVB R0,@VDPWA
	ANDI R0,>3FFF		RESET WRITE BIT
SETCPU	EQU  $
	LI   R1,RESFIL
	MOV  R8,R2
	B    *R11
*
*  TABLE OF SPECIAL FUNCTIONS:
*
TABSTR	EQU  $
	BYTE 3,5,6,8,15,0
*
*  TABLE OF SPECIAL QUALIFIERS
*
SPOUT1	EQU  $+1
SPOUTC	EQU  $
	BYTE >FF,>0C,>1B,>0D,>0A,>00
EQUALS	TEXT '='
	EVEN
*
SPOUTT	EQU  $
	DATA SCRLRE		FF TERMINATOR
	DATA CLS		0C FORM FEED
	DATA POSCUR		1B ESCAPE
	DATA JMPLIN		0D CARRIAGE RETURN
	DATA SCRLOU		0A LINE FEED
*
TABJMP	EQU  $
	DATA DELIT		03 DELETE CHARACTER
	DATA QUITIT		05 QUIT
	DATA REDOIT		06 REDO
	DATA DELIT		08 LEFT CURSOR
	DATA BACKIT		0F BACK
	DATA SETBLK     	00 NULL
	TITL 'UTILITY SUBROUTINES'
*
*  THIS MODULE CONTAINS COMMONLY USED UTILITY SUBROUTINES.
*
*  	XMLLNK - LINK TO CONSOLE ROUTINES
*  	KSCAN  - SCAN KEYBOARD
*  	DSRLNK - DEVICE SERVICE ROUTINE LINKAGE
*  	VSBR   - VDP SINGLE BYTE READ
*  	VSBW   - VDP SINGLE BYTE WRITE
*  	VMBR   - VDP MULTI-BYTE READ
*  	VMBW   - VDP MULTI-BYTE WRITE
*  	VWTR   - VDP WRITE REGISTERS
*	VRFR   - VDP READ REGISTERS (ACTUALLY, STORED VALUES)
*
*  THIS MODULE ALSO CONTAINS THE REAL-TIME CLOCK INTERRUPT ROUTINE.
*
*  XMLLNK : CONSOLE LINKAGE
*
BXMLLN	EQU  $
	LIMI 0			DISABLE INTERRUPTS
	MOV  *R14+,@GPLWS+2 	SAVE ROUTINE NUMBER
	LWPI GPLWS	  	GET GPL WORKSPACE
	MOV  R11,@WORKS1+22 	SAVE RETURN IN MY WORKSPACE
	MOV  R1,R2
	SRL  R1,12
	SLA  R1,1
	SLA  R2,4
	SRL  R2,11	  	COMPUTE TABLE INDEX
	A    @TBLSTR(R1),R2
	MOV  *R2,R2	 	GET ADDRESS
	BL   *R2		EXECUTE ROUTINE
	JMP  XMLRTC
*
*  KSCAN : KEYBOARD SCANNER
*
BKSCAN	EQU  $
	LIMI 0			DISABLE INTERRUPTS
	LWPI GPLWS
	MOV  R11,@WORKS1+22
	BL   @SCAN	  	SCAN KEYBOARD
XMLRTC	EQU  $
	LWPI WORKS1
	MOV  R11,@GPLWS+22
	RTWP
*
*  VSBW : VDP SINGLE BYTE WRITE
*
BVSBW	EQU  $
	BL   @VSETUW		SETUP FOR VDP PROCESSING
	MOVB @2(R13),@VDPWD
	RTWP
*
*  VMBW : VDP MULTI BYTE WRITE
*
BVMBW	EQU  $
	BL   @VSETUW
MBWNXT	EQU  $			WRITE UNTIL BYTE COUNT EXHAUSTED
	MOVB *R1+,@VDPWD
	DEC  R2
	JNE  MBWNXT
	RTWP
*
*  VSBR : VDP SINGLE BYTE READ
*
BVSBR	EQU  $
	BL   @VSETUR
	MOVB @VDPRD,@2(R13)
	RTWP
*
*  VMBR : VDP MULTI BYTE READ
*
BVMBR	EQU  $
	BL   @VSETUR
MBRNXT	EQU  $			READ UNTIL BYTE COUNT EXHAUSTED
	MOVB @VDPRD,*R1+
	DEC  R2
	JNE  MBRNXT
	RTWP
*
*  VWTR : VDP WRITE REGISTER.   A COPY OF THE LAST WRITTEN REGISTER
*	  VALUES ARE KEPT IN THE ARRAY VDPSTB.
*
BVWTR	EQU  $
	LIMI 0
	MOV  *R13,R1		GET R0 VALUE
	MOVB @1(R13),@VDPWA
	ORI  R1,>8000
	MOVB R1,@VDPWA
	ANDI R1,>0F00		GET REGISTER NUMBER
	SRA  R1,8		IN LOW BYTE
	MOVB @1(R13),@VDPSTB(R1)
	RTWP
*
*  VRFR : VDP READ REGISTER (PLAY BACK FROM ARRAY)
*         CALL WITH REGISTER # IN R1, RETURNS VALUE IN R0.L
*
BVRFR	EQU  $
	MOV  @2(R13),R1		GET VDP REGISTER
	ANDI R1,>F
	CLR  R0
	MOVB @VDPSTB(R1),R0
	SWPB R0
	MOV  R0,*R13		SAVE IN USER R0
	RTWP
*
*  VSETUR - SETUP FOR VDP READ
*  VSETUW - SETUP FOR VDP WRITE
*
VSETUW	EQU  $
	LI   R1,>4000
	JMP  VSETUC
VSETUR	EQU  $
	CLR  R1
VSETUC	EQU  $
	LIMI 0			DISABLE INTERRUPTS
	MOV  *R13,R2		GET USER R0 IN MY R2
	SOC  R2,R1		OR IN WRITE BIT
	SWPB R1
	MOVB R1,@VDPWA		SET LOW ADDRESS (FROM MY R1)
	SWPB R1
	MOVB R1,@VDPWA		SET HIGH ADDRESS (FROM MY R1)
	MOV  @2(R13),R1		GET USER CPU RAM ADDRESS (IN MY R1)
	MOV  @4(R13),R2		GET NUMBER BYTES TO READ/WRITE (IN MY R1)
	B    *R11
* 
*  DSRLNK - Link to Device Service Routine
*
BDSRLN	EQU  $		Beginning of DSR routine
	LIMI 0
	MOV  *R14+,R5     	Begin of DSR routine
	SZCB @SETVAL,R15
	MOV  @DSRPTR,R0
	MOV  R0,R9
	AI   R9,-8
	BL   @QVSBR		Read length of device name
	MOVB R1,R3		 or subroutine name
	SRL  R3,8
	SETO R4
	LI   R2,FNAME		 into FNAME save area
DSR1	EQU  $
	INC  R0
	INC  R4
	C    R4,R3
	JEQ  DSR2		Brif moved all
	BL   @QVSBR
	MOVB R1,*R2+
	CB   R1,@PERIOD		Is this the end?
	JNE  DSR1		Brif no
DSR2	EQU  $
	MOV  R4,R4
	JEQ  DSR10		Brif moved nothing, error
	CI   R4,>0007
	JGT  DSR10		Brif moved >6, error
	CLR  @>83D0
	MOV  R4,@>8354
	INC  R4
	A    R4,@DSRPTR
	LWPI GPLWS		DSR's use GPL workspace
	CLR  R1
	LI   R12,>0F00		Initial CRU address (->100)
DSR3	EQU  $
	MOV  R12,R12
	JEQ  DSR4
	SBZ  >0000
DSR4    EQU  $
	AI   R12,>0100		Bump CRU address
	CLR  @>83D0
	CI   R12,>2000		Past DSR's?
	JEQ  DSR9		Brif yes
	MOV  R12,@>83D0
	SBO  >0000		Turn ON DSR
	LI   R2,>4000		Get header byte
	CB   *R2,@IMHERE	Is DSR here?
	JNE  DSR3		Brif NO
	A    @WORKS2+10,R2	Else, add >8 for I/O, >10 for subs
	JMP  DSR6
DSR5	EQU  $
	MOV  @>83D2,R2
	SBO  >0000
DSR6	EQU  $
	MOV  *R2,R2		Get word
	JEQ  DSR3
	MOV  R2,@>83D2
	INCT R2
	MOV  *R2+,R9
	MOVB @>8355,R5
	JEQ  DSR8
	CB   R5,*R2+
	JNE  DSR5
	SRL  R5,8
	LI   R6,FNAME		Area contains device or subr name
DSR7	EQU  $
	CB   *R6+,*R2+		Is this the one?
	JNE  DSR5		Brif no
	DEC  R5
	JNE  DSR7		Try next
DSR8	EQU  $			Found it!
	INC  R1
	BL   *R9		Go do it
	JMP  DSR5		Error Return
	SBZ  >0000		Turn OFF DSR
	LWPI WORKS2		Restore my workspace
	MOV  R9,R0
	BL   @QVSBR		Save status in PAB
	SRL  R1,13
	JNE  DSR11
	JMP  DSR12
DSR9	EQU  $
	LWPI WORKS2
DSR10	EQU  $
	CLR  R1
DSR11	EQU  $
	SWPB R1
	MOVB R1,*R13
	SOCB @SETVAL,R15	Set status bit saying BAD
DSR12   EQU  $
	RTWP			RETURN
*
*  USER INTERRUPT ROUTINE.  KEEP TIME IN DOUBLE WORD
*  CLOCK AT CLOCK1, CLOCK2.
*
CLKINT	EQU  $
	INC  @COUNTT		INCREMENT COUNTDOWN TIMER
	JNE  CLKRET	 	BRIF NOT TIME (1/10 SECOND)
*			  	RESET COUNTDOWN TIMER
	MOV  @COUNTS,@COUNTT
	INC  @DCLOCK2		INCREMENT SECOND WORD CLOCK
	JNE  CLKRET
	INC  @DCLOCK1		OVERFLOW INTO FIRST CELL
CLKRET	EQU  $
	B    *R11	   	RETURN
*
*  GPLLNK : This program allows calls to Grom routines
*
* PAGE 10 JULY 1986 SMART PROGRAMMER 
* GPLLNK- A universal GPLLNK -6/21/85 -MG
*
* This routine will work with any GROM library Slot since it is 
* indexed off of R-13 in the GPLWS. (It does require memory Expansion) 
* This GPLLNK does NOT require a module to be plugged into 
* the GROM port so it will work with the Editor/Assembler, 
* Mini Memory (with Memory exapnsion), XB, The Myarc 
* CALL LR("DSKx.xxx") or the Cor Comp Disk manager loaders. 
* It saves and restores the current GROM Address in case  you want 
* to return back to GROM for Basic or XB CALL LINKs 
* or to return to the loading module. 
* *   ENTER: The same way as the E/A GPLLNK ie: BLWP @GPLLNK 
*                                               data >34 
* *   Notes: Do not REF GPLLNK when using this routine in your code 
* *  70 Bytes -including the GPLLNK  Workspace 
* *

GR4	EQU  GPLWS+8      	GPL Workspace R4
GR6	EQU  GPLWS+12     	GPL Workspace R6 
LDGADD	EQU  >60          	Load & Execute GROM address entry point 
GETSTK	EQU  >166C

GXMLAD	DATA >176C		R10   GROM Address for GPL XML (0F 27 Opcode)
	DATA >50    		R11   Initialized to >50 where PUTSTK address resides

GLNKWS	EQU  $->18             	GPLLNK'S Workspace of which only
FNAME	EQU  $			ALSO USED FOR TEMPS FOR DSRLNK
	BSS  >08    		R12-R15   registers R7 through R15 are used

GLINK1	MOV  *R11,@GPLWS+8	Put PUTSTK Address in R4 of GPL WS
	MOV  *R14+,@GPLWS+12	Put GPL Routine Address in R6 of GPL WS
	LWPI GPLWS		Load GPL WS
	BL   *R4                Save current Grom address on stack
	MOV  @GXMLAD,@>8302(R4)	Push GPL XML Add on stack for GPL RTurn
	INCT @SUBSTK		Adjust the stack pointer
	B    @LDGADD		Execute our GPL routine

XMLRTN	MOV  @GETSTK,R4		Get GETSTK Pointer
	BL   *R4		Restore GROM address off the stack
	LWPI GLNKWS		Load our WS
	RTWP			All done -return to caller
SEND	EQU  $
*
*  FOLLOWING I/O TABLE MUST BE CONTAINED WITHIN E/A OBJECT SINCE IT
*  MUST BE ZEROED ON INITIALIZATION
*
IOTABL	EQU  $
	DATA 0,0,0,0		FILE 1
	DATA 0,0,0,0		FILE 2
	DATA 0,0,0,0		FILE 3
	DATA 0,0,0,0		FILE 4
	DATA 0,0,0,0		FILE 5
	DATA 0,0,0,0		FILE 6
	DATA 0,0,0,0		FILE 7
	DATA 0,0,0,0		FILE 8
*
*  WORKSPACES FOR MY SUBROUTINES AND UTILITIES
*
*WORKS1	EQU  >8320		WORK SPACE 1
*WORKS2	EQU  >8326		WORK SPACE 2
*
WORKS1	DATA 0,0,0
*
WORKS2	DATA 0,0,0,0,0,0,0,0
	DATA 0,0,0,0,0,0,0,0
*
WORKS3	DATA 0,0,0,0,0,0,0,0
	DATA 0,0,0,0,0,0,0,0
*
SELOPT	DATA 0			SELECTED OPTION
*
*  PAB FOR SAVING/RESTORING A SEGMENT
*
RESPAB	EQU  $
	DATA >0500	LOAD PROGRAM RESTORE OPCODE
RESBUF	EQU  $
	DATA MODSTA	BUFFER START
	DATA 0
RESBYT	EQU  $
	DATA 8192
	BYTE 0
RESFIL	EQU  $		SAVE FILE ENTRY & 80 BYTE SCREEN BUFFER
	BYTE 0,0,0,0,0,0,0,0,0,0
	BYTE 0,0,0,0,0,0,0,0,0,0
	BYTE 0,0,0,0,0,0,0,0,0,0
	BYTE 0,0,0,0,0,0,0,0,0,0
	BYTE 0,0,0,0,0,0,0,0,0,0
	BYTE 0,0,0,0,0,0,0,0,0,0
	BYTE 0,0,0,0,0,0,0,0,0,0
	BYTE 0,0,0,0,0,0,0,0,0,0
	EVEN
*
*  TABLE WHICH SAVES A COPY OF THE LATEST VALUE STORED IN EACH VIDEO
*  REGISTER
*
VDPSTB	EQU  $
	DATA 0		0,1
	DATA 0		2,3
	DATA 0		4,5
	DATA 0		6,7
	DATA 0		8,9
	DATA 0		10,11
	DATA 0		12,13
*
ENDME1	EQU  $
	END
