	TITL  'BINARY I/O READS AND WRITES'
	IDT   'BINIO'
*
*   BINIO  :  PERFORM BINARY READ OR WRITE TO A DISK FILE
*
*   THE BINIO SUBROUTINE IS CALLED TO PERFORM AN MDOS BREAD OR BWRITE
*   COMMAND.   THE COMMANDS ARE AS FOLLOWS:
*
*	CALL BREAD ( FILE, SECTOR OFFSET, NUMBER SECTORS, BUFFER, ERROR )
*	CALL LBREAD( FILE, SECTOR OFFSET, NUMBER SECTORS, LBUFADR, ERROR )
*
*	CALL BWRITE( FILE, SECTOR OFFSET, NUMBER SECTORS, BUFFER, ERROR )
*	CALL LBWRIT( FILE, SECTOR OFFSET, NUMBER SECTORS, LBUFADR, ERROR )
*
*   WHERE:
*
*	FILE : 	  IS THE NAME OF THE FILE TO READ OR WRITE
*
*	SECTOR :  IS THE SECTOR OFFSET TO READ/WRITE, 0 TO N
*	OFFSET
*
*	NUMBER :  IS THE NUMBER OF SECTORS TO READ/WRITE
*	SECTORS
*
*       BUFFER :  IS THE BUFFER OF DATA READ OR TO BE WRITTEN
*	LBUFADR : IS THE LONGWORD ADDRESS OF DATA TO BE READ OR WRITTEN
*
*	ERROR  :  IS ANY ERROR CODE RETURNED (0=GOOD I/O)
*
*  Update History:
*
*    V4.0  28-October-1988:  MDOS/GPL compatible version
*
*          23-dec-1988:      Fixed error code, and added long entry
*
*  Copyright 1988 by LGMA Products
*
*  DEFINITIONS:
*
	DEF  BREAD		BINARY READ
	DEF  LBREAD		LONG BINARY READ
	DEF  BWRITE		BINARY WRITE
	DEF  LBWRIT		LONG BINARY WRITE
*
*  EQUATES:
*
	COPY "FORTPAR:"
	UNL
	COPY "EQUATES:IO.EQ9"
	COPY "EQUATES:UTIL.EQ9"
	COPY "EQUATES:FORTEX.EQ9"
	LIST
*
MAXLEN	EQU  40			MAXIMUM LENGTH OF A FILE NAME (BYTES)
*
*  BINARY READ/WRITE ROUTINE
*
BREAD	EQU  $
	DATA -5			5 ARGUMENTS
	DATA TEMPS
	LI   R0,OPCBRE		DO BINARY READ
	JMP  SIOCOM
*
*  LONGWORD BINARY READ ROUTINE
*
LBREAD	EQU  $
	DATA -5
	DATA TEMPS
	LI   R0,OPCBRE
	JMP  LIOCOM
*
BWRITE	EQU  $
	DATA -5			5 ARGUMENTS
	DATA TEMPS
	LI   R0,OPCBWR
	JMP  SIOCOM
*
LBWRIT	EQU  $
	DATA -5
	DATA TEMPS
	LI   R0,OPCBWR
	JMP  LIOCOM
*
*  SHORT I/O COMMON
*
SIOCOM	EQU  $
	MOV  @ABUFFE,@BUFADR	SET BUFFER ADDRESS
	CLR  @BUFADR-2		CLEAR HIGH
	JMP  IOCOMM
*
LIOCOM	EQU  $
	MOV  @ABUFFE,R5		GET ADDRESS OF BUFFER
	MOV  *R5+,@BUFADR-2
	MOV  *R5,@BUFADR	SET BUFFER ADDRESS
	JMP  IOCOMM
*
*  STUFF PAB WITH ALL THE GOOD STUFF FOR TRANSFER
*
IOCOMM	EQU  $
	SWPB R0			SET FUNCTION CODE IN PAB
	MOVB R0,@PAB
	CLR  R0
	MOVB R0,@PABERC		CLEAR ANY ERROR CODE IN PAB
	MOV  @ASECTO,R5
	MOV  *R5,@SECTOR	SET SECTOR OFFSET
	MOV  @ANUMSE,R5
	MOV  *R5,@NUMSEC	SET NUMBER OF SECTORS
*
*  CALL THE UTILITY TO PARSE THE GIVEN USER FILE NAME INTO THE
*  FILE PAB.
*
	LI   R5,MAXLEN		SET MAX LENGTH OF FILE NAME
	SWPB R5
	MOVB R5,@FILELN		SET IT IN PAB
*
	LI   R0,PARFIL		PARSE THE FILE NAME
	MOV  @AFILEN,R1		INPUT STRING
	LI   R2,FILELN		OUTPUT STRING (LENGTH BYTE)
	CLR  R3
	XOP  @DUTLXP,0		DO IT
*
*  NOW PERFORM THE I/O OPERATION REQUESTED
*
	LI   R0,PAB		ADDRESS OF PAB
	XOP  @DIOXOP,0		DO IT
*
	CLR  R5
	MOVB @PABERC,R5		GET ERROR CODE (IF ANY)
	SRA  R5,13		RIGHT JUSTIFY
	ANDI R5,>7
	JEQ  JUSTRE		IF NONE, THEN RETURN
	INC  R5			ELSE, ADD ONE
JUSTRE	EQU  $
	MOV  @AERROR,R6		SET ERROR IN RESPONSE
	MOV  R5,*R6
	MOV  @TEMPS,R3		RESTORE BASE
	B    *R11		RETURN
*
*  DATA AREA
*
DIOXOP	DATA IOXOP		INPUT/OUTPUT XOP NUMBER
DUTLXP	DATA UTLXOP		UTILITY XOP NUMBER
*
*  ARGUMENTS PASSED BY MAIN ROUTINE
*
TEMPS	BSS  4			R3 + R11
AFILEN	BSS  2			FILE NAME
ASECTO	BSS  2			SECTOR OFFSET
ANUMSE	BSS  2			NUMBER OF SECTORS
ABUFFE	BSS  2			BUFFER OF DATA TO READ/WRITE
AERROR	BSS  2			ANY ERROR RETURNED
*
*  PERIPHERAL ACCESS BLOCK (CPU RAM COPY)
*
PAB	EQU  $
	BYTE 0			>A FOR BREAD, >B FOR BWRITE
	BYTE 0
PABERC	BYTE 0			ERROR CODE RETURNED
	BYTE 0			BUFFER ADDRESS (HIGH)
BUFADR	DATA 0			BUFFER ADDRESS (LOW)
SECTOR	DATA 0			SECTOR OFFSET TO READ/WRITE
	DATA 0
	BYTE 0			TRANSFER FLAG (0=CPU)
	BYTE 0
NUMSEC	DATA 0			NUMBER OF SECTORS TO READ/WRITE
	BYTE 0
FILELN	BYTE 0
FILENM	BSS  MAXLEN		FILE NAME TO READ/WRITE
	EVEN
	END	
