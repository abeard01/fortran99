	TITL  'GOUSER - BREAKPOINT INTERFACE ROUTINE'
	IDT   'GOUSER'
*
*  GOUSER - This routine is called when the user wants to execute
*	    the user program.  The calling sequence is:
*
*		call breakh ( wsp )
*
*	    where "wsp" is a nineteen element array that contains
*	    the following information:
*
*		1 PC   -  Program Counter
*		2 SR   -  Status Register
*		3 WSP  -  Workspace Pointer
*		4 WS   -  16 Workspace Registers (@>f000)
*
*	    The subroutine maps in the low & high memory breakpoint
*	    handlers, and then "swaps" memory with the user program
*	    (moves debugger to pages 8-15, moves application to pages
*	    0-7) and then starts user program at given PC.
*
*	    On breakpoint, an XOP is executed that causes the user
*	    application & debugger to again be swapped, and then
*	    executes the debugger.
*
*  17-June-1991  A.L.Beard  Rewrite to avoid use of high memory >fd00
*			    to >ffff.
*
*  Now uses locations >4c to >
*
*  Equates:
*
	UNL
	COPY  "EQUATES:MEM.EQ9"
	LIST
*
*  Def/Ref's:
*
	DEF  BREAKH
	DEF  INITBR
*
*  Equates:
*
XOPNUM	EQU  3			WHICH XOP I AM USING (3)
XOPLOC  EQU  4*XOPNUM+>40	XOP LOCATION, WHERE XOP IS
*XOPREG	EQU  >F0A0		WHERE THE BREAKPOINT WORKSPACE IS
XOPREG	EQU  >00B4		HOLE IN LOW MEMORY FOR WORKSPACE
HIGHME	EQU  >E000		HIGH MEMORY HANDLER START ADDRESS
USRWSP	EQU  >F000		WHERE THE DEBUGGER WORKSPACE IS
*
*  INITBR - FOR COMPATIBILITY (UNUSED)
*
INITBR	EQU  $
	DATA -2			2 ARGUMENTS
	DATA TEMPS
	MOV  @TEMPS,R3		RESTORE R3
	B    *R11		; RETURN
*
BREAKH	EQU  $
	DATA -1			1 ARGUMENT
	DATA TEMPS
*
	LIMI 0
*
*  MOVE IN LOW MEMORY HANDLER
*
	LI   R0,STARTL
	LI   R1,XOPLOC
	LI   R2,LOWSIZ
	BL   @MOVMEM
*
*  GET MEMORY MAP
*
	LI   R0,GETMAP
	LI   R1,MEMMAP
	LI   R2,16		ONLY GET 16 PAGES
	XOP  @DMEMXP,0
*
*  MOVE IN HIGH MEMORY HANDLER
*
	MOVB @MEMMAP+8,@MMRREG+7
	LI   R0,STARTH
	LI   R1,HIGHME
	LI   R2,HIGSIZ
	BL   @MOVMEM
*
*  BRANCH TO THE HIGH MEMORY BREAKPOINT HANDLER
*
	LI   R4,HIGHME		HIGH MEMORY HANDLER START (@>E000)
	BL   @GOUSR1		DO IT
*				MAP IN MY NORMAL PAGE 7
	MOVB @MEMMAP+7,@MMRREG+7
	MOV  @TEMPS,R3
	MOV  @TEMPS+2,R11
	B    *R11		; RETURN
*
*  DATA AREA
*
TEMPS	BSS  4
AREGIS	BSS  2			REGISTER ARRAY (19 ELEMENTS)
	BSS  2			DUMMY (FOR INITBR DUMMY)
*
DMEMXP	DATA MEMXOP		MEMORY XOP NUMBER
*
*  MOVMEM - MOVE MEMORY ROUTINE
*
*		R0 - HAS MOVE "FROM" ADDRESS
*		R1 - HAS MOVE "TO"   ADDRESS
*		R2 - HAS # OF BYTES TO MOVE
*
MOVMEM	EQU  $
	MOV  *R0+,*R1+
	DECT R2
	JNE  MOVMEM
	B    *R11
*=======================================================================
*  LOW MEMORY BREAKPOINT HANDLER START
*
STARTL	EQU  $
	DATA XOPREG			; 4c
	DATA LOWHAN			; 4e
LOWHAN	EQU  $-STARTL+XOPLOC
	MOVB @MEMMAP+8,@MMRREG+7	; 50
	B    @GOUSR4			; 56	
*
GOUSR3	EQU  $-STARTL+XOPLOC
*					; MAP IN MY NORMAL PAGE 7
	MOVB @MEMMAP+7,@MMRREG+7	; 5a
	RTWP				; 60 GO TO USER PROGRAM
*
LOWSIZ	EQU  $-STARTL
MEMMAP	EQU  $-STARTL+XOPLOC
*
*  LOW MEMORY BREAKPOINT HANDLER END
*=======================================================================
*
*  HIGH MEMORY BREAKPOINT HANDLER START
*
STARTH	EQU  $
GOUSR1	EQU  $-STARTH+HIGHME
	LIMI 0
	LWPI XOPREG		; LOAD MY WORKSPACE POINTER
	LI   R4,HIGHME		; POINTER TO MY START
*
*  COPY IN USER WSP, PC + SR INTO MY REGISTER AREA 
*
	MOV  @AREGIS,R5		; GET POINTER TO IT
	MOV  *R5+,R13
	MOV  *R5+,R14
	MOV  *R5+,R15
*
	LI   R1,SAVDEB		; REGISTER SAVE AREA
	LI   R2,>80		; MOVE 80 BYTES
*
GOUSR2	EQU  $
	MOV  *R5+,*R1+
	DECT R2
	JNE  GOUSR2
*
*  NOW SWAP USER TASK & DEBUGGER
*
	BL   @TABSWP		; SWAP IT
	LIMI 2			; ENABLE INTERRUPTS
	B    @GOUSR3		; GO DO USER TASK
*
*  GOUSR4 - EXECUTE THE RETURN FROM THE BREAKPOINT.  I MUST SWAP
*	    BACK IN THE DEBUGGER, SAVE THE SPACE FROM >F000 TO >F07F,
*	    AND RECALL THE USER TASK
*
GOUSR4	EQU  $-STARTH+HIGHME
	LIMI 0			; DISABLE INTERRUPTS
	BL   @TABSWP		; SWAP THE SPACES
*
	MOV  @AREGIS,R5		; USER REGISTER POINTER
	DECT R14		; ADJUST PC (TAKE INTO ACCOUNT XOP)
	MOV  R13,*R5+
	MOV  R14,*R5+
	MOV  R15,*R5+
	LI   R1,SAVDEB
	LI   R2,>80
*
GOUSR5	EQU  $
	MOV  *R1+,*R5+
	DECT  R2
	JNE   GOUSR5
*
*  SET POINTER TO USER WORKSPACE, & RETURN
*
	LWPI  USRWSP
	LIMI  2
	B     *R11
*
*  SWAP USER TASK & DEBUGGER
*
TABSWP	EQU  $-STARTH+HIGHME
	MOV  R11,R10
	LI   R5,TABLE		; TABLE OF ADDRESSES TO SWAP
TABLOP	EQU  $
	MOV  *R5+,R0		; START ADDRESS TO SWAP
	JEQ  TABEND
	MOV  *R5+,R1		; END ADDRESS TO SWAP
	MOV  *R5+,R2		; # OF BYTES TO SWAP
	MOV  *R5+,R6		; START PAGE TO POKE
	MOV  *R5+,R7		; PAGE NUMBER TO POKE
	MOVB @MEMMAP(R7),@MMRREG(R6)
	MOV  *R5+,R6		; START PAGE TO POKE
	MOV  *R5+,R7		; PAGE NUMBER TO POKE
	MOVB @MEMMAP(R7),@MMRREG(R6)
	BL   @SWAPME
	JMP  TABLOP
*
TABEND	EQU  $
	MOV  @MEMMAP,@MMRREG	; RESTORE MAP REGISTERS
	MOV  @MEMMAP+2,@MMRREG+2
	MOV  @MEMMAP+4,@MMRREG+4
	MOVB @MEMMAP+6,@MMRREG+6
*
*  SWAP THE USER SPACE
* 
	LI   R0,>F000		; SAVE FROM >F000 TO >F07F
	LI   R1,SAVDEB
	LI   R2,>80
	BL   @SWAPME
	B    *R10
*
*  SWAPME - SWAP MEMORY CONTENTS
*
SWAPME	EQU  $-STARTH+HIGHME
SWAPM1	EQU  $
	MOV  *R0,R6		; GET 1ST WORD TO SWAP
	MOV  *R1,*R0+
	MOV  R6,*R1+
	DECT R2
	JNE  SWAPM1
	B    *R11
*
*  THE FOLLOWING TABLE IS USED TO CONTROL THE SWAPPING OF MEMORY.
*  EACH ENTRY DEFINES:
*
*	A. MOVE "FROM" ADDRESS
*	B. MOVE "TO"   ADDRESS
*	C. NUMBER OF BYTES TO MOVE
*	D. PAGE NUMBER TO MAP "MOVE FROM" PAGE INTO
*	E. PAGE NUMBER TO MAP "MOVE FROM" PAGE FROM
*	F. PAGE NUMBER TO MAP "MOVE TO"   PAGE INTO
*	G. PAGE NUMBER TO MAP "MOVE TO"   PAGE FROM
*
*  TABLE IS TERMINATED BY ZERO "MOVE FROM" ADDRESS
*
TABLE	EQU  $-STARTH+HIGHME
	DATA >0400,>2400,>1C00,0,0,1,8
	DATA >2000,>4000,>2000,1,1,2,9
	DATA >4000,>2000,>2000,2,2,1,10
	DATA >6000,>2000,>2000,3,3,1,11
	DATA >8000,>2000,>2000,4,4,1,12
	DATA >A000,>2000,>2000,5,5,1,13
	DATA >C000,>2000,>2000,6,6,1,14
	DATA >2000,>4000,>1000,1,7,2,15
	DATA >3140,>5140,>0EC0,1,7,2,15
	DATA 0
*
SAVDEB	EQU  $-STARTH+HIGHME
	BSS  >80
HIGSIZ	EQU  $-STARTH

*
*  END HIGH MEMORY BREAKPOINT HANDLER
*=======================================================================
	END
