	TITL  'BREAK HANDLER FOR FORTRAN DEBUGGER'
	IDT   'BREAK'
*
*  BREAK : THIS IS THE BREAK HANDLER FOR THE FORTRAN SYMBOLIC DEBUGGER.
*
*	   CALLING SEQUENCE:
*
*		CALL INITBR
*		CALL BREAKH  ( REGISTERS )
*
*  REGISTERS HAVE :
*
*	WSP, PC, SR, LOCATIONS >F000 TO >F07F
*
*  ON ENTRY TO THIS ROUTINE (FROM DEBUGGER), THE FOLLOWING TAKES PLACE:
*
*    1. MOVES A HANDLER TO HIGH RAM, IN BOTH THE DEBUGGER
*	RAM SPACE AND THE USER RAM SPACE.
*    2. BRANCHES TO THE HANDLER.
*    3. SWAPS THE 1ST TWO 64K BANKS, LOCATIONS >0400 TO >EFFF, AND
*	>F140 TO >FE00.
*    4. SAVES THE OLD DEBUGGER REGISTERS, AND MOVES THE
*       FORTRAN REGISTERS TO THE REGISTERS AT >F000 TO >F04F
*    5. GOES TO PROGRAM EXECUTION AT GIVEN PC.
*
*  ON A BREAK, THE FOLLOWING HAPPENS:
*
*    1. SWAPS THE 1ST TWO 64K BANKS, LOCATIONS >0400 TO >EFFF, AND
*       >F140 TO >FE00.
*    2. SAVES THE FORTRAN REGISTERS AT >F000 TO >F07F
*    3. RETURNS TO DEBUGGER.
*
	DEF  BREAKH		BREAK HANDLER
	DEF  INITBR		INITIALIZE ENTRY
*
	UNL
	COPY "EQUATES:MEM.EQ9"
	LIST
*
FORTWP	EQU  >F000		FORTRAN WORKSPACE ADDRESS
HANDAD	EQU  >FD00		HANDLER START ADDRESS
HANDW1	EQU  >FF90		HANDLER WORKSPACE ADDRESS (DEBUG)
HANDW2	EQU  >FFB0		HANDLER WORKSPACE ADDRESS (FORTRAN)
XOPNUM	EQU  3			XOP NUMBER USED FOR BREAK
*
XOPLOC	EQU  4*XOPNUM+>40	XOP START ADDRESS IN LOW RAM, WP, PC
*
INITBR	EQU  $			INITIALIZE BREAKPOINT HANDLER ENTRY
	DATA -2			TWO ARGUMENTS
	DATA TEMPS
	LI   R7,HANDAD		HANDLER START ADDRESS HIGH RAM
*
	LI   R0,HANDLE		MOVE MY COPY OF HANDLER
	MOV  R7,R1
	LI   R2,HANDEE-HANDLE
*
MOVHAN	EQU  $
	MOV  *R0+,*R1+
	DECT R2
	JNE  MOVHAN
*
*  GET THE (MAX) 32 PAGE MEMORY MAP INTO HIGH RAM HANDLER
*
	LI   R0,GETMAP		GET MEMORY MAP
	LI   R1,MEMMAP
	A    R7,R1
	LI   R2,32
	XOP  @DMEMXP,0
*
*  SETUP THE XOP VECTOR
*
	LI   R0,HANDW2
	MOV  R0,@XOPLOC		WORKSPACE POINTER
*
	LI   R0,BREAKE		BREAKPOINT ENTRY ADDRESS
	A    R7,R0
	MOV  R0,@XOPLOC+2
*
*  CALCULATE THE PAGES NEEDED TO BE SWAPPED FOR THE FORTRAN TASK.
*  THIS IS DETERMINED FROM THE PASSED ARGUMENTS, LOGEND AND DATSTR.
*
	LI   R4,HANDBG		GET HANDLER END ADDRESS
	A    R7,R4
	MOV  @ALOGEN,R5		GET LOGIC END ADDRESS
	MOV  *R5,R5
	JEQ  BREAKR		BRIF ZERO, NO PROGRAM YET
	MOV  @ADATST,R6
	MOV  *R6,R6
	LI   R3,>2000		STARTING ADDRESS TO MOVE
MOVENT	EQU  $
	C    R3,R5		IS ADDRESS BELOW LOGIC END?
	JH   TRYDAT		BRIF NO, ABOVE LOGIC END
	MOV  R5,R0		DETERMINE HOW MUCH ABOVE
	S    R3,R0
	JLT  LARGE		LARGE AMOUNT, NEED WHOLE PAGE
	CI   R0,>2000		IS IT MORE THAN A PAGE?
	JGT  LARGE		BRIF YES
	INCT R0
	JMP  SETTBL		SET TABLE ENTRY
*
TRYDAT	EQU  $
	C    R3,R6		IS ADDRESS BELOW DATA START?
	JH   LARGE		BRIF NO, MUST SWAP WHOLE THING
	MOV  R6,R0
	S    R3,R0		HOW MUCH BELOW?
	JLT  SKIPTB		MORE THAN A PAGE, SKIP ENTRY
	CI   R0,>2000		IS IT GREATER THAN A PAGE BELOW?
	JGT  SKIPTB		BRIF YES, SKIP PAGE
	MOV  R6,*R4+		DATA START IS STARTING ADDRESS
	NEG  R0			DETERMINE AMOUNT TO MOVE
	AI   R0,>2000
	MOV  R0,*R4+
	CI   R3,>2000		IS THIS THE >2000 PAGE?
	JEQ  SETPG4		BRIF YES
	LI   R1,1		OTHERWISE, OK TO USE PAGE 1
	MOV  R1,*R4+
	LI   R2,>2000		SET BASE ADDRESS
	JMP  SETPG5
SETPG4	EQU  $
	LI   R1,2
	MOV  R1,*R4+
	LI   R2,>4000		SET BASE ADDRESS
SETPG5	EQU  $
	MOV  R6,R1		DATA START
	S    R3,R1		 - PAGE START
	A    R2,R1		 + THIS PAGE START
	MOV  R1,*R4+		IS THE START ADDRESS TO USE
	JMP  SKIPTB
*
LARGE	EQU  $
	LI   R0,>2000		MOVE >2000 BYTES
*
SETTBL	EQU  $
	MOV  R3,*R4+		SET STARTING ADDRESS
	MOV  R0,*R4+		SET AMOUNT TO MOVE
	CI   R3,>2000		IS THIS THE >2000 PAGE?
	JEQ  SETPG2		BRIF YES, SET PAGE 2
	LI   R1,1		OTHERWISE, OK TO USE PAGE 1
	MOV  R1,*R4+
	LI   R1,>2000
	MOV  R1,*R4+
	JMP  SKIPTB
SETPG2	EQU  $
	LI   R1,2		USE PAGE 2
	MOV  R1,*R4+
	LI   R1,>4000
	MOV  R1,*R4+
SKIPTB	EQU  $
	AI   R3,>2000		SET ADDRESS TO NEXT PAGE
	CI   R3,>E000		AM I AT THE END?
	JNE  MOVENT		NO, MOVE ANOTHER ENTRY
BREAKR	EQU  $
	CLR  *R4+		SET TERMINATOR
	JMP  BRKRET		RETURN
*
BREAKH	EQU  $
	DATA -1			1 ARGUMENT
	DATA TEMPS
	LI   R7,HANDAD		BREAKPOINT HANDLER ADDRESS
	MOV  @AREGIS,R0		GET REGISTER START ADDRESS
	LI   R1,HANDW2+26	SET FORTRAN RETURN WSP R13, R14, R15
	MOV  *R0+,*R1+		SET PC
	MOV  *R0+,*R1+
	MOV  *R0+,*R1+
	LI   R1,SAVFOR
	A    R7,R1
	LI   R2,>F080-FORTWP
BRKWSP	EQU  $
	MOV  *R0+,*R1+		RESTORE FORTRAN REGISTERS
	DECT R2
	JNE  BRKWSP
*
	LI   R7,HANDAD		START OF HANDLER
	MOV  R7,@HANDW1+14
	BLWP *R7		GOTO HANDLER
*
*  RETURNS HERE AFTER BREAK ENCOUNTERED.  STUFF THE RETURNED WSP,
*  PC, AND SR INTO MY REGISTERS AND RETURN.
*
	MOV  @AREGIS,R0		GET USER REGISTER LOCATION
	LI   R1,HANDW2+26
	MOV  *R1+,*R0+		SET WSP
	MOV  *R1+,R5		GET PC
	DECT R5			DECREMENT (DUE TO XOP CALL)
	MOV  R5,*R0+		AND SAVE
	MOV  *R1+,*R0+		SET SR
	LI   R1,SAVFOR		GET SAVE AREA
	A    R7,R1		 + BASE
	LI   R2,>F080-FORTWP
RESLOP	EQU  $
	MOV  *R1+,*R0+
	DECT R2
	JNE  RESLOP
*
BRKRET	EQU  $			RETURN TO FORTRAN MAIN
	MOV  @TEMPS,R3		RETURN
	MOV  @TEMPS+2,R11
	B    *R11
*
TEMPS	BSS  4			TEMPORARY SAVE AREA
ALOGEN	EQU  $
AREGIS	BSS  2			REGISTER START ADDRESS
ADATST	BSS  2
*
DMEMXP	DATA MEMXOP		MEMORY MANAGER XOP NUMBER
XOPINS	XOP  R0,XOPNUM		XOP INSTRUCTION (INFORMATION ONLY)
*
*  THE FOLLOWING IS THE ACTUAL BREAK HANDLER.
*
HANDLE	EQU  $
	DATA HANDW1		HANDLER WORKSPACE POINTER
	DATA HANDAD+4		ENTRY
*
	BL   @SWAP(R7)		SWAP THE 64K MEMORY BANKS
*
*  TASKS HAVE BEEN SWAPPED.  SAVE THE DEBUGGER'S REGISTERS IN MY
*  SAVE AREA, AND SET THE USER WORKSPACE POINTER
*
	LI   R0,FORTWP		SAVE FROM >F000 TO >F080
	LI   R1,SAVDEB
	A    R7,R1
	LI   R2,SAVFOR
	A    R7,R2
	LI   R3,>F080-FORTWP
SAVLOP	EQU  $
	MOV  *R0,*R1+		SAVE A DEBUGGER WORKSPACE REGISTER
	MOV  *R2+,*R0+		RESTORE A FORTRAN REGISTER
	DECT R3
	JNE  SAVLOP
*
*  SET UP XOP #7 TO POINT TO THE BREAK HANDLER
*
*  NOW SET TO THE FORTRAN RETURN REGISTERS, AND RETURN TO THE
*  FORTRAN TASK.
*
	LWPI HANDW2		SET TO IT
	RTWP			AND GO INTO EXECUTION
*
*  ACTUAL BREAK HANDLER.  THIS IS ENTERED WHEN AN XOP IS EXECUTED.
*  IT SAVES THE CURRENT FORTRAN ENVIRONMENT (BY SAVING ADDRESSES
*  >F000 TO >F080), SWAPS THE 64K MEMORY BANKS, AND RETURNS TO
*  THE DEBUGGER.
*
BREAKE	EQU  $-HANDLE		BREAK ENTRY
	LWPI HANDW1		USE DEBUGGER WORKSPACE
*
	LI   R0,SAVFOR		SAVE THE FORTRAN REGISTERS
	A    R7,R0
	LI   R1,SAVDEB		AND RESTORE DEBUG REGISTERS
	A    R7,R1
	LI   R2,FORTWP
	LI   R3,>F080-FORTWP
RESLO1	EQU  $
	MOV  *R2,*R0+		SAVE A FORTRAN REGISTER
	MOV  *R1+,*R2+		RESTORE A DEBUGGER REGISTER
	DECT R3
	JNE  RESLO1
*
	BL   @SWAP(R7)		SWAP 64K MEMORY BANKS
*
	RTWP			WHEN DONE, RETURN TO FORTRAN WORKSPACE
*
*  SWAP THE 64K MEMORY BANKS
*
SWAP	EQU  $-HANDLE
	LI   R0,TABLE		TABLE WHICH CONTROLS SWAP
	A    R7,R0
*
MOVPAG	EQU  $
	MOV  *R0+,R1		GET STARTING ADDRESS
	JEQ  MOVDON		IF ZERO, THEN I AM DONE
*
	MOV  *R0+,R2		GET # OF BYTES TO MOVE
	MOV  *R0+,R3		GET MOVE TO PAGE NUMBER
	MOV  *R0+,R4		GET MOVE TO START ADDRESS
*
*  MAP IN DESIRED NEW PAGE
*
	MOV  R3,R5		PAGE I AM MAPPING TO
	AI   R5,MMRREG		 + MEMORY MAP OFFSET
*
	MOV  R1,R6		GET MOVE ADDRESS
	SRA  R6,13
	ANDI R6,>7
	AI   R6,MEMMAP
	AI   R6,8
	A    R7,R6
*
*  NOW MAP IN THE FORTRAN TASK PAGE AT THE GIVEN "MOVE TO" PAGE
*
	MOVB *R5,R9		SAVE PAGE I AM MAPPING OUT
	MOVB *R6,*R5
*
*  SWAP THE PAGE
*
MOVWOR	EQU  $
	MOV  *R1,R8		GET A WORD
	MOV  *R4,*R1+
	MOV  R8,*R4+
	DECT R2
	JNE  MOVWOR
	MOVB R9,*R5		RESTORE PAGE I MAPPED OUT
	JMP  MOVPAG
*
*  TASKS HAVE BEEN SWAPPED.  SAVE THE DEBUGGER'S REGISTERS IN MY
*  SAVE AREA, AND SET THE USER WORKSPACE POINTER
*
MOVDON	EQU  $			DONE WITH MOVE
	B    *R11		RETURN
*
*  SAVE AREAS.  MAINLY FOR SAVING THE HIGH-SPEED WORKSPACE REGISTERS.
*
SAVDEB	EQU  $-HANDLE		SAVE AREA FOR DEBUGGER REGISTERS
	BSS  >F080-FORTWP
*
SAVFOR	EQU  $-HANDLE		SAVE AREA FOR FORTRAN REGISTERS
	BSS  >F080-FORTWP
*
MEMMAP	EQU  $-HANDLE
	BSS  32			MY MEMORY MAP
*
*  THE FOLLOWING TABLE IS USED TO CONTROL THE MOVE OF THE 64K BANKS.
*  THE TABLE CONTAINS:
*
*     A. THE START ADDRESS TO MOVE FROM
*     B. THE NUMBER OF BYTES TO MOVE
*     C. THE "MOVE TO" PAGE NUMBER
*     D. THE "MOVE TO" PAGE START ADDRESS
*
TABLE	EQU  $-HANDLE
	DATA >0400,>2000->0400,1,>2400
	DATA >E000,>F000->E000,1,>2000
	DATA >F140,>FD00->F140,1,>3140
HANDBG	EQU  $-HANDLE
HANDEE	EQU  $			HANDLER END ADDRESS
HANSIZ	EQU  $-HANDLE+60
	END
